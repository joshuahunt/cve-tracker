#!/bin/bash
set -x

CVE_TRACKER="/home/johunt/projects/cve-tracker"
UBUNTU_TRACKER="/home/johunt/projects/ubuntu-cve-tracker"
STABLE_KERNEL="/home/johunt/projects/linux-stable"
LINUX_KERNEL="/home/johunt/projects/linux-2.6"

CVE_DB=$CVE_TRACKER/cve.db

DATE="$(date +%d%m%Y)"

# Basic db check and just look at the # of fields like so:
#awk '{ if (NF != 8) print $0 }' cve.db

# First thing, sync to the latest version of everything

# TODO: Catch errors in syncing
# Sync to latest $UBUNTU_TRACKER
pushd $UBUNTU_TRACKER
bzr merge
bzr commit -m "Merge $DATE from main branch"
popd

# Sync stable kernel
pushd $STABLE_KERNEL
git pull
popd

pushd $UBUNTU_TRACKER
cp $CVE_TRACKER/scripts/get-cves.sh $UBUNTU_TRACKER

if [ ! -e "$CVE_DB" ]; then
	echo "No CVE DB Found!"
	# TODO: Make this ask if we should create a new one
	exit 1
fi

cp $CVE_DB ${CVE_DB}.old

for x in active retired
do
	pushd $x > /dev/null
	../get-cves.sh
	popd > /dev/null
done > $CVE_TRACKER/cve.list

sort -k2 $CVE_TRACKER/cve.list > $CVE_DB

# FIXME: This doesn't just find just new ones. It finds ones which have changed.
# Will need to be able to handle the different cases eventually. Here's the ones I can
# think of now:
#	1. New CVE Entry
#	2. CVE Existed, upstream break commit added
#	3. CVE Existed, CVE Date updated
#

popd
pushd $STABLE_KERNEL
cp $CVE_TRACKER/scripts/xref-cve.sh $STABLE_KERNEL
./xref-cve.sh $CVE_DB

popd

# Think I should have a single db file which is generated from the cve.list, but
# you add the new items to the db file. When they are added to the file we also
# look to see where, if at all, it was fixed in the various longterm stable branches
# This way you only run this:
# stable_fix=$(git --no-pager log $branch --grep="commit $fix" --pretty=format:%H)
# on the new fixes, then we can change the parsing of the db file for the html
# generation. You can also look at the new ones and send out a mail with those
# in tow... 

# TODO: We should be checking the results into git here...
