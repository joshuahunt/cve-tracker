#!/bin/bash
set -x

source config

fields=([1]="Public Date" "CVE" "Break Date" "Break Commit" "Break Tag" "Linus Fix Date" "Linus Commit" "Linus Tag" "Stable Date" "Stable Commit" "Stable Tag")

# Field constants
PUBLIC_DATE=1
CVE=2
BREAK_DATE=3
BREAK_COMMIT=4
BREAK_TAG=5
LINUS_DATE=6
LINUS_COMMIT=7
LINUS_TAG=8
STABLE_DATE=9
STABLE_COMMIT=10
STABLE_TAG=11

get_fields_index() {
        local value="$1"

        for i in "${!fields[@]}"
        do
                if [ "${fields[$i]}" == "$value" ]; then
                        echo $i
                        break
                fi
        done
}

# Version compare
# Returns:
#	0: if both are equal
#	1: if ver1 > ver2
#	-1: if ver2 > ver1
#	255: err
cmp_ver() {
	local ver1=$1
	local ver2=$2
	local retval=0

	if [ "$ver1" == "$ver2" ]; then
		echo 0
		return
	fi

	if [[ "$ver1" == "-" || "$ver2" == "-" ]]; then
		echo 255
		return
	fi
	
	local result=$(echo -e "$ver1\n$ver2" | sort -V | awk 'NR > 1 { exit }; 1')

	if [ "$result" == "$ver1" ]; then
		retval="-1"
	elif [ "$result" == "$ver2" ]; then
		retval="1"
	fi

	echo $retval

}

get_stable_commit_tag() {
        local commit=$1

        pushd $STABLE_KERNEL > /dev/null
        if [ "$commit" != "-" ]; then
                git describe --contains $commit | awk -F- '{ print $1 }' | sed 's/^v\([2-9]\+\)\.\([0-9]\{1,2\}\)\.\([0-9]\{1,3\}\)\?.*/\1\.\2\.\3/'
        else
                echo $commit
        fi
        popd > /dev/null
}

get_commit_msg() {
	local commit=$1

	pushd $STABLE_KERNEL > /dev/null
	git log --stat -n 1 $commit
	popd > /dev/null
}

get_fix_and_date() {
	local ver="$1"
	local major="$2"
	local minor="$3"
	local git_branch="$4"
	local fix_id="$5"
	# Get the last tag on this stable branch
	local lasttag

	# Stable commits have the following in their commit log referencing the original commit they are based on:
	# Sasha format:
	#	[ Upstream commit e7e11f99564222d82f0ce84bd521e57d78a6b678 ]
	# Greg format:
	#	commit 966031f340185eddd05affcf72b740549f056348 upstream.
	# TODO: Add others as necessary. Hopefully they'll settle on a std format...
	local GREGKH="commit $fix_id upstream."
	local SASHA="\[ Upstream commit $fix_id \]"

	pushd $STABLE_KERNEL > /dev/null
	lasttag="$(git tag -l v${ver}.* | sort -V | tac | head -1)"

	# So we'll grep for these to find it in the log.

	git --no-pager log -n 1 v${ver}..$lasttag $git_branch --grep="$GREGKH" --grep="$SASHA" --date=short --pretty=format:"%H %cd"
	popd > /dev/null
}

valid_hash() {
	local commit=$1

	# Skip if the commit is '-' since we can't look that up AND
	# Ubuntu sometimes pushes local changes (those which they do not push upstream) and the fix tag will contain 'local*' so skip those and return "-" AND
	# it's a valid hex value 
	if [[ "$commit" != "-" && "$commit" != *"local"* && "$commit" =~ ^[[:xdigit:]]+$ ]]; then
		return 0
	else
		return 1
	fi
}

get_linus_commit_date() {
        local commit=$1
	local commit_ver=$2
	local ret="-"

        pushd $STABLE_KERNEL > /dev/null
	if valid_hash $commit; then
		ret="$(git log -n 1 $commit --date=short --pretty=format:%cd)"
		if [ $? -ne 0 ]; then
			ret="-"
		fi
	fi
	echo $ret
        popd > /dev/null
}

get_linus_tag() {
	local commit=$1
	local cve=$2
	local pos=$3
	local ret="-"
	local cached

	# TODO: A little skeptical of this right now, but it speeds it up so much it's worth going down this path
	cached=$(grep -m1 $cve ${CVE_DB}.old | grep $commit | awk '{ print $'$pos' }')
	if [[ -n "$cached" && "$cached" != "-" ]]; then
		echo "$cached"
		return
	fi

	pushd $STABLE_KERNEL > /dev/null

	if valid_hash $commit; then
		# Get the tag this commit went into
		ret="$(git describe --contains $commit | sed 's/v\([0-9]\+\.[0-9]\+\(-rc[0-9]\+\)\?\).*/\1/')"
		if [[ $? -ne 0 || -z "$ret" || ! "$ret" =~ ^[0-9]+\.[0-9]+(-rc[0-9]+)?$ ]]; then
			ret="-"
		fi
	fi

	echo $ret

	popd > /dev/null
}

get_cves() {
	local cve
	local bf

	ORIG_IFS="$IFS"
	# nullglob doesn't print the entries in the list for the for loop if they don't exist (ex: CVE-202*-*)
	shopt -s nullglob
	for cve in CVE-201[3-9]* CVE-202*-*
	do
		# Skip CVE if it's present in the override file
		if grep -q $cve $DB_PATH/override; then
			continue
		fi

		# Format in CVE files is usually
		# 
		# Patches_linux:
		# break-fix: - ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5

		# First question, does this CVE touch Linux?
		if grep -q Patches_linux: $cve; then

			date="$(grep PublicDate: $cve | awk '{ print $2 }')"

			# Example break/fix info in CVE file (where break is commit which caused the breakage):
			# Unknown break or fix are filled in with '-'
			# break-fix: - ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5
			# TODO: This has a flaw where it could grab a break-fix line from some other section of the CVE file and not
			#	from the Patches_linux: section. This is partially checked by verifying the commit hashes are valid
			#	later on, but we should probably do something more exact here to make sure the line we're pulling is
			#	from the right section.
			breakfix="$(egrep -i '^[[:space:]]*break-fix' $cve | awk '{ printf "%s,%s ", $(NF-1),$NF }')"

			for bf in $breakfix
			do
				IFS=","
				set -- $bf
				break="$1"
				fix="$2"
				IFS="$ORIG_IFS"

				if [ "$break" != "-" ]; then
					break_tag="$(get_linus_tag $break $cve $BREAK_TAG)"
					break_date="$(get_linus_commit_date $break $break_tag)"
				else
					break_tag="-"
					break_date="-"
				fi

				if [ "$fix" != "-" ]; then
					fix_tag="$(get_linus_tag $fix $cve $LINUS_TAG)"
					fix_date="$(get_linus_commit_date $fix $fix_tag)"
				else
					fix_tag="-"
					fix_date="-"
				fi

				# Output file format
				# public_date cve break_date break break_tag fix_date fix fix_tag 
				echo "$date $cve $break_date $break $break_tag $fix_date $fix $fix_tag"
			done
		fi
	done
	shopt -u nullglob
}

find_diff_records() {

	local old="$1"
	local new="$2"
	local nr_fields=${#fields[@]}
	declare -A old_field	
	declare -A new_field
	local field_index
	local new_cve=""
	local fields_changed=""
	local y
	local i

	echo -n "$new" | awk '{ print $'$CVE'":" }'
	echo "*************"
	echo
	for y in $(seq 1 $nr_fields)
	do
		old_field[$y]=$(echo $old | awk '{ print $'$y' }')
		if [ -z "${old_field[$y]}" ]; then
			old_field[$y]="*"
		fi
		new_field[$y]=$(echo $new | awk '{ print $'$y' }')

		if [ "${old_field[$y]}" != "${new_field[$y]}" ]; then
			if [ -z "$fields_changed" ]; then
				fields_changed="${fields[$y]}"
			else
				fields_changed="$fields_changed,${fields[$y]}"
			fi
		fi
	done

	if [ $(echo $fields_changed | awk -F, '{ print NF }') -eq $nr_fields ]; then
		echo "*** This is a new CVE ***"
		new_cve="1"
	fi

	if [ "${new_field[$STABLE_TAG]}" != "-" ]; then
		echo "This CVE has been resolved in ${new_field[$STABLE_TAG]}."
		echo "Please pull this or a newer version of the kernel to resolve this security vulnerability."
		echo
	fi
	
	echo "---"
	echo "Description of fix for this vulnerability:"
	get_commit_msg ${new_field[$LINUS_COMMIT]}
	echo "---"

	echo "The following fields have changed: $fields_changed"
        ORIGIFS=$IFS
        IFS=,
        for i in $fields_changed
        do
                field_index=$(get_fields_index $i)
		if [ -z "$new_cve" ]; then 
                	echo "${fields[$field_index]}: ${old_field[$field_index]} -> ${new_field[$field_index]}"
		else
                	echo "${fields[$field_index]}: ${new_field[$field_index]}"
		fi
        done
        IFS=$ORIGIFS
        echo

	# TODO: File bugs from here
	# if [ "$new_cve" -eq "1" ]; then
	# 	#file bug...
	# fi
}

get_updated_cves() {

	local cve_filename=$1
	local cve_oldfilename="${1}.old"
	
	if [ ! -e "$cve_oldfilename" ]; then
		touch "$cve_oldfilename"
	fi 

	grep -vf $cve_oldfilename $cve_filename
}

mail_info() {

	local SUBJECT="$1 Kernel Vulnerability Report"
	local email_list="$2"

	/usr/bin/mail -s "$SUBJECT" "$email_list" < $MSG
}
