
-----------------------------
Stable Kernel Security Notice
2017-10-30

Stable Branch: linux-3.14.y

All linux-3.14.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-3.14.y-stable-cve-list.html

CVE(s) in report:

CVE-2017-15951
-----------------------------

Details:

*************
CVE-2017-15951:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 363b02dab09b3226f3bd1420dad9c72b79a42a76
Author: David Howells <dhowells@redhat.com>
Date:   Wed Oct 4 16:43:25 2017 +0100

    KEYS: Fix race between updating and finding a negative key
    
    Consolidate KEY_FLAG_INSTANTIATED, KEY_FLAG_NEGATIVE and the rejection
    error into one field such that:
    
     (1) The instantiation state can be modified/read atomically.
    
     (2) The error can be accessed atomically with the state.
    
     (3) The error isn't stored unioned with the payload pointers.
    
    This deals with the problem that the state is spread over three different
    objects (two bits and a separate variable) and reading or updating them
    atomically isn't practical, given that not only can uninstantiated keys
    change into instantiated or rejected keys, but rejected keys can also turn
    into instantiated keys - and someone accessing the key might not be using
    any locking.
    
    The main side effect of this problem is that what was held in the payload
    may change, depending on the state.  For instance, you might observe the
    key to be in the rejected state.  You then read the cached error, but if
    the key semaphore wasn't locked, the key might've become instantiated
    between the two reads - and you might now have something in hand that isn't
    actually an error code.
    
    The state is now KEY_IS_UNINSTANTIATED, KEY_IS_POSITIVE or a negative error
    code if the key is negatively instantiated.  The key_is_instantiated()
    function is replaced with key_is_positive() to avoid confusion as negative
    keys are also 'instantiated'.
    
    Additionally, barriering is included:
    
     (1) Order payload-set before state-set during instantiation.
    
     (2) Order state-read before payload-read when using the key.
    
    Further separate barriering is necessary if RCU is being used to access the
    payload content after reading the payload pointers.
    
    Fixes: 146aa8b1453b ("KEYS: Merge the type-specific data with the payload data")
    Cc: stable@vger.kernel.org # v4.4+
    Reported-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Eric Biggers <ebiggers@google.com>

 include/linux/key.h                      | 47 ++++++++++++++++++++------------
 net/dns_resolver/dns_key.c               |  2 +-
 security/keys/big_key.c                  |  4 +--
 security/keys/encrypted-keys/encrypted.c |  2 +-
 security/keys/gc.c                       |  8 +++---
 security/keys/key.c                      | 31 +++++++++++++--------
 security/keys/keyctl.c                   |  9 +++---
 security/keys/keyring.c                  | 10 +++----
 security/keys/proc.c                     |  7 +++--
 security/keys/process_keys.c             |  2 +-
 security/keys/request_key.c              |  7 ++---
 security/keys/request_key_auth.c         |  2 +-
 security/keys/trusted.c                  |  2 +-
 security/keys/user_defined.c             |  4 +--
 14 files changed, 80 insertions(+), 57 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2017-10-27
CVE: CVE-2017-15951
Break Date: 2015-10-21
Break Commit: 146aa8b1453bd8f1ff2304ffb71b4ee0eb9acdcc
Break Tag: 4.5
Linus Fix Date: 2017-10-18
Linus Commit: 363b02dab09b3226f3bd1420dad9c72b79a42a76
Linus Tag: 4.14
Stable Date: -
Stable Commit: -
Stable Tag: -
