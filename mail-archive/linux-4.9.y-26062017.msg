
-----------------------------
Stable Kernel Security Notice
2017-06-26

Stable Branch: linux-4.9.y

All linux-4.9.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-4.9.y-stable-cve-list.html

CVE(s) in report:

CVE-2017-1000364
CVE-2017-7518
-----------------------------

Details:

*************
CVE-2017-1000364:
*************

*** This is a new CVE ***
This CVE has been resolved in 4.9.34.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 1be7107fbe18eed3e319a6c3e83c78254b693acb
Author: Hugh Dickins <hughd@google.com>
Date:   Mon Jun 19 04:03:24 2017 -0700

    mm: larger stack guard gap, between vmas
    
    Stack guard page is a useful feature to reduce a risk of stack smashing
    into a different mapping. We have been using a single page gap which
    is sufficient to prevent having stack adjacent to a different mapping.
    But this seems to be insufficient in the light of the stack usage in
    userspace. E.g. glibc uses as large as 64kB alloca() in many commonly
    used functions. Others use constructs liks gid_t buffer[NGROUPS_MAX]
    which is 256kB or stack strings with MAX_ARG_STRLEN.
    
    This will become especially dangerous for suid binaries and the default
    no limit for the stack size limit because those applications can be
    tricked to consume a large portion of the stack and a single glibc call
    could jump over the guard page. These attacks are not theoretical,
    unfortunatelly.
    
    Make those attacks less probable by increasing the stack guard gap
    to 1MB (on systems with 4k pages; but make it depend on the page size
    because systems with larger base pages might cap stack allocations in
    the PAGE_SIZE units) which should cover larger alloca() and VLA stack
    allocations. It is obviously not a full fix because the problem is
    somehow inherent, but it should reduce attack space a lot.
    
    One could argue that the gap size should be configurable from userspace,
    but that can be done later when somebody finds that the new 1MB is wrong
    for some special case applications.  For now, add a kernel command line
    option (stack_guard_gap) to specify the stack gap size (in page units).
    
    Implementation wise, first delete all the old code for stack guard page:
    because although we could get away with accounting one extra page in a
    stack vma, accounting a larger gap can break userspace - case in point,
    a program run with "ulimit -S -v 20000" failed when the 1MB gap was
    counted for RLIMIT_AS; similar problems could come with RLIMIT_MLOCK
    and strict non-overcommit mode.
    
    Instead of keeping gap inside the stack vma, maintain the stack guard
    gap as a gap between vmas: using vm_start_gap() in place of vm_start
    (or vm_end_gap() in place of vm_end if VM_GROWSUP) in just those few
    places which need to respect the gap - mainly arch_get_unmapped_area(),
    and and the vma tree's subtree_gap support for that.
    
    Original-patch-by: Oleg Nesterov <oleg@redhat.com>
    Original-patch-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Hugh Dickins <hughd@google.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Tested-by: Helge Deller <deller@gmx.de> # parisc
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 Documentation/admin-guide/kernel-parameters.txt |   7 ++
 arch/arc/mm/mmap.c                              |   2 +-
 arch/arm/mm/mmap.c                              |   4 +-
 arch/frv/mm/elf-fdpic.c                         |   2 +-
 arch/mips/mm/mmap.c                             |   2 +-
 arch/parisc/kernel/sys_parisc.c                 |  15 ++-
 arch/powerpc/mm/hugetlbpage-radix.c             |   2 +-
 arch/powerpc/mm/mmap.c                          |   4 +-
 arch/powerpc/mm/slice.c                         |   2 +-
 arch/s390/mm/mmap.c                             |   4 +-
 arch/sh/mm/mmap.c                               |   4 +-
 arch/sparc/kernel/sys_sparc_64.c                |   4 +-
 arch/sparc/mm/hugetlbpage.c                     |   2 +-
 arch/tile/mm/hugetlbpage.c                      |   2 +-
 arch/x86/kernel/sys_x86_64.c                    |   4 +-
 arch/x86/mm/hugetlbpage.c                       |   2 +-
 arch/xtensa/kernel/syscall.c                    |   2 +-
 fs/hugetlbfs/inode.c                            |   2 +-
 fs/proc/task_mmu.c                              |   4 -
 include/linux/mm.h                              |  53 ++++-----
 mm/gup.c                                        |   5 -
 mm/memory.c                                     |  38 ------
 mm/mmap.c                                       | 149 ++++++++++++++----------
 23 files changed, 152 insertions(+), 163 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2017-06-19
CVE: CVE-2017-1000364
Break Date: 2010-08-12
Break Commit: 320b2b8de12698082609ebbc1a17165727f4c893
Break Tag: 2.6
Linus Fix Date: 2017-06-19
Linus Commit: 1be7107fbe18eed3e319a6c3e83c78254b693acb
Linus Tag: 4.12
Stable Date: 2017-06-24
Stable Commit: cfc0eb403816c5c4f9667d959de5e22789b5421e
Stable Tag: 4.9.34

CVE-2017-7518:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit c8401dda2f0a00cd25c0af6a95ed50e478d25de4
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Wed Jun 7 15:13:14 2017 +0200

    KVM: x86: fix singlestepping over syscall
    
    TF is handled a bit differently for syscall and sysret, compared
    to the other instructions: TF is checked after the instruction completes,
    so that the OS can disable #DB at a syscall by adding TF to FMASK.
    When the sysret is executed the #DB is taken "as if" the syscall insn
    just completed.
    
    KVM emulates syscall so that it can trap 32-bit syscall on Intel processors.
    Fix the behavior, otherwise you could get #DB on a user stack which is not
    nice.  This does not affect Linux guests, as they use an IST or task gate
    for #DB.
    
    This fixes CVE-2017-7518.
    
    Cc: stable@vger.kernel.org
    Reported-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>

 arch/x86/include/asm/kvm_emulate.h |  1 +
 arch/x86/kvm/emulate.c             |  1 +
 arch/x86/kvm/x86.c                 | 62 ++++++++++++++++++++------------------
 3 files changed, 34 insertions(+), 30 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2017-06-23
CVE: CVE-2017-7518
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2017-06-22
Linus Commit: c8401dda2f0a00cd25c0af6a95ed50e478d25de4
Linus Tag: 4.12
Stable Date: -
Stable Commit: -
Stable Tag: -
