
-----------------------------
Stable Kernel Security Notice
2018-02-01

Stable Branch: linux-4.4.y

All linux-4.4.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-4.4.y-stable-cve-list.html

CVE(s) in report:

CVE-2017-11472
CVE-2017-17448
CVE-2017-17450
-----------------------------

Details:

*************
CVE-2017-11472:
*************

This CVE has been resolved in 4.4.114.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 3b2d69114fefa474fca542e51119036dceb4aa6f
Author: Seunghun Han <kkamagui@gmail.com>
Date:   Wed Apr 26 16:18:08 2017 +0800

    ACPICA: Namespace: fix operand cache leak
    
    ACPICA commit a23325b2e583556eae88ed3f764e457786bf4df6
    
    I found some ACPI operand cache leaks in ACPI early abort cases.
    
    Boot log of ACPI operand cache leak is as follows:
    >[    0.174332] ACPI: Added _OSI(Module Device)
    >[    0.175504] ACPI: Added _OSI(Processor Device)
    >[    0.176010] ACPI: Added _OSI(3.0 _SCP Extensions)
    >[    0.177032] ACPI: Added _OSI(Processor Aggregator Device)
    >[    0.178284] ACPI: SCI (IRQ16705) allocation failed
    >[    0.179352] ACPI Exception: AE_NOT_ACQUIRED, Unable to install
    System Control Interrupt handler (20160930/evevent-131)
    >[    0.180008] ACPI: Unable to start the ACPI Interpreter
    >[    0.181125] ACPI Error: Could not remove SCI handler
    (20160930/evmisc-281)
    >[    0.184068] kmem_cache_destroy Acpi-Operand: Slab cache still has
    objects
    >[    0.185358] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.10.0-rc3 #2
    >[    0.186820] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS
    virtual_box 12/01/2006
    >[    0.188000] Call Trace:
    >[    0.188000]  ? dump_stack+0x5c/0x7d
    >[    0.188000]  ? kmem_cache_destroy+0x224/0x230
    >[    0.188000]  ? acpi_sleep_proc_init+0x22/0x22
    >[    0.188000]  ? acpi_os_delete_cache+0xa/0xd
    >[    0.188000]  ? acpi_ut_delete_caches+0x3f/0x7b
    >[    0.188000]  ? acpi_terminate+0x5/0xf
    >[    0.188000]  ? acpi_init+0x288/0x32e
    >[    0.188000]  ? __class_create+0x4c/0x80
    >[    0.188000]  ? video_setup+0x7a/0x7a
    >[    0.188000]  ? do_one_initcall+0x4e/0x1b0
    >[    0.188000]  ? kernel_init_freeable+0x194/0x21a
    >[    0.188000]  ? rest_init+0x80/0x80
    >[    0.188000]  ? kernel_init+0xa/0x100
    >[    0.188000]  ? ret_from_fork+0x25/0x30
    
    When early abort is occurred due to invalid ACPI information, Linux kernel
    terminates ACPI by calling acpi_terminate() function. The function calls
    acpi_ns_terminate() function to delete namespace data and ACPI operand cache
    (acpi_gbl_module_code_list).
    
    But the deletion code in acpi_ns_terminate() function is wrapped in
    ACPI_EXEC_APP definition, therefore the code is only executed when the
    definition exists. If the define doesn't exist, ACPI operand cache
    (acpi_gbl_module_code_list) is leaked, and stack dump is shown in kernel log.
    
    This causes a security threat because the old kernel (<= 4.9) shows memory
    locations of kernel functions in stack dump, therefore kernel ASLR can be
    neutralized.
    
    To fix ACPI operand leak for enhancing security, I made a patch which
    removes the ACPI_EXEC_APP define in acpi_ns_terminate() function for
    executing the deletion code unconditionally.
    
    Link: https://github.com/acpica/acpica/commit/a23325b2
    Signed-off-by: Seunghun Han <kkamagui@gmail.com>
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

 drivers/acpi/acpica/nsutils.c | 23 +++++++++--------------
 1 file changed, 9 insertions(+), 14 deletions(-)
---
The following fields have changed: Stable Date,Stable Commit,Stable Tag
Stable Date: - -> 2018-01-31
Stable Commit: - -> 4c19b00e5588828f0d3198b926efade766dcf2c8
Stable Tag: - -> 4.4.114

CVE-2017-17448:
*************

This CVE has been resolved in 4.4.114.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4b380c42f7d00a395feede754f0bc2292eebe6e5
Author: Kevin Cernekee <cernekee@chromium.org>
Date:   Sun Dec 3 12:12:45 2017 -0800

    netfilter: nfnetlink_cthelper: Add missing permission checks
    
    The capability check in nfnetlink_rcv() verifies that the caller
    has CAP_NET_ADMIN in the namespace that "owns" the netlink socket.
    However, nfnl_cthelper_list is shared by all net namespaces on the
    system.  An unprivileged user can create user and net namespaces
    in which he holds CAP_NET_ADMIN to bypass the netlink_net_capable()
    check:
    
        $ nfct helper list
        nfct v1.4.4: netlink error: Operation not permitted
        $ vpnns -- nfct helper list
        {
                .name = ftp,
                .queuenum = 0,
                .l3protonum = 2,
                .l4protonum = 6,
                .priv_data_len = 24,
                .status = enabled,
        };
    
    Add capable() checks in nfnetlink_cthelper, as this is cleaner than
    trying to generalize the solution.
    
    Signed-off-by: Kevin Cernekee <cernekee@chromium.org>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/netfilter/nfnetlink_cthelper.c | 10 ++++++++++
 1 file changed, 10 insertions(+)
---
The following fields have changed: Stable Date,Stable Commit,Stable Tag
Stable Date: - -> 2018-01-31
Stable Commit: - -> a359a437fbc6bb08aa9cc8e25ef4ac3b77ca727b
Stable Tag: - -> 4.4.114

CVE-2017-17450:
*************

This CVE has been resolved in 4.4.114.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 916a27901de01446bcf57ecca4783f6cff493309
Author: Kevin Cernekee <cernekee@chromium.org>
Date:   Tue Dec 5 15:42:41 2017 -0800

    netfilter: xt_osf: Add missing permission checks
    
    The capability check in nfnetlink_rcv() verifies that the caller
    has CAP_NET_ADMIN in the namespace that "owns" the netlink socket.
    However, xt_osf_fingers is shared by all net namespaces on the
    system.  An unprivileged user can create user and net namespaces
    in which he holds CAP_NET_ADMIN to bypass the netlink_net_capable()
    check:
    
        vpnns -- nfnl_osf -f /tmp/pf.os
    
        vpnns -- nfnl_osf -f /tmp/pf.os -d
    
    These non-root operations successfully modify the systemwide OS
    fingerprint list.  Add new capable() checks so that they can't.
    
    Signed-off-by: Kevin Cernekee <cernekee@chromium.org>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/netfilter/xt_osf.c | 7 +++++++
 1 file changed, 7 insertions(+)
---
The following fields have changed: Stable Date,Stable Commit,Stable Tag
Stable Date: - -> 2018-01-31
Stable Commit: - -> d01ceb4722cd8d64176272434fe332b596750d9c
Stable Tag: - -> 4.4.114
