
-----------------------------
Stable Kernel Security Notice
2018-03-08

Stable Branch: linux-4.9.y

All linux-4.9.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-4.9.y-stable-cve-list.html

CVE(s) in report:

CVE-2017-18221
CVE-2018-7566
-----------------------------

Details:

*************
CVE-2017-18221:
*************

*** This is a new CVE ***
This CVE has been resolved in 4.9.31.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 70feee0e1ef331b22cc51f383d532a0d043fbdcc
Author: Yisheng Xie <xieyisheng1@huawei.com>
Date:   Fri Jun 2 14:46:43 2017 -0700

    mlock: fix mlock count can not decrease in race condition
    
    Kefeng reported that when running the follow test, the mlock count in
    meminfo will increase permanently:
    
     [1] testcase
     linux:~ # cat test_mlockal
     grep Mlocked /proc/meminfo
      for j in `seq 0 10`
      do
     	for i in `seq 4 15`
     	do
     		./p_mlockall >> log &
     	done
     	sleep 0.2
     done
     # wait some time to let mlock counter decrease and 5s may not enough
     sleep 5
     grep Mlocked /proc/meminfo
    
     linux:~ # cat p_mlockall.c
     #include <sys/mman.h>
     #include <stdlib.h>
     #include <stdio.h>
    
     #define SPACE_LEN	4096
    
     int main(int argc, char ** argv)
     {
    	 	int ret;
    	 	void *adr = malloc(SPACE_LEN);
    	 	if (!adr)
    	 		return -1;
    
    	 	ret = mlockall(MCL_CURRENT | MCL_FUTURE);
    	 	printf("mlcokall ret = %d\n", ret);
    
    	 	ret = munlockall();
    	 	printf("munlcokall ret = %d\n", ret);
    
    	 	free(adr);
    	 	return 0;
    	 }
    
    In __munlock_pagevec() we should decrement NR_MLOCK for each page where
    we clear the PageMlocked flag.  Commit 1ebb7cc6a583 ("mm: munlock: batch
    NR_MLOCK zone state updates") has introduced a bug where we don't
    decrement NR_MLOCK for pages where we clear the flag, but fail to
    isolate them from the lru list (e.g.  when the pages are on some other
    cpu's percpu pagevec).  Since PageMlocked stays cleared, the NR_MLOCK
    accounting gets permanently disrupted by this.
    
    Fix it by counting the number of page whose PageMlock flag is cleared.
    
    Fixes: 1ebb7cc6a583 (" mm: munlock: batch NR_MLOCK zone state updates")
    Link: http://lkml.kernel.org/r/1495678405-54569-1-git-send-email-xieyisheng1@huawei.com
    Signed-off-by: Yisheng Xie <xieyisheng1@huawei.com>
    Reported-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Tested-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: Joern Engel <joern@logfs.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Michel Lespinasse <walken@google.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Xishi Qiu <qiuxishi@huawei.com>
    Cc: zhongjiang <zhongjiang@huawei.com>
    Cc: Hanjun Guo <guohanjun@huawei.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 mm/mlock.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2018-03-07
CVE: CVE-2017-18221
Break Date: 2013-09-11
Break Commit: 1ebb7cc6a58321a4b22c4c9097b4651b0ab859d0
Break Tag: 3.12-rc1
Linus Fix Date: 2017-06-02
Linus Commit: 70feee0e1ef331b22cc51f383d532a0d043fbdcc
Linus Tag: 4.12-rc4
Stable Date: 2017-06-07
Stable Commit: 1163e785b1506a4f46dbdee89bbab161dd742186
Stable Tag: 4.9.31

CVE-2018-7566:
*************

*** This is a new CVE ***
This CVE has been resolved in 4.9.83.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit d15d662e89fc667b90cd294b0eb45694e33144da
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 12 15:20:51 2018 +0100

    ALSA: seq: Fix racy pool initializations
    
    ALSA sequencer core initializes the event pool on demand by invoking
    snd_seq_pool_init() when the first write happens and the pool is
    empty.  Meanwhile user can reset the pool size manually via ioctl
    concurrently, and this may lead to UAF or out-of-bound accesses since
    the function tries to vmalloc / vfree the buffer.
    
    A simple fix is to just wrap the snd_seq_pool_init() call with the
    recently introduced client->ioctl_mutex; as the calls for
    snd_seq_pool_init() from other side are always protected with this
    mutex, we can avoid the race.
    
    Reported-by: 范龙飞 <long7573@126.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/seq/seq_clientmgr.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2018-03-02
CVE: CVE-2018-7566
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2018-02-14
Linus Commit: d15d662e89fc667b90cd294b0eb45694e33144da
Linus Tag: 4.16-rc2
Stable Date: 2018-02-22
Stable Commit: 869182f45e38e4c62722b20a5c6f4bc48b2e60c3
Stable Tag: 4.9.83
