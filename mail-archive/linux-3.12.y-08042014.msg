
-----------------------------
Stable Kernel Security Notice
2014-04-08

Stable Branch: linux-3.12.y

All linux-3.12.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-3.12.y-stable-cve-list.html

CVE(s) in report:

CVE-2014-0131
CVE-2014-2523
CVE-2014-2673
-----------------------------

Details:

*************
CVE-2014-0131:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 1fd819ecb90cc9b822cd84d3056ddba315d3340f
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Mon Mar 10 19:28:08 2014 +0200

    skbuff: skb_segment: orphan frags before copying
    
    skb_segment copies frags around, so we need
    to copy them carefully to avoid accessing
    user memory after reporting completion to userspace
    through a callback.
    
    skb_segment doesn't normally happen on datapath:
    TSO needs to be disabled - so disabling zero copy
    in this case does not look like a big deal.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/core/skbuff.c |    6 ++++++
 1 file changed, 6 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-03-24
CVE: CVE-2014-0131
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-03-11
Linus Commit: 1fd819ecb90cc9b822cd84d3056ddba315d3340f
Linus Tag: 3.14
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-2523:
*************

This CVE has been resolved in 3.12.17.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b22f5126a24b3b2f15448c3f2a254fc10cbc2b92
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon Jan 6 00:57:54 2014 +0100

    netfilter: nf_conntrack_dccp: fix skb_header_pointer API usages
    
    Some occurences in the netfilter tree use skb_header_pointer() in
    the following way ...
    
      struct dccp_hdr _dh, *dh;
      ...
      skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);
    
    ... where dh itself is a pointer that is being passed as the copy
    buffer. Instead, we need to use &_dh as the forth argument so that
    we're copying the data into an actual buffer that sits on the stack.
    
    Currently, we probably could overwrite memory on the stack (e.g.
    with a possibly mal-formed DCCP packet), but unintentionally, as
    we only want the buffer to be placed into _dh variable.
    
    Fixes: 2bc780499aa3 ("[NETFILTER]: nf_conntrack: add DCCP protocol support")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/netfilter/nf_conntrack_proto_dccp.c |    6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)
---
The following fields have changed: Stable Date,Stable Commit,Stable Tag
Stable Date: - -> 2014-04-03
Stable Commit: - -> f9c8e356e5c574cfa6ace53bb9956b4469fe606a
Stable Tag: - -> 3.12.17

CVE-2014-2673:
*************

This CVE has been resolved in 3.12.15.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 621b5060e823301d0cba4cb52a7ee3491922d291
Author: Michael Neuling <mikey@neuling.org>
Date:   Mon Mar 3 14:21:40 2014 +1100

    powerpc/tm: Fix crash when forking inside a transaction
    
    When we fork/clone we currently don't copy any of the TM state to the new
    thread.  This results in a TM bad thing (program check) when the new process is
    switched in as the kernel does a tmrechkpt with TEXASR FS not set.  Also, since
    R1 is from userspace, we trigger the bad kernel stack pointer detection.  So we
    end up with something like this:
    
       Bad kernel stack pointer 0 at c0000000000404fc
       cpu 0x2: Vector: 700 (Program Check) at [c00000003ffefd40]
           pc: c0000000000404fc: restore_gprs+0xc0/0x148
           lr: 0000000000000000
           sp: 0
          msr: 9000000100201030
         current = 0xc000001dd1417c30
         paca    = 0xc00000000fe00800   softe: 0        irq_happened: 0x01
           pid   = 0, comm = swapper/2
       WARNING: exception is not recoverable, can't continue
    
    The below fixes this by flushing the TM state before we copy the task_struct to
    the clone.  To do this we go through the tmreclaim patch, which removes the
    checkpointed registers from the CPU and transitions the CPU out of TM suspend
    mode.  Hence we need to call tmrechkpt after to restore the checkpointed state
    and the TM mode for the current task.
    
    To make this fail from userspace is simply:
    	tbegin
    	li	r0, 2
    	sc
    	<boom>
    
    Kudos to Adhemerval Zanella Neto for finding this.
    
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    cc: Adhemerval Zanella Neto <azanella@br.ibm.com>
    cc: stable@vger.kernel.org
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

 arch/powerpc/kernel/process.c |    9 +++++++++
 1 file changed, 9 insertions(+)
---
The following fields have changed: Break Date,Break Commit,Break Tag
Break Date: - -> 2013-02-15
Break Commit: - -> fb09692e71f13af7298eb603a1975850b1c7a8d8
Break Tag: - -> 3.9
