
-----------------------------
Stable Kernel Security Notice
2017-01-06

Stable Branch: linux-4.4.y

All linux-4.4.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-4.4.y-stable-cve-list.html

CVE(s) in report:

CVE-2016-6213
CVE-2016-9588
CVE-2016-9685
CVE-2016-9754
CVE-2016-9755
CVE-2016-9756
CVE-2016-9777
CVE-2016-9794
CVE-2016-9806
-----------------------------

Details:

*************
CVE-2016-6213:
*************

---
Description of fix for this vulnerability:
commit d29216842a85c7970c536108e093963f02714498
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Sep 28 00:27:17 2016 -0500

    mnt: Add a per mount namespace limit on the number of mounts
    
    CAI Qian <caiqian@redhat.com> pointed out that the semantics
    of shared subtrees make it possible to create an exponentially
    increasing number of mounts in a mount namespace.
    
        mkdir /tmp/1 /tmp/2
        mount --make-rshared /
        for i in $(seq 1 20) ; do mount --bind /tmp/1 /tmp/2 ; done
    
    Will create create 2^20 or 1048576 mounts, which is a practical problem
    as some people have managed to hit this by accident.
    
    As such CVE-2016-6213 was assigned.
    
    Ian Kent <raven@themaw.net> described the situation for autofs users
    as follows:
    
    > The number of mounts for direct mount maps is usually not very large because of
    > the way they are implemented, large direct mount maps can have performance
    > problems. There can be anywhere from a few (likely case a few hundred) to less
    > than 10000, plus mounts that have been triggered and not yet expired.
    >
    > Indirect mounts have one autofs mount at the root plus the number of mounts that
    > have been triggered and not yet expired.
    >
    > The number of autofs indirect map entries can range from a few to the common
    > case of several thousand and in rare cases up to between 30000 and 50000. I've
    > not heard of people with maps larger than 50000 entries.
    >
    > The larger the number of map entries the greater the possibility for a large
    > number of active mounts so it's not hard to expect cases of a 1000 or somewhat
    > more active mounts.
    
    So I am setting the default number of mounts allowed per mount
    namespace at 100,000.  This is more than enough for any use case I
    know of, but small enough to quickly stop an exponential increase
    in mounts.  Which should be perfect to catch misconfigurations and
    malfunctioning programs.
    
    For anyone who needs a higher limit this can be changed by writing
    to the new /proc/sys/fs/mount-max sysctl.
    
    Tested-by: CAI Qian <caiqian@redhat.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 Documentation/sysctl/fs.txt |  7 +++++++
 fs/mount.h                  |  2 ++
 fs/namespace.c              | 49 ++++++++++++++++++++++++++++++++++++++++++++-
 fs/pnode.c                  |  2 +-
 fs/pnode.h                  |  1 +
 include/linux/mount.h       |  2 ++
 kernel/sysctl.c             |  9 +++++++++
 7 files changed, 70 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date
Public Date: 2016-07-14 -> 2016-12-28

CVE-2016-9588:
*************

---
Description of fix for this vulnerability:
commit ef85b67385436ddc1998f45f1d6a210f935b3388
Author: Jim Mattson <jmattson@google.com>
Date:   Mon Dec 12 11:01:37 2016 -0800

    kvm: nVMX: Allow L1 to intercept software exceptions (#BP and #OF)
    
    When L2 exits to L0 due to "exception or NMI", software exceptions
    (#BP and #OF) for which L1 has requested an intercept should be
    handled by L1 rather than L0. Previously, only hardware exceptions
    were forwarded to L1.
    
    Signed-off-by: Jim Mattson <jmattson@google.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/vmx.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date
Public Date: 2016-12-15 -> 2016-12-28

CVE-2016-9685:
*************

This CVE has been resolved in 4.4.7.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 2e83b79b2d6c78bf1b4aa227938a214dcbddc83f
Author: Mateusz Guzik <mguzik@redhat.com>
Date:   Wed Mar 2 09:51:09 2016 +1100

    xfs: fix two memory leaks in xfs_attr_list.c error paths
    
    This plugs 2 trivial leaks in xfs_attr_shortform_list and
    xfs_attr3_leaf_list_int.
    
    Signed-off-by: Mateusz Guzik <mguzik@redhat.com>
    Cc: <stable@vger.kernel.org>
    Reviewed-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

 fs/xfs/xfs_attr_list.c | 19 ++++++++++---------
 1 file changed, 10 insertions(+), 9 deletions(-)
---
The following fields have changed: Public Date
Public Date: 2016-12-01 -> 2016-12-28

CVE-2016-9754:
*************

*** This is a new CVE ***
This CVE has been resolved in 4.4.12.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 59643d1535eb220668692a5359de22545af579f6
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Fri May 13 09:34:12 2016 -0400

    ring-buffer: Prevent overflow of size in ring_buffer_resize()
    
    If the size passed to ring_buffer_resize() is greater than MAX_LONG - BUF_PAGE_SIZE
    then the DIV_ROUND_UP() will return zero.
    
    Here's the details:
    
      # echo 18014398509481980 > /sys/kernel/debug/tracing/buffer_size_kb
    
    tracing_entries_write() processes this and converts kb to bytes.
    
     18014398509481980 << 10 = 18446744073709547520
    
    and this is passed to ring_buffer_resize() as unsigned long size.
    
     size = DIV_ROUND_UP(size, BUF_PAGE_SIZE);
    
    Where DIV_ROUND_UP(a, b) is (a + b - 1)/b
    
    BUF_PAGE_SIZE is 4080 and here
    
     18446744073709547520 + 4080 - 1 = 18446744073709551599
    
    where 18446744073709551599 is still smaller than 2^64
    
     2^64 - 18446744073709551599 = 17
    
    But now 18446744073709551599 / 4080 = 4521260802379792
    
    and size = size * 4080 = 18446744073709551360
    
    This is checked to make sure its still greater than 2 * 4080,
    which it is.
    
    Then we convert to the number of buffer pages needed.
    
     nr_page = DIV_ROUND_UP(size, BUF_PAGE_SIZE)
    
    but this time size is 18446744073709551360 and
    
     2^64 - (18446744073709551360 + 4080 - 1) = -3823
    
    Thus it overflows and the resulting number is less than 4080, which makes
    
      3823 / 4080 = 0
    
    an nr_pages is set to this. As we already checked against the minimum that
    nr_pages may be, this causes the logic to fail as well, and we crash the
    kernel.
    
    There's no reason to have the two DIV_ROUND_UP() (that's just result of
    historical code changes), clean up the code and fix this bug.
    
    Cc: stable@vger.kernel.org # 3.5+
    Fixes: 83f40318dab00 ("ring-buffer: Make removal of ring buffer pages atomic")
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

 kernel/trace/ring_buffer.c | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2017-01-05
CVE: CVE-2016-9754
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-13
Linus Commit: 59643d1535eb220668692a5359de22545af579f6
Linus Tag: 4.7
Stable Date: 2016-06-01
Stable Commit: f199023137853eb1d46e8b7ebc274b29ba99028c
Stable Tag: 4.4.12

CVE-2016-9755:
*************

---
Description of fix for this vulnerability:
commit 9b57da0630c9fd36ed7a20fc0f98dc82cc0777fa
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Nov 29 02:17:34 2016 +0100

    netfilter: ipv6: nf_defrag: drop mangled skb on ream error
    
    Dmitry Vyukov reported GPF in network stack that Andrey traced down to
    negative nh offset in nf_ct_frag6_queue().
    
    Problem is that all network headers before fragment header are pulled.
    Normal ipv6 reassembly will drop the skb when errors occur further down
    the line.
    
    netfilter doesn't do this, and instead passed the original fragment
    along.  That was also fine back when netfilter ipv6 defrag worked with
    cloned fragments, as the original, pristine fragment was passed on.
    
    So we either have to undo the pull op, or discard such fragments.
    Since they're malformed after all (e.g. overlapping fragment) it seems
    preferrable to just drop them.
    
    Same for temporary errors -- it doesn't make sense to accept (and
    perhaps forward!) only some fragments of same datagram.
    
    Fixes: 029f7f3b8701cc7ac ("netfilter: ipv6: nf_defrag: avoid/free clone operations")
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Debugged-by: Andrey Konovalov <andreyknvl@google.com>
    Diagnosed-by: Eric Dumazet <Eric Dumazet <edumazet@google.com>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/ipv6/netfilter/nf_conntrack_reasm.c   | 4 ++--
 net/ipv6/netfilter/nf_defrag_ipv6_hooks.c | 2 +-
 2 files changed, 3 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date
Public Date: 2016-12-01 -> 2016-12-28

CVE-2016-9756:
*************

This CVE has been resolved in 4.4.36.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 2117d5398c81554fbf803f5fd1dc55eb78216c0c
Author: Radim Krčmář <rkrcmar@redhat.com>
Date:   Wed Nov 23 21:15:00 2016 +0100

    KVM: x86: drop error recovery in em_jmp_far and em_ret_far
    
    em_jmp_far and em_ret_far assumed that setting IP can only fail in 64
    bit mode, but syzkaller proved otherwise (and SDM agrees).
    Code segment was restored upon failure, but it was left uninitialized
    outside of long mode, which could lead to a leak of host kernel stack.
    We could have fixed that by always saving and restoring the CS, but we
    take a simpler approach and just break any guest that manages to fail
    as the error recovery is error-prone and modern CPUs don't need emulator
    for this.
    
    Found by syzkaller:
    
      WARNING: CPU: 2 PID: 3668 at arch/x86/kvm/emulate.c:2217 em_ret_far+0x428/0x480
      Kernel panic - not syncing: panic_on_warn set ...
    
      CPU: 2 PID: 3668 Comm: syz-executor Not tainted 4.9.0-rc4+ #49
      Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
       [...]
      Call Trace:
       [...] __dump_stack lib/dump_stack.c:15
       [...] dump_stack+0xb3/0x118 lib/dump_stack.c:51
       [...] panic+0x1b7/0x3a3 kernel/panic.c:179
       [...] __warn+0x1c4/0x1e0 kernel/panic.c:542
       [...] warn_slowpath_null+0x2c/0x40 kernel/panic.c:585
       [...] em_ret_far+0x428/0x480 arch/x86/kvm/emulate.c:2217
       [...] em_ret_far_imm+0x17/0x70 arch/x86/kvm/emulate.c:2227
       [...] x86_emulate_insn+0x87a/0x3730 arch/x86/kvm/emulate.c:5294
       [...] x86_emulate_instruction+0x520/0x1ba0 arch/x86/kvm/x86.c:5545
       [...] emulate_instruction arch/x86/include/asm/kvm_host.h:1116
       [...] complete_emulated_io arch/x86/kvm/x86.c:6870
       [...] complete_emulated_mmio+0x4e9/0x710 arch/x86/kvm/x86.c:6934
       [...] kvm_arch_vcpu_ioctl_run+0x3b7a/0x5a90 arch/x86/kvm/x86.c:6978
       [...] kvm_vcpu_ioctl+0x61e/0xdd0 arch/x86/kvm/../../../virt/kvm/kvm_main.c:2557
       [...] vfs_ioctl fs/ioctl.c:43
       [...] do_vfs_ioctl+0x18c/0x1040 fs/ioctl.c:679
       [...] SYSC_ioctl fs/ioctl.c:694
       [...] SyS_ioctl+0x8f/0xc0 fs/ioctl.c:685
       [...] entry_SYSCALL_64_fastpath+0x1f/0xc2
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: stable@vger.kernel.org
    Fixes: d1442d85cc30 ("KVM: x86: Handle errors when RIP is set during far jumps")
    Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>

 arch/x86/kvm/emulate.c | 36 +++++++++++-------------------------
 1 file changed, 11 insertions(+), 25 deletions(-)
---
The following fields have changed: Public Date
Public Date: 2016-12-01 -> 2016-12-28

CVE-2016-9777:
*************

---
Description of fix for this vulnerability:
commit 81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755
Author: Radim Krčmář <rkrcmar@redhat.com>
Date:   Wed Nov 23 21:15:27 2016 +0100

    KVM: x86: fix out-of-bounds accesses of rtc_eoi map
    
    KVM was using arrays of size KVM_MAX_VCPUS with vcpu_id, but ID can be
    bigger that the maximal number of VCPUs, resulting in out-of-bounds
    access.
    
    Found by syzkaller:
    
      BUG: KASAN: slab-out-of-bounds in __apic_accept_irq+0xb33/0xb50 at addr [...]
      Write of size 1 by task a.out/27101
      CPU: 1 PID: 27101 Comm: a.out Not tainted 4.9.0-rc5+ #49
      Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
       [...]
      Call Trace:
       [...] __apic_accept_irq+0xb33/0xb50 arch/x86/kvm/lapic.c:905
       [...] kvm_apic_set_irq+0x10e/0x180 arch/x86/kvm/lapic.c:495
       [...] kvm_irq_delivery_to_apic+0x732/0xc10 arch/x86/kvm/irq_comm.c:86
       [...] ioapic_service+0x41d/0x760 arch/x86/kvm/ioapic.c:360
       [...] ioapic_set_irq+0x275/0x6c0 arch/x86/kvm/ioapic.c:222
       [...] kvm_ioapic_inject_all arch/x86/kvm/ioapic.c:235
       [...] kvm_set_ioapic+0x223/0x310 arch/x86/kvm/ioapic.c:670
       [...] kvm_vm_ioctl_set_irqchip arch/x86/kvm/x86.c:3668
       [...] kvm_arch_vm_ioctl+0x1a08/0x23c0 arch/x86/kvm/x86.c:3999
       [...] kvm_vm_ioctl+0x1fa/0x1a70 arch/x86/kvm/../../../virt/kvm/kvm_main.c:3099
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: stable@vger.kernel.org
    Fixes: af1bae5497b9 ("KVM: x86: bump KVM_MAX_VCPU_ID to 1023")
    Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
    Reviewed-by: David Hildenbrand <david@redhat.com>
    Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>

 arch/x86/kvm/ioapic.c | 2 +-
 arch/x86/kvm/ioapic.h | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date
Public Date: 2016-12-02 -> 2016-12-28

CVE-2016-9794:
*************

This CVE has been resolved in 4.4.37.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Apr 14 18:02:37 2016 +0200

    ALSA: pcm : Call kill_fasync() in stream lock
    
    Currently kill_fasync() is called outside the stream lock in
    snd_pcm_period_elapsed().  This is potentially racy, since the stream
    may get released even during the irq handler is running.  Although
    snd_pcm_release_substream() calls snd_pcm_drop(), this doesn't
    guarantee that the irq handler finishes, thus the kill_fasync() call
    outside the stream spin lock may be invoked after the substream is
    detached, as recently reported by KASAN.
    
    As a quick workaround, move kill_fasync() call inside the stream
    lock.  The fasync is rarely used interface, so this shouldn't have a
    big impact from the performance POV.
    
    Ideally, we should implement some sync mechanism for the proper finish
    of stream and irq handler.  But this oneliner should suffice for most
    cases, so far.
    
    Reported-by: Baozeng Ding <sploving1@gmail.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/pcm_lib.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date
Public Date: 2016-12-05 -> 2016-12-28

CVE-2016-9806:
*************

This CVE has been resolved in 4.4.14.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 92964c79b357efd980812c4de5c1fd2ec8bb5520
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Mon May 16 17:28:16 2016 +0800

    netlink: Fix dump skb leak/double free
    
    When we free cb->skb after a dump, we do it after releasing the
    lock.  This means that a new dump could have started in the time
    being and we'll end up freeing their skb instead of ours.
    
    This patch saves the skb and module before we unlock so we free
    the right memory.
    
    Fixes: 16b304f3404f ("netlink: Eliminate kmalloc in netlink dump operation.")
    Reported-by: Baozeng Ding <sploving1@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/netlink/af_netlink.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date
Public Date: 2016-12-05 -> 2016-12-28
