
-----------------------------
Stable Kernel Security Notice
2013-12-12

Stable Branch: linux-3.10.y

All linux-3.10.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-3.10.y-stable-cve-list.html

CVE(s) in report:

CVE-2013-2930
CVE-2013-4270
CVE-2013-6431
CVE-2013-6432
CVE-2013-7026
CVE-2013-7027
-----------------------------

Details:

*************
CVE-2013-2930:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.10.21.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 12ae030d54ef250706da5642fc7697cc60ad0df7
Author: Steven Rostedt <rostedt@goodmis.org>
Date:   Tue Nov 5 12:51:11 2013 -0500

    perf/ftrace: Fix paranoid level for enabling function tracer
    
    The current default perf paranoid level is "1" which has
    "perf_paranoid_kernel()" return false, and giving any operations that
    use it, access to normal users. Unfortunately, this includes function
    tracing and normal users should not be allowed to enable function
    tracing by default.
    
    The proper level is defined at "-1" (full perf access), which
    "perf_paranoid_tracepoint_raw()" will only give access to. Use that
    check instead for enabling function tracing.
    
    Reported-by: Dave Jones <davej@redhat.com>
    Reported-by: Vince Weaver <vincent.weaver@maine.edu>
    Tested-by: Vince Weaver <vincent.weaver@maine.edu>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: stable@vger.kernel.org # 3.4+
    CVE: CVE-2013-2930
    Fixes: ced39002f5ea ("ftrace, perf: Add support to use function tracepoint in perf")
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

 kernel/trace/trace_event_perf.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2013-12-09
CVE: CVE-2013-2930
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2013-11-06
Linus Commit: 12ae030d54ef250706da5642fc7697cc60ad0df7
Linus Tag: 3.13
Stable Date: 2013-11-29
Stable Commit: 65b4037862eeec836fef612bbcd558ea10efe1a8
Stable Tag: 3.10.21

CVE-2013-4270:
*************

This CVE has been resolved in 3.10.16.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 2433c8f094a008895e66f25bd1773cdb01c91d01
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Oct 5 13:15:30 2013 -0700

    net: Update the sysctl permissions handler to test effective uid/gid
    
    Modify the code to use current_euid(), and in_egroup_p, as in done
    in fs/proc/proc_sysctl.c:test_perm()
    
    Cc: stable@vger.kernel.org
    Reviewed-by: Eric Sandeen <sandeen@redhat.com>
    Reported-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 net/sysctl_net.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date
Public Date: 2013-11-08 -> 2013-12-09

CVE-2013-6431:
*************

This CVE has been resolved in 3.10.16.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Sat Sep 7 15:13:20 2013 +0200

    net: fib: fib6_add: fix potential NULL pointer dereference
    
    When the kernel is compiled with CONFIG_IPV6_SUBTREES, and we return
    with an error in fn = fib6_add_1(), then error codes are encoded into
    the return pointer e.g. ERR_PTR(-ENOENT). In such an error case, we
    write the error code into err and jump to out, hence enter the if(err)
    condition. Now, if CONFIG_IPV6_SUBTREES is enabled, we check for:
    
      if (pn != fn && pn->leaf == rt)
        ...
      if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO))
        ...
    
    Since pn is NULL and fn is f.e. ERR_PTR(-ENOENT), then pn != fn
    evaluates to true and causes a NULL-pointer dereference on further
    checks on pn. Fix it, by setting both NULL in error case, so that
    pn != fn already evaluates to false and no further dereference
    takes place.
    
    This was first correctly implemented in 4a287eba2 ("IPv6 routing,
    NLM_F_* flag support: REPLACE and EXCL flags support, warn about
    missing CREATE flag"), but the bug got later on introduced by
    188c517a0 ("ipv6: return errno pointers consistently for fib6_add_1()").
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Cc: Lin Ming <mlin@ss.pku.edu.cn>
    Cc: Matti Vaittinen <matti.vaittinen@nsn.com>
    Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Acked-by: Matti Vaittinen <matti.vaittinen@nsn.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv6/ip6_fib.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date
Public Date: 2013-12-06 -> 2013-12-09

CVE-2013-6432:
*************

---
Description of fix for this vulnerability:
commit cf970c002d270c36202bd5b9c2804d3097a52da0
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Mon Nov 18 07:07:45 2013 +0100

    ping: prevent NULL pointer dereference on write to msg_name
    
    A plain read() on a socket does set msg->msg_name to NULL. So check for
    NULL pointer first.
    
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv4/ping.c | 34 +++++++++++++++++++---------------
 1 file changed, 19 insertions(+), 15 deletions(-)
---
The following fields have changed: Public Date
Public Date: 2013-12-06 -> 2013-12-09

CVE-2013-7026:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.10.21.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1
Author: Greg Thelen <gthelen@google.com>
Date:   Thu Nov 21 14:32:00 2013 -0800

    ipc,shm: fix shm_file deletion races
    
    When IPC_RMID races with other shm operations there's potential for
    use-after-free of the shm object's associated file (shm_file).
    
    Here's the race before this patch:
    
      TASK 1                     TASK 2
      ------                     ------
      shm_rmid()
        ipc_lock_object()
                                 shmctl()
                                 shp = shm_obtain_object_check()
    
        shm_destroy()
          shum_unlock()
          fput(shp->shm_file)
                                 ipc_lock_object()
                                 shmem_lock(shp->shm_file)
                                 <OOPS>
    
    The oops is caused because shm_destroy() calls fput() after dropping the
    ipc_lock.  fput() clears the file's f_inode, f_path.dentry, and
    f_path.mnt, which causes various NULL pointer references in task 2.  I
    reliably see the oops in task 2 if with shmlock, shmu
    
    This patch fixes the races by:
    1) set shm_file=NULL in shm_destroy() while holding ipc_object_lock().
    2) modify at risk operations to check shm_file while holding
       ipc_object_lock().
    
    Example workloads, which each trigger oops...
    
    Workload 1:
      while true; do
        id=$(shmget 1 4096)
        shm_rmid $id &
        shmlock $id &
        wait
      done
    
      The oops stack shows accessing NULL f_inode due to racing fput:
        _raw_spin_lock
        shmem_lock
        SyS_shmctl
    
    Workload 2:
      while true; do
        id=$(shmget 1 4096)
        shmat $id 4096 &
        shm_rmid $id &
        wait
      done
    
      The oops stack is similar to workload 1 due to NULL f_inode:
        touch_atime
        shmem_mmap
        shm_mmap
        mmap_region
        do_mmap_pgoff
        do_shmat
        SyS_shmat
    
    Workload 3:
      while true; do
        id=$(shmget 1 4096)
        shmlock $id
        shm_rmid $id &
        shmunlock $id &
        wait
      done
    
      The oops stack shows second fput tripping on an NULL f_inode.  The
      first fput() completed via from shm_destroy(), but a racing thread did
      a get_file() and queued this fput():
        locks_remove_flock
        __fput
        ____fput
        task_work_run
        do_notify_resume
        int_signal
    
    Fixes: c2c737a0461e ("ipc,shm: shorten critical region for shmat")
    Fixes: 2caacaa82a51 ("ipc,shm: shorten critical region for shmctl")
    Signed-off-by: Greg Thelen <gthelen@google.com>
    Cc: Davidlohr Bueso <davidlohr@hp.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Cc: <stable@vger.kernel.org>  # 3.10.17+ 3.11.6+
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 ipc/shm.c | 28 +++++++++++++++++++++++-----
 1 file changed, 23 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2013-12-09
CVE: CVE-2013-7026
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2013-11-21
Linus Commit: a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1
Linus Tag: 3.13
Stable Date: 2013-11-29
Stable Commit: b444df2f5791fb1ddf7d6b771ee32e30cc29dad9
Stable Tag: 3.10.21

CVE-2013-7027:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.10.18.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit f5563318ff1bde15b10e736e97ffce13be08bc1a
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Oct 11 14:47:05 2013 +0200

    wireless: radiotap: fix parsing buffer overrun
    
    When parsing an invalid radiotap header, the parser can overrun
    the buffer that is passed in because it doesn't correctly check
     1) the minimum radiotap header size
     2) the space for extended bitmaps
    
    The first issue doesn't affect any in-kernel user as they all
    check the minimum size before calling the radiotap function.
    The second issue could potentially affect the kernel if an skb
    is passed in that consists only of the radiotap header with a
    lot of extended bitmaps that extend past the SKB. In that case
    a read-only buffer overrun by at most 4 bytes is possible.
    
    Fix this by adding the appropriate checks to the parser.
    
    Cc: stable@vger.kernel.org
    Reported-by: Evan Huus <eapache@gmail.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

 net/wireless/radiotap.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2013-12-09
CVE: CVE-2013-7027
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2013-10-14
Linus Commit: f5563318ff1bde15b10e736e97ffce13be08bc1a
Linus Tag: 3.12
Stable Date: 2013-11-04
Stable Commit: add8ec07b2a000af11be64a89b99afc8c90797e5
Stable Tag: 3.10.18
