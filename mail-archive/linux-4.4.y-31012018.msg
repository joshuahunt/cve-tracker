
-----------------------------
Stable Kernel Security Notice
2018-01-31

Stable Branch: linux-4.4.y

All linux-4.4.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-4.4.y-stable-cve-list.html

CVE(s) in report:

CVE-2017-15129
CVE-2017-18079
-----------------------------

Details:

*************
CVE-2017-15129:
*************

This CVE has been resolved in 4.4.109.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 21b5944350052d2583e82dd59b19a9ba94a007f0
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Dec 19 11:27:56 2017 -0600

    net: Fix double free and memory corruption in get_net_ns_by_id()
    
    (I can trivially verify that that idr_remove in cleanup_net happens
     after the network namespace count has dropped to zero --EWB)
    
    Function get_net_ns_by_id() does not check for net::count
    after it has found a peer in netns_ids idr.
    
    It may dereference a peer, after its count has already been
    finaly decremented. This leads to double free and memory
    corruption:
    
    put_net(peer)                                   rtnl_lock()
    atomic_dec_and_test(&peer->count) [count=0]     ...
    __put_net(peer)                                 get_net_ns_by_id(net, id)
      spin_lock(&cleanup_list_lock)
      list_add(&net->cleanup_list, &cleanup_list)
      spin_unlock(&cleanup_list_lock)
    queue_work()                                      peer = idr_find(&net->netns_ids, id)
      |                                               get_net(peer) [count=1]
      |                                               ...
      |                                               (use after final put)
      v                                               ...
      cleanup_net()                                   ...
        spin_lock(&cleanup_list_lock)                 ...
        list_replace_init(&cleanup_list, ..)          ...
        spin_unlock(&cleanup_list_lock)               ...
        ...                                           ...
        ...                                           put_net(peer)
        ...                                             atomic_dec_and_test(&peer->count) [count=0]
        ...                                               spin_lock(&cleanup_list_lock)
        ...                                               list_add(&net->cleanup_list, &cleanup_list)
        ...                                               spin_unlock(&cleanup_list_lock)
        ...                                             queue_work()
        ...                                           rtnl_unlock()
        rtnl_lock()                                   ...
        for_each_net(tmp) {                           ...
          id = __peernet2id(tmp, peer)                ...
          spin_lock_irq(&tmp->nsid_lock)              ...
          idr_remove(&tmp->netns_ids, id)             ...
          ...                                         ...
          net_drop_ns()                               ...
    	net_free(peer)                            ...
        }                                             ...
      |
      v
      cleanup_net()
        ...
        (Second free of peer)
    
    Also, put_net() on the right cpu may reorder with left's cpu
    list_replace_init(&cleanup_list, ..), and then cleanup_list
    will be corrupted.
    
    Since cleanup_net() is executed in worker thread, while
    put_net(peer) can happen everywhere, there should be
    enough time for concurrent get_net_ns_by_id() to pick
    the peer up, and the race does not seem to be unlikely.
    The patch fixes the problem in standard way.
    
    (Also, there is possible problem in peernet2id_alloc(), which requires
    check for net::count under nsid_lock and maybe_get_net(peer), but
    in current stable kernel it's used under rtnl_lock() and it has to be
    safe. Openswitch begun to use peernet2id_alloc(), and possibly it should
    be fixed too. While this is not in stable kernel yet, so I'll send
    a separate message to netdev@ later).
    
    Cc: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Fixes: 0c7aecd4bde4 "netns: add rtnl cmd to add and get peer netns ids"
    Reviewed-by: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Reviewed-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Acked-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/core/net_namespace.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Break Date,Break Commit,Break Tag
Break Date: - -> 2015-01-19
Break Commit: - -> 0c7aecd4bde4b7302cd41986d3a29e4f0b0ed218
Break Tag: - -> 4.0-rc1

CVE-2017-18079:
*************

*** This is a new CVE ***
This CVE has been resolved in 4.4.79.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 340d394a789518018f834ff70f7534fc463d3226
Author: Chen Hong <chenhong3@huawei.com>
Date:   Sun Jul 2 15:11:10 2017 -0700

    Input: i8042 - fix crash at boot time
    
    The driver checks port->exists twice in i8042_interrupt(), first when
    trying to assign temporary "serio" variable, and second time when deciding
    whether it should call serio_interrupt(). The value of port->exists may
    change between the 2 checks, and we may end up calling serio_interrupt()
    with a NULL pointer:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000050
    IP: [<ffffffff8150feaf>] _spin_lock_irqsave+0x1f/0x40
    PGD 0
    Oops: 0002 [#1] SMP
    last sysfs file:
    CPU 0
    Modules linked in:
    
    Pid: 1, comm: swapper Not tainted 2.6.32-358.el6.x86_64 #1 QEMU Standard PC (i440FX + PIIX, 1996)
    RIP: 0010:[<ffffffff8150feaf>]  [<ffffffff8150feaf>] _spin_lock_irqsave+0x1f/0x40
    RSP: 0018:ffff880028203cc0  EFLAGS: 00010082
    RAX: 0000000000010000 RBX: 0000000000000000 RCX: 0000000000000000
    RDX: 0000000000000282 RSI: 0000000000000098 RDI: 0000000000000050
    RBP: ffff880028203cc0 R08: ffff88013e79c000 R09: ffff880028203ee0
    R10: 0000000000000298 R11: 0000000000000282 R12: 0000000000000050
    R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000098
    FS:  0000000000000000(0000) GS:ffff880028200000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
    CR2: 0000000000000050 CR3: 0000000001a85000 CR4: 00000000001407f0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    Process swapper (pid: 1, threadinfo ffff88013e79c000, task ffff88013e79b500)
    Stack:
    ffff880028203d00 ffffffff813de186 ffffffffffffff02 0000000000000000
    <d> 0000000000000000 0000000000000000 0000000000000000 0000000000000098
    <d> ffff880028203d70 ffffffff813e0162 ffff880028203d20 ffffffff8103b8ac
    Call Trace:
    <IRQ>
     [<ffffffff813de186>] serio_interrupt+0x36/0xa0
    [<ffffffff813e0162>] i8042_interrupt+0x132/0x3a0
    [<ffffffff8103b8ac>] ? kvm_clock_read+0x1c/0x20
    [<ffffffff8103b8b9>] ? kvm_clock_get_cycles+0x9/0x10
    [<ffffffff810e1640>] handle_IRQ_event+0x60/0x170
    [<ffffffff8103b154>] ? kvm_guest_apic_eoi_write+0x44/0x50
    [<ffffffff810e3d8e>] handle_edge_irq+0xde/0x180
    [<ffffffff8100de89>] handle_irq+0x49/0xa0
    [<ffffffff81516c8c>] do_IRQ+0x6c/0xf0
    [<ffffffff8100b9d3>] ret_from_intr+0x0/0x11
    [<ffffffff81076f63>] ? __do_softirq+0x73/0x1e0
    [<ffffffff8109b75b>] ? hrtimer_interrupt+0x14b/0x260
    [<ffffffff8100c1cc>] ? call_softirq+0x1c/0x30
    [<ffffffff8100de05>] ? do_softirq+0x65/0xa0
    [<ffffffff81076d95>] ? irq_exit+0x85/0x90
    [<ffffffff81516d80>] ? smp_apic_timer_interrupt+0x70/0x9b
    [<ffffffff8100bb93>] ? apic_timer_interrupt+0x13/0x20
    
    To avoid the issue let's change the second check to test whether serio is
    NULL or not.
    
    Also, let's take i8042_lock in i8042_start() and i8042_stop() instead of
    trying to be overly smart and using memory barriers.
    
    Signed-off-by: Chen Hong <chenhong3@huawei.com>
    [dtor: take lock in i8042_start()/i8042_stop()]
    Cc: stable@vger.kernel.org
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

 drivers/input/serio/i8042.c | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2018-01-29
CVE: CVE-2017-18079
Break Date: 2005-04-16
Break Commit: 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Break Tag: 2.6
Linus Fix Date: 2017-07-12
Linus Commit: 340d394a789518018f834ff70f7534fc463d3226
Linus Tag: 4.13-rc1
Stable Date: 2017-07-27
Stable Commit: bba6b69e11777695256619a77f90081ac7f99de7
Stable Tag: 4.4.79
