
-----------------------------
Stable Kernel Security Notice
2015-11-19

Stable Branch: linux-4.0.y

All linux-4.0.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-4.0.y-stable-cve-list.html

CVE(s) in report:

CVE-2015-2925
CVE-2015-2925
CVE-2015-5257
CVE-2015-7312
CVE-2015-7872
CVE-2015-7872
-----------------------------

Details:

*************
CVE-2015-2925:
*************

---
Description of fix for this vulnerability:
commit 397d425dc26da728396e66d392d5dcb8dac30c37
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Aug 15 20:27:13 2015 -0500

    vfs: Test for and handle paths that are unreachable from their mnt_root
    
    In rare cases a directory can be renamed out from under a bind mount.
    In those cases without special handling it becomes possible to walk up
    the directory tree to the root dentry of the filesystem and down
    from the root dentry to every other file or directory on the filesystem.
    
    Like division by zero .. from an unconnected path can not be given
    a useful semantic as there is no predicting at which path component
    the code will realize it is unconnected.  We certainly can not match
    the current behavior as the current behavior is a security hole.
    
    Therefore when encounting .. when following an unconnected path
    return -ENOENT.
    
    - Add a function path_connected to verify path->dentry is reachable
      from path->mnt.mnt_root.  AKA to validate that rename did not do
      something nasty to the bind mount.
    
      To avoid races path_connected must be called after following a path
      component to it's next path component.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 fs/namei.c |   27 +++++++++++++++++++++++++--
 1 file changed, 25 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date
Public Date: 2015-04-06 -> 2015-11-16

CVE-2015-2925:
*************

---
Description of fix for this vulnerability:
commit cde93be45a8a90d8c264c776fab63487b5038a65
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Aug 15 13:36:12 2015 -0500

    dcache: Handle escaped paths in prepend_path
    
    A rename can result in a dentry that by walking up d_parent
    will never reach it's mnt_root.  For lack of a better term
    I call this an escaped path.
    
    prepend_path is called by four different functions __d_path,
    d_absolute_path, d_path, and getcwd.
    
    __d_path only wants to see paths are connected to the root it passes
    in.  So __d_path needs prepend_path to return an error.
    
    d_absolute_path similarly wants to see paths that are connected to
    some root.  Escaped paths are not connected to any mnt_root so
    d_absolute_path needs prepend_path to return an error greater
    than 1.  So escaped paths will be treated like paths on lazily
    unmounted mounts.
    
    getcwd needs to prepend "(unreachable)" so getcwd also needs
    prepend_path to return an error.
    
    d_path is the interesting hold out.  d_path just wants to print
    something, and does not care about the weird cases.  Which raises
    the question what should be printed?
    
    Given that <escaped_path>/<anything> should result in -ENOENT I
    believe it is desirable for escaped paths to be printed as empty
    paths.  As there are not really any meaninful path components when
    considered from the perspective of a mount tree.
    
    So tweak prepend_path to return an empty path with an new error
    code of 3 when it encounters an escaped path.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 fs/dcache.c |    7 +++++++
 1 file changed, 7 insertions(+)
---
The following fields have changed: Public Date
Public Date: 2015-04-06 -> 2015-11-16

CVE-2015-5257:
*************

---
Description of fix for this vulnerability:
commit cbb4be652d374f64661137756b8f357a1827d6a4
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Sep 23 11:41:42 2015 -0700

    USB: whiteheat: fix potential null-deref at probe
    
    Fix potential null-pointer dereference at probe by making sure that the
    required endpoints are present.
    
    The whiteheat driver assumes there are at least five pairs of bulk
    endpoints, of which the final pair is used for the "command port". An
    attempt to bind to an interface with fewer bulk endpoints would
    currently lead to an oops.
    
    Fixes CVE-2015-5257.
    
    Reported-by: Moein Ghasemzadeh <moein@istuary.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/usb/serial/whiteheat.c |   31 +++++++++++++++++++++++++++++++
 1 file changed, 31 insertions(+)
---
The following fields have changed: Public Date
Public Date: 2015-09-24 -> 2015-11-16

CVE-2015-7312:
*************

---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date
Public Date: 2015-09-23 -> 2015-11-16

CVE-2015-7872:
*************

---
Description of fix for this vulnerability:
commit f05819df10d7b09f6d1eb6f8534a8f68e5a4fe61
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 15 17:21:37 2015 +0100

    KEYS: Fix crash when attempt to garbage collect an uninstantiated keyring
    
    The following sequence of commands:
    
        i=`keyctl add user a a @s`
        keyctl request2 keyring foo bar @t
        keyctl unlink $i @s
    
    tries to invoke an upcall to instantiate a keyring if one doesn't already
    exist by that name within the user's keyring set.  However, if the upcall
    fails, the code sets keyring->type_data.reject_error to -ENOKEY or some
    other error code.  When the key is garbage collected, the key destroy
    function is called unconditionally and keyring_destroy() uses list_empty()
    on keyring->type_data.link - which is in a union with reject_error.
    Subsequently, the kernel tries to unlink the keyring from the keyring names
    list - which oopses like this:
    
    	BUG: unable to handle kernel paging request at 00000000ffffff8a
    	IP: [<ffffffff8126e051>] keyring_destroy+0x3d/0x88
    	...
    	Workqueue: events key_garbage_collector
    	...
    	RIP: 0010:[<ffffffff8126e051>] keyring_destroy+0x3d/0x88
    	RSP: 0018:ffff88003e2f3d30  EFLAGS: 00010203
    	RAX: 00000000ffffff82 RBX: ffff88003bf1a900 RCX: 0000000000000000
    	RDX: 0000000000000000 RSI: 000000003bfc6901 RDI: ffffffff81a73a40
    	RBP: ffff88003e2f3d38 R08: 0000000000000152 R09: 0000000000000000
    	R10: ffff88003e2f3c18 R11: 000000000000865b R12: ffff88003bf1a900
    	R13: 0000000000000000 R14: ffff88003bf1a908 R15: ffff88003e2f4000
    	...
    	CR2: 00000000ffffff8a CR3: 000000003e3ec000 CR4: 00000000000006f0
    	...
    	Call Trace:
    	 [<ffffffff8126c756>] key_gc_unused_keys.constprop.1+0x5d/0x10f
    	 [<ffffffff8126ca71>] key_garbage_collector+0x1fa/0x351
    	 [<ffffffff8105ec9b>] process_one_work+0x28e/0x547
    	 [<ffffffff8105fd17>] worker_thread+0x26e/0x361
    	 [<ffffffff8105faa9>] ? rescuer_thread+0x2a8/0x2a8
    	 [<ffffffff810648ad>] kthread+0xf3/0xfb
    	 [<ffffffff810647ba>] ? kthread_create_on_node+0x1c2/0x1c2
    	 [<ffffffff815f2ccf>] ret_from_fork+0x3f/0x70
    	 [<ffffffff810647ba>] ? kthread_create_on_node+0x1c2/0x1c2
    
    Note the value in RAX.  This is a 32-bit representation of -ENOKEY.
    
    The solution is to only call ->destroy() if the key was successfully
    instantiated.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>

 security/keys/gc.c |    6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date
Public Date: 2015-10-21 -> 2015-11-16

CVE-2015-7872:
*************

---
Description of fix for this vulnerability:
commit 911b79cde95c7da0ec02f48105358a36636b7a71
Author: David Howells <dhowells@redhat.com>
Date:   Mon Oct 19 11:20:28 2015 +0100

    KEYS: Don't permit request_key() to construct a new keyring
    
    If request_key() is used to find a keyring, only do the search part - don't
    do the construction part if the keyring was not found by the search.  We
    don't really want keyrings in the negative instantiated state since the
    rejected/negative instantiation error value in the payload is unioned with
    keyring metadata.
    
    Now the kernel gives an error:
    
    	request_key("keyring", "#selinux,bdekeyring", "keyring", KEY_SPEC_USER_SESSION_KEYRING) = -1 EPERM (Operation not permitted)
    
    Signed-off-by: David Howells <dhowells@redhat.com>

 security/keys/request_key.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date
Public Date: 2015-10-21 -> 2015-11-16
