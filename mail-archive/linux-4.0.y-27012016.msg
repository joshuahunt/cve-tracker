
-----------------------------
Stable Kernel Security Notice
2016-01-27

Stable Branch: linux-4.0.y

All linux-4.0.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-4.0.y-stable-cve-list.html

CVE(s) in report:

2015-07-21
CVE-2015-7833
CVE-2015-7833
CVE-2015-8543
CVE-2015-8785
CVE-2016-2069
CVE-2016-2069
CVE-2016-2070
-----------------------------

Details:

*************
CVE-2015-7833:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 588afcc1c0e45358159090d95bf7b246fb67565f
Author: Oliver Neukum <oneukum@suse.com>
Date:   Tue Oct 27 09:51:34 2015 -0200

    [media] usbvision fix overflow of interfaces array
    
    This fixes the crash reported in:
    http://seclists.org/bugtraq/2015/Oct/35
    The interface number needs a sanity check.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.com>
    Cc: Vladis Dronov <vdronov@redhat.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

 drivers/media/usb/usbvision/usbvision-video.c |    7 +++++++
 1 file changed, 7 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-7833
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-11-17
Linus Commit: 588afcc1c0e45358159090d95bf7b246fb67565f
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-7833:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fa52bd506f274b7619955917abfde355e3d19ffe
Author: Vladis Dronov <vdronov@redhat.com>
Date:   Mon Nov 16 15:55:11 2015 -0200

    [media] usbvision: fix crash on detecting device with invalid configuration
    
    The usbvision driver crashes when a specially crafted usb device with invalid
    number of interfaces or endpoints is detected. This fix adds checks that the
    device has proper configuration expected by the driver.
    
    Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
    Signed-off-by: Vladis Dronov <vdronov@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

 drivers/media/usb/usbvision/usbvision-video.c |   16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-7833
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-11-19
Linus Commit: fa52bd506f274b7619955917abfde355e3d19ffe
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8543:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 79462ad02e861803b3840cc782248c7359451cd9
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Mon Dec 14 22:03:39 2015 +0100

    net: add validation for the socket syscall protocol argument
    
    郭永刚 reported that one could simply crash the kernel as root by
    using a simple program:
    
    	int socket_fd;
    	struct sockaddr_in addr;
    	addr.sin_port = 0;
    	addr.sin_addr.s_addr = INADDR_ANY;
    	addr.sin_family = 10;
    
    	socket_fd = socket(10,3,0x40000000);
    	connect(socket_fd , &addr,16);
    
    AF_INET, AF_INET6 sockets actually only support 8-bit protocol
    identifiers. inet_sock's skc_protocol field thus is sized accordingly,
    thus larger protocol identifiers simply cut off the higher bits and
    store a zero in the protocol fields.
    
    This could lead to e.g. NULL function pointer because as a result of
    the cut off inet_num is zero and we call down to inet_autobind, which
    is NULL for raw sockets.
    
    kernel: Call Trace:
    kernel:  [<ffffffff816db90e>] ? inet_autobind+0x2e/0x70
    kernel:  [<ffffffff816db9a4>] inet_dgram_connect+0x54/0x80
    kernel:  [<ffffffff81645069>] SYSC_connect+0xd9/0x110
    kernel:  [<ffffffff810ac51b>] ? ptrace_notify+0x5b/0x80
    kernel:  [<ffffffff810236d8>] ? syscall_trace_enter_phase2+0x108/0x200
    kernel:  [<ffffffff81645e0e>] SyS_connect+0xe/0x10
    kernel:  [<ffffffff81779515>] tracesys_phase2+0x84/0x89
    
    I found no particular commit which introduced this problem.
    
    CVE: CVE-2015-8543
    Cc: Cong Wang <cwang@twopensource.com>
    Reported-by: 郭永刚 <guoyonggang@360.cn>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/sock.h     |    1 +
 net/ax25/af_ax25.c     |    3 +++
 net/decnet/af_decnet.c |    3 +++
 net/ipv4/af_inet.c     |    3 +++
 net/ipv6/af_inet6.c    |    3 +++
 net/irda/af_irda.c     |    3 +++
 6 files changed, 16 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-28
CVE: CVE-2015-8543
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-14
Linus Commit: 79462ad02e861803b3840cc782248c7359451cd9
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8785:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 3ca8138f014a913f98e6ef40e939868e1e9ea876
Author: Roman Gushchin <klamm@yandex-team.ru>
Date:   Mon Oct 12 16:33:44 2015 +0300

    fuse: break infinite loop in fuse_fill_write_pages()
    
    I got a report about unkillable task eating CPU. Further
    investigation shows, that the problem is in the fuse_fill_write_pages()
    function. If iov's first segment has zero length, we get an infinite
    loop, because we never reach iov_iter_advance() call.
    
    Fix this by calling iov_iter_advance() before repeating an attempt to
    copy data from userspace.
    
    A similar problem is described in 124d3b7041f ("fix writev regression:
    pan hanging unkillable and un-straceable"). If zero-length segmend
    is followed by segment with invalid address,
    iov_iter_fault_in_readable() checks only first segment (zero-length),
    iov_iter_copy_from_user_atomic() skips it, fails at second and
    returns zero -> goto again without skipping zero-length segment.
    
    Patch calls iov_iter_advance() before goto again: we'll skip zero-length
    segment at second iteraction and iov_iter_fault_in_readable() will detect
    invalid address.
    
    Special thanks to Konstantin Khlebnikov, who helped a lot with the commit
    description.
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Maxim Patlasov <mpatlasov@parallels.com>
    Cc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: Roman Gushchin <klamm@yandex-team.ru>
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Fixes: ea9b9907b82a ("fuse: implement perform_write")
    Cc: <stable@vger.kernel.org>

 fs/fuse/file.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-31
CVE: CVE-2015-8785
Break Date: 2008-04-30
Break Commit: ea9b9907b82a09bd1a708004454f7065de77c5b0
Break Tag: 2.6
Linus Fix Date: 2015-11-10
Linus Commit: 3ca8138f014a913f98e6ef40e939868e1e9ea876
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-2069:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 71b3c126e61177eb693423f2e18a1914205b165e
Author: Andy Lutomirski <luto@kernel.org>
Date:   Wed Jan 6 12:21:01 2016 -0800

    x86/mm: Add barriers and document switch_mm()-vs-flush synchronization
    
    When switch_mm() activates a new PGD, it also sets a bit that
    tells other CPUs that the PGD is in use so that TLB flush IPIs
    will be sent.  In order for that to work correctly, the bit
    needs to be visible prior to loading the PGD and therefore
    starting to fill the local TLB.
    
    Document all the barriers that make this work correctly and add
    a couple that were missing.
    
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-mm@kvack.org
    Cc: stable@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/include/asm/mmu_context.h |   33 ++++++++++++++++++++++++++++++++-
 arch/x86/mm/tlb.c                  |   29 ++++++++++++++++++++++++++---
 2 files changed, 58 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-01-26
CVE: CVE-2016-2069
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-11
Linus Commit: 71b3c126e61177eb693423f2e18a1914205b165e
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-2069:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 4eaffdd5a5fe6ff9f95e1ab4de1ac904d5e0fa8b
Author: Andy Lutomirski <luto@kernel.org>
Date:   Tue Jan 12 12:47:40 2016 -0800

    x86/mm: Improve switch_mm() barrier comments
    
    My previous comments were still a bit confusing and there was a
    typo. Fix it up.
    
    Reported-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Fixes: 71b3c126e611 ("x86/mm: Add barriers and document switch_mm()-vs-flush synchronization")
    Link: http://lkml.kernel.org/r/0a0b43cdcdd241c5faaaecfbcc91a155ddedc9a1.1452631609.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/include/asm/mmu_context.h |   15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-01-26
CVE: CVE-2016-2069
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-13
Linus Commit: 4eaffdd5a5fe6ff9f95e1ab4de1ac904d5e0fa8b
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-2070:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 8b8a321ff72c785ed5e8b4cf6eda20b35d427390
Author: Yuchung Cheng <ycheng@google.com>
Date:   Wed Jan 6 12:42:38 2016 -0800

    tcp: fix zero cwnd in tcp_cwnd_reduction
    
    Patch 3759824da87b ("tcp: PRR uses CRB mode by default and SS mode
    conditionally") introduced a bug that cwnd may become 0 when both
    inflight and sndcnt are 0 (cwnd = inflight + sndcnt). This may lead
    to a div-by-zero if the connection starts another cwnd reduction
    phase by setting tp->prior_cwnd to the current cwnd (0) in
    tcp_init_cwnd_reduction().
    
    To prevent this we skip PRR operation when nothing is acked or
    sacked. Then cwnd must be positive in all cases as long as ssthresh
    is positive:
    
    1) The proportional reduction mode
       inflight > ssthresh > 0
    
    2) The reduction bound mode
      a) inflight == ssthresh > 0
    
      b) inflight < ssthresh
         sndcnt > 0 since newly_acked_sacked > 0 and inflight < ssthresh
    
    Therefore in all cases inflight and sndcnt can not both be 0.
    We check invalid tp->prior_cwnd to avoid potential div0 bugs.
    
    In reality this bug is triggered only with a sequence of less common
    events.  For example, the connection is terminating an ECN-triggered
    cwnd reduction with an inflight 0, then it receives reordered/old
    ACKs or DSACKs from prior transmission (which acks nothing). Or the
    connection is in fast recovery stage that marks everything lost,
    but fails to retransmit due to local issues, then receives data
    packets from other end which acks nothing.
    
    Fixes: 3759824da87b ("tcp: PRR uses CRB mode by default and SS mode conditionally")
    Reported-by: Oleksandr Natalenko <oleksandr@natalenko.name>
    Signed-off-by: Yuchung Cheng <ycheng@google.com>
    Signed-off-by: Neal Cardwell <ncardwell@google.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv4/tcp_input.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-01-26
CVE: CVE-2016-2070
Break Date: 2015-07-08
Break Commit: 3759824da87b30ce7a35b4873b62b0ba38905ef5
Break Tag: 4.3
Linus Fix Date: 2016-01-06
Linus Commit: 8b8a321ff72c785ed5e8b4cf6eda20b35d427390
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -
