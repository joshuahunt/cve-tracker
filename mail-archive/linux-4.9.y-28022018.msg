
-----------------------------
Stable Kernel Security Notice
2018-02-28

Stable Branch: linux-4.9.y

All linux-4.9.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-4.9.y-stable-cve-list.html

CVE(s) in report:

CVE-2017-18200
CVE-2017-18202
CVE-2018-7480
CVE-2018-7492
-----------------------------

Details:

*************
CVE-2017-18200:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 638164a2718f337ea224b747cf5977ef143166a4
Author: Chao Yu <yuchao0@huawei.com>
Date:   Mon Oct 2 02:50:16 2017 +0800

    f2fs: fix potential panic during fstrim
    
    As Ju Hyung Park reported:
    
    "When 'fstrim' is called for manual trim, a BUG() can be triggered
    randomly with this patch.
    
    I'm seeing this issue on both x86 Desktop and arm64 Android phone.
    
    On x86 Desktop, this was caused during Ubuntu boot-up. I have a
    cronjob installed which calls 'fstrim -v /' during boot. On arm64
    Android, this was caused during GC looping with 1ms gc_min_sleep_time
    & gc_max_sleep_time."
    
    Root cause of this issue is that f2fs_wait_discard_bios can only be
    used by f2fs_put_super, because during put_super there must be no
    other referrers, so it can ignore discard entry's reference count
    when removing the entry, otherwise in other caller we will hit bug_on
    in __remove_discard_cmd as there may be other issuer added reference
    count in discard entry.
    
    Thread A				Thread B
    					- issue_discard_thread
    - f2fs_ioc_fitrim
     - f2fs_trim_fs
      - f2fs_wait_discard_bios
       - __issue_discard_cmd
        - __submit_discard_cmd
    					 - __wait_discard_cmd
    					  - dc->ref++
    					  - __wait_one_discard_bio
       - __wait_discard_cmd
        - __remove_discard_cmd
         - f2fs_bug_on(sbi, dc->ref)
    
    Fixes: 969d1b180d987c2be02de890d0fff0f66a0e80de
    Reported-by: Ju Hyung Park <qkrwngud825@gmail.com>
    Signed-off-by: Chao Yu <yuchao0@huawei.com>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

 fs/f2fs/f2fs.h    | 2 +-
 fs/f2fs/segment.c | 6 +++---
 fs/f2fs/super.c   | 2 +-
 3 files changed, 5 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2018-02-25
CVE: CVE-2017-18200
Break Date: 2017-08-21
Break Commit: 969d1b180d987c2be02de890d0fff0f66a0e80de
Break Tag: 4.14-rc1
Linus Fix Date: 2017-10-03
Linus Commit: 638164a2718f337ea224b747cf5977ef143166a4
Linus Tag: 4.14-rc5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2017-18202:
*************

*** This is a new CVE ***
This CVE has been resolved in 4.9.68.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 687cb0884a714ff484d038e9190edc874edcf146
Author: Wang Nan <wangnan0@huawei.com>
Date:   Wed Nov 29 16:09:58 2017 -0800

    mm, oom_reaper: gather each vma to prevent leaking TLB entry
    
    tlb_gather_mmu(&tlb, mm, 0, -1) means gathering the whole virtual memory
    space.  In this case, tlb->fullmm is true.  Some archs like arm64
    doesn't flush TLB when tlb->fullmm is true:
    
      commit 5a7862e83000 ("arm64: tlbflush: avoid flushing when fullmm == 1").
    
    Which causes leaking of tlb entries.
    
    Will clarifies his patch:
     "Basically, we tag each address space with an ASID (PCID on x86) which
      is resident in the TLB. This means we can elide TLB invalidation when
      pulling down a full mm because we won't ever assign that ASID to
      another mm without doing TLB invalidation elsewhere (which actually
      just nukes the whole TLB).
    
      I think that means that we could potentially not fault on a kernel
      uaccess, because we could hit in the TLB"
    
    There could be a window between complete_signal() sending IPI to other
    cores and all threads sharing this mm are really kicked off from cores.
    In this window, the oom reaper may calls tlb_flush_mmu_tlbonly() to
    flush TLB then frees pages.  However, due to the above problem, the TLB
    entries are not really flushed on arm64.  Other threads are possible to
    access these pages through TLB entries.  Moreover, a copy_to_user() can
    also write to these pages without generating page fault, causes
    use-after-free bugs.
    
    This patch gathers each vma instead of gathering full vm space.  In this
    case tlb->fullmm is not true.  The behavior of oom reaper become similar
    to munmapping before do_exit, which should be safe for all archs.
    
    Link: http://lkml.kernel.org/r/20171107095453.179940-1-wangnan0@huawei.com
    Fixes: aac453635549 ("mm, oom: introduce oom reaper")
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: David Rientjes <rientjes@google.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Bob Liu <liubo95@huawei.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Roman Gushchin <guro@fb.com>
    Cc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 mm/oom_kill.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2018-02-27
CVE: CVE-2017-18202
Break Date: 2016-03-25
Break Commit: aac453635549699c13a84ea1456d5b0e574ef855
Break Tag: 4.6-rc1
Linus Fix Date: 2017-11-29
Linus Commit: 687cb0884a714ff484d038e9190edc874edcf146
Linus Tag: 4.15-rc2
Stable Date: 2017-12-09
Stable Commit: ee23ae915fa74956503507c1e55cbb2102f349ec
Stable Tag: 4.9.68

CVE-2018-7480:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9b54d816e00425c3a517514e0d677bb3cec49258
Author: Hou Tao <houtao1@huawei.com>
Date:   Fri Feb 3 17:19:07 2017 +0800

    blkcg: fix double free of new_blkg in blkcg_init_queue
    
    If blkg_create fails, new_blkg passed as an argument will
    be freed by blkg_create, so there is no need to free it again.
    
    Signed-off-by: Hou Tao <houtao1@huawei.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

 block/blk-cgroup.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2018-02-25
CVE: CVE-2018-7480
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2017-02-03
Linus Commit: 9b54d816e00425c3a517514e0d677bb3cec49258
Linus Tag: 4.11-rc1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2018-7492:
*************

*** This is a new CVE ***
This CVE has been resolved in 4.9.70.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit f3069c6d33f6ae63a1668737bc78aaaa51bff7ca
Author: Håkon Bugge <Haakon.Bugge@oracle.com>
Date:   Wed Dec 6 17:18:28 2017 +0100

    rds: Fix NULL pointer dereference in __rds_rdma_map
    
    This is a fix for syzkaller719569, where memory registration was
    attempted without any underlying transport being loaded.
    
    Analysis of the case reveals that it is the setsockopt() RDS_GET_MR
    (2) and RDS_GET_MR_FOR_DEST (7) that are vulnerable.
    
    Here is an example stack trace when the bug is hit:
    
    BUG: unable to handle kernel NULL pointer dereference at 00000000000000c0
    IP: __rds_rdma_map+0x36/0x440 [rds]
    PGD 2f93d03067 P4D 2f93d03067 PUD 2f93d02067 PMD 0
    Oops: 0000 [#1] SMP
    Modules linked in: bridge stp llc tun rpcsec_gss_krb5 nfsv4
    dns_resolver nfs fscache rds binfmt_misc sb_edac intel_powerclamp
    coretemp kvm_intel kvm irqbypass crct10dif_pclmul c rc32_pclmul
    ghash_clmulni_intel pcbc aesni_intel crypto_simd glue_helper cryptd
    iTCO_wdt mei_me sg iTCO_vendor_support ipmi_si mei ipmi_devintf nfsd
    shpchp pcspkr i2c_i801 ioatd ma ipmi_msghandler wmi lpc_ich mfd_core
    auth_rpcgss nfs_acl lockd grace sunrpc ip_tables ext4 mbcache jbd2
    mgag200 i2c_algo_bit drm_kms_helper ixgbe syscopyarea ahci sysfillrect
    sysimgblt libahci mdio fb_sys_fops ttm ptp libata sd_mod mlx4_core drm
    crc32c_intel pps_core megaraid_sas i2c_core dca dm_mirror
    dm_region_hash dm_log dm_mod
    CPU: 48 PID: 45787 Comm: repro_set2 Not tainted 4.14.2-3.el7uek.x86_64 #2
    Hardware name: Oracle Corporation ORACLE SERVER X5-2L/ASM,MOBO TRAY,2U, BIOS 31110000 03/03/2017
    task: ffff882f9190db00 task.stack: ffffc9002b994000
    RIP: 0010:__rds_rdma_map+0x36/0x440 [rds]
    RSP: 0018:ffffc9002b997df0 EFLAGS: 00010202
    RAX: 0000000000000000 RBX: ffff882fa2182580 RCX: 0000000000000000
    RDX: 0000000000000000 RSI: ffffc9002b997e40 RDI: ffff882fa2182580
    RBP: ffffc9002b997e30 R08: 0000000000000000 R09: 0000000000000002
    R10: ffff885fb29e3838 R11: 0000000000000000 R12: ffff882fa2182580
    R13: ffff882fa2182580 R14: 0000000000000002 R15: 0000000020000ffc
    FS:  00007fbffa20b700(0000) GS:ffff882fbfb80000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00000000000000c0 CR3: 0000002f98a66006 CR4: 00000000001606e0
    Call Trace:
     rds_get_mr+0x56/0x80 [rds]
     rds_setsockopt+0x172/0x340 [rds]
     ? __fget_light+0x25/0x60
     ? __fdget+0x13/0x20
     SyS_setsockopt+0x80/0xe0
     do_syscall_64+0x67/0x1b0
     entry_SYSCALL64_slow_path+0x25/0x25
    RIP: 0033:0x7fbff9b117f9
    RSP: 002b:00007fbffa20aed8 EFLAGS: 00000293 ORIG_RAX: 0000000000000036
    RAX: ffffffffffffffda RBX: 00000000000c84a4 RCX: 00007fbff9b117f9
    RDX: 0000000000000002 RSI: 0000400000000114 RDI: 000000000000109b
    RBP: 00007fbffa20af10 R08: 0000000000000020 R09: 00007fbff9dd7860
    R10: 0000000020000ffc R11: 0000000000000293 R12: 0000000000000000
    R13: 00007fbffa20b9c0 R14: 00007fbffa20b700 R15: 0000000000000021
    
    Code: 41 56 41 55 49 89 fd 41 54 53 48 83 ec 18 8b 87 f0 02 00 00 48
    89 55 d0 48 89 4d c8 85 c0 0f 84 2d 03 00 00 48 8b 87 00 03 00 00 <48>
    83 b8 c0 00 00 00 00 0f 84 25 03 00 0 0 48 8b 06 48 8b 56 08
    
    The fix is to check the existence of an underlying transport in
    __rds_rdma_map().
    
    Signed-off-by: Håkon Bugge <haakon.bugge@oracle.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/rds/rdma.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2018-02-26
CVE: CVE-2018-7492
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2017-12-06
Linus Commit: f3069c6d33f6ae63a1668737bc78aaaa51bff7ca
Linus Tag: 4.15-rc3
Stable Date: 2017-12-16
Stable Commit: 3259862dd73bfb9d9b7a647ea77cb20ba8b179a4
Stable Tag: 4.9.70
