
-----------------------------
Stable Kernel Security Notice
2016-11-05

Stable Branch: linux-4.1.y

All linux-4.1.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-4.1.y-stable-cve-list.html

CVE(s) in report:

4.4
-
3.14
4.5
fbd40ea0180a2d328c5adc61414dc8bab9335ce2
4.7
3.15
-----------------------------

Details:

*************
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
-:
CVE-2013-4312:
CVE-2013-7446:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3332:
CVE-2015-4004:
CVE-2015-4692:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5697:
CVE-2015-6252:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
4.4:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8956:
CVE-2015-8970:
-:
CVE-2015-8944:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
3.14:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
4.5:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
fbd40ea0180a2d328c5adc61414dc8bab9335ce2:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
4.7:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
3.15:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

This CVE has been resolved in 3b244a6e53dc33f6701bfde8601d7677c0c6e9e8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 3b244a6e53dc33f6701bfde8601d7677c0c6e9e8
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Dec 11 14:38:06 2015 +0200

    xhci: fix usb2 resume timing and races.
    
    [ Upstream commit f69115fdbc1ac0718e7d19ad3caa3da2ecfe1c96 ]
    
    According to USB 2 specs ports need to signal resume for at least 20ms,
    in practice even longer, before moving to U0 state.
    Both host and devices can initiate resume.
    
    On device initiated resume, a port status interrupt with the port in resume
    state in issued. The interrupt handler tags a resume_done[port]
    timestamp with current time + USB_RESUME_TIMEOUT, and kick roothub timer.
    Root hub timer requests for port status, finds the port in resume state,
    checks if resume_done[port] timestamp passed, and set port to U0 state.
    
    On host initiated resume, current code sets the port to resume state,
    sleep 20ms, and finally sets the port to U0 state. This should also
    be changed to work in a similar way as the device initiated resume, with
    timestamp tagging, but that is not yet tested and will be a separate
    fix later.
    
    There are a few issues with this approach
    
    1. A host initiated resume will also generate a resume event. The event
       handler will find the port in resume state, believe it's a device
       initiated resume, and act accordingly.
    
    2. A port status request might cut the resume signalling short if a
       get_port_status request is handled during the host resume signalling.
       The port will be found in resume state. The timestamp is not set leading
       to time_after_eq(jiffies, timestamp) returning true, as timestamp = 0.
       get_port_status will proceed with moving the port to U0.
    
    3. If an error, or anything else happens to the port during device
       initiated resume signalling it will leave all the device resume
       parameters hanging uncleared, preventing further suspend, returning
       -EBUSY, and cause the pm thread to busyloop trying to enter suspend.
    
    Fix this by using the existing resuming_ports bitfield to indicate that
    resume signalling timing is taken care of.
    Check if the resume_done[port] is set before using it for timestamp
    comparison, and also clear out any resume signalling related variables
    if port is not in U0 or Resume state
    
    This issue was discovered when a PM thread busylooped, trying to runtime
    suspend the xhci USB 2 roothub on a Dell XPS
    
    Cc: stable <stable@vger.kernel.org>
    Reported-by: Daniel J Blueman <daniel@quora.org>
    Tested-by: Daniel J Blueman <daniel@quora.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

 drivers/usb/host/xhci-hub.c  |   45 +++++++++++++++++++++++++++++++++++++-----
 drivers/usb/host/xhci-ring.c |    3 ++-
 2 files changed, 42 insertions(+), 6 deletions(-)
---
The following fields have changed: 

2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
-:
4.4:
3.14:
4.5:
fbd40ea0180a2d328c5adc61414dc8bab9335ce2:
4.7:
3.15:
*************

This CVE has been resolved in 3b244a6e53dc33f6701bfde8601d7677c0c6e9e8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 3b244a6e53dc33f6701bfde8601d7677c0c6e9e8
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Dec 11 14:38:06 2015 +0200

    xhci: fix usb2 resume timing and races.
    
    [ Upstream commit f69115fdbc1ac0718e7d19ad3caa3da2ecfe1c96 ]
    
    According to USB 2 specs ports need to signal resume for at least 20ms,
    in practice even longer, before moving to U0 state.
    Both host and devices can initiate resume.
    
    On device initiated resume, a port status interrupt with the port in resume
    state in issued. The interrupt handler tags a resume_done[port]
    timestamp with current time + USB_RESUME_TIMEOUT, and kick roothub timer.
    Root hub timer requests for port status, finds the port in resume state,
    checks if resume_done[port] timestamp passed, and set port to U0 state.
    
    On host initiated resume, current code sets the port to resume state,
    sleep 20ms, and finally sets the port to U0 state. This should also
    be changed to work in a similar way as the device initiated resume, with
    timestamp tagging, but that is not yet tested and will be a separate
    fix later.
    
    There are a few issues with this approach
    
    1. A host initiated resume will also generate a resume event. The event
       handler will find the port in resume state, believe it's a device
       initiated resume, and act accordingly.
    
    2. A port status request might cut the resume signalling short if a
       get_port_status request is handled during the host resume signalling.
       The port will be found in resume state. The timestamp is not set leading
       to time_after_eq(jiffies, timestamp) returning true, as timestamp = 0.
       get_port_status will proceed with moving the port to U0.
    
    3. If an error, or anything else happens to the port during device
       initiated resume signalling it will leave all the device resume
       parameters hanging uncleared, preventing further suspend, returning
       -EBUSY, and cause the pm thread to busyloop trying to enter suspend.
    
    Fix this by using the existing resuming_ports bitfield to indicate that
    resume signalling timing is taken care of.
    Check if the resume_done[port] is set before using it for timestamp
    comparison, and also clear out any resume signalling related variables
    if port is not in U0 or Resume state
    
    This issue was discovered when a PM thread busylooped, trying to runtime
    suspend the xhci USB 2 roothub on a Dell XPS
    
    Cc: stable <stable@vger.kernel.org>
    Reported-by: Daniel J Blueman <daniel@quora.org>
    Tested-by: Daniel J Blueman <daniel@quora.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

 drivers/usb/host/xhci-hub.c  |   45 +++++++++++++++++++++++++++++++++++++-----
 drivers/usb/host/xhci-ring.c |    3 ++-
 2 files changed, 42 insertions(+), 6 deletions(-)
---
The following fields have changed: 

2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
2016-10-23:
-:
4.4:
3.14:
4.5:
fbd40ea0180a2d328c5adc61414dc8bab9335ce2:
4.7:
3.15:
*************

This CVE has been resolved in 3b244a6e53dc33f6701bfde8601d7677c0c6e9e8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 3b244a6e53dc33f6701bfde8601d7677c0c6e9e8
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Dec 11 14:38:06 2015 +0200

    xhci: fix usb2 resume timing and races.
    
    [ Upstream commit f69115fdbc1ac0718e7d19ad3caa3da2ecfe1c96 ]
    
    According to USB 2 specs ports need to signal resume for at least 20ms,
    in practice even longer, before moving to U0 state.
    Both host and devices can initiate resume.
    
    On device initiated resume, a port status interrupt with the port in resume
    state in issued. The interrupt handler tags a resume_done[port]
    timestamp with current time + USB_RESUME_TIMEOUT, and kick roothub timer.
    Root hub timer requests for port status, finds the port in resume state,
    checks if resume_done[port] timestamp passed, and set port to U0 state.
    
    On host initiated resume, current code sets the port to resume state,
    sleep 20ms, and finally sets the port to U0 state. This should also
    be changed to work in a similar way as the device initiated resume, with
    timestamp tagging, but that is not yet tested and will be a separate
    fix later.
    
    There are a few issues with this approach
    
    1. A host initiated resume will also generate a resume event. The event
       handler will find the port in resume state, believe it's a device
       initiated resume, and act accordingly.
    
    2. A port status request might cut the resume signalling short if a
       get_port_status request is handled during the host resume signalling.
       The port will be found in resume state. The timestamp is not set leading
       to time_after_eq(jiffies, timestamp) returning true, as timestamp = 0.
       get_port_status will proceed with moving the port to U0.
    
    3. If an error, or anything else happens to the port during device
       initiated resume signalling it will leave all the device resume
       parameters hanging uncleared, preventing further suspend, returning
       -EBUSY, and cause the pm thread to busyloop trying to enter suspend.
    
    Fix this by using the existing resuming_ports bitfield to indicate that
    resume signalling timing is taken care of.
    Check if the resume_done[port] is set before using it for timestamp
    comparison, and also clear out any resume signalling related variables
    if port is not in U0 or Resume state
    
    This issue was discovered when a PM thread busylooped, trying to runtime
    suspend the xhci USB 2 roothub on a Dell XPS
    
    Cc: stable <stable@vger.kernel.org>
    Reported-by: Daniel J Blueman <daniel@quora.org>
    Tested-by: Daniel J Blueman <daniel@quora.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Sasha Levin <alexander.levin@verizon.com>

 drivers/usb/host/xhci-hub.c  |   45 +++++++++++++++++++++++++++++++++++++-----
 drivers/usb/host/xhci-ring.c |    3 ++-
 2 files changed, 42 insertions(+), 6 deletions(-)
---
The following fields have changed: 
