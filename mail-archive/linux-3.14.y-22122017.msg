
-----------------------------
Stable Kernel Security Notice
2017-12-22

Stable Branch: linux-3.14.y

All linux-3.14.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-3.14.y-stable-cve-list.html

CVE(s) in report:

CVE-2017-17712
CVE-2017-17805
CVE-2017-17806
CVE-2017-17807
-----------------------------

Details:

*************
CVE-2017-17712:
*************

---
Description of fix for this vulnerability:
commit 8f659a03a0ba9289b9aeb9b4470e6fb263d6f483
Author: Mohamed Ghannam <simo.ghannam@gmail.com>
Date:   Sun Dec 10 03:50:58 2017 +0000

    net: ipv4: fix for a race condition in raw_sendmsg
    
    inet->hdrincl is racy, and could lead to uninitialized stack pointer
    usage, so its value should be read only once.
    
    Fixes: c008ba5bdc9f ("ipv4: Avoid reading user iov twice after raw_probe_proto_opt")
    Signed-off-by: Mohamed Ghannam <simo.ghannam@gmail.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv4/raw.c | 15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date
Public Date: 2017-12-16 -> 2017-12-15

CVE-2017-17805:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ecaaab5649781c5a0effdaf298a925063020500e
Author: Eric Biggers <ebiggers@google.com>
Date:   Tue Nov 28 20:56:59 2017 -0800

    crypto: salsa20 - fix blkcipher_walk API usage
    
    When asked to encrypt or decrypt 0 bytes, both the generic and x86
    implementations of Salsa20 crash in blkcipher_walk_done(), either when
    doing 'kfree(walk->buffer)' or 'free_page((unsigned long)walk->page)',
    because walk->buffer and walk->page have not been initialized.
    
    The bug is that Salsa20 is calling blkcipher_walk_done() even when
    nothing is in 'walk.nbytes'.  But blkcipher_walk_done() is only meant to
    be called when a nonzero number of bytes have been provided.
    
    The broken code is part of an optimization that tries to make only one
    call to salsa20_encrypt_bytes() to process inputs that are not evenly
    divisible by 64 bytes.  To fix the bug, just remove this "optimization"
    and use the blkcipher_walk API the same way all the other users do.
    
    Reproducer:
    
        #include <linux/if_alg.h>
        #include <sys/socket.h>
        #include <unistd.h>
    
        int main()
        {
                int algfd, reqfd;
                struct sockaddr_alg addr = {
                        .salg_type = "skcipher",
                        .salg_name = "salsa20",
                };
                char key[16] = { 0 };
    
                algfd = socket(AF_ALG, SOCK_SEQPACKET, 0);
                bind(algfd, (void *)&addr, sizeof(addr));
                reqfd = accept(algfd, 0, 0);
                setsockopt(algfd, SOL_ALG, ALG_SET_KEY, key, sizeof(key));
                read(reqfd, key, sizeof(key));
        }
    
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Fixes: eb6f13eb9f81 ("[CRYPTO] salsa20_generic: Fix multi-page processing")
    Cc: <stable@vger.kernel.org> # v2.6.25+
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

 arch/x86/crypto/salsa20_glue.c | 7 -------
 crypto/salsa20_generic.c       | 7 -------
 2 files changed, 14 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2017-12-20
CVE: CVE-2017-17805
Break Date: 2008-01-11
Break Commit: eb6f13eb9f812f5812ed5d14f241309da369dee6
Break Tag: 2.6
Linus Fix Date: 2017-11-29
Linus Commit: ecaaab5649781c5a0effdaf298a925063020500e
Linus Tag: 4.15
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2017-17806:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1
Author: Eric Biggers <ebiggers@google.com>
Date:   Tue Nov 28 18:01:38 2017 -0800

    crypto: hmac - require that the underlying hash algorithm is unkeyed
    
    Because the HMAC template didn't check that its underlying hash
    algorithm is unkeyed, trying to use "hmac(hmac(sha3-512-generic))"
    through AF_ALG or through KEYCTL_DH_COMPUTE resulted in the inner HMAC
    being used without having been keyed, resulting in sha3_update() being
    called without sha3_init(), causing a stack buffer overflow.
    
    This is a very old bug, but it seems to have only started causing real
    problems when SHA-3 support was added (requires CONFIG_CRYPTO_SHA3)
    because the innermost hash's state is ->import()ed from a zeroed buffer,
    and it just so happens that other hash algorithms are fine with that,
    but SHA-3 is not.  However, there could be arch or hardware-dependent
    hash algorithms also affected; I couldn't test everything.
    
    Fix the bug by introducing a function crypto_shash_alg_has_setkey()
    which tests whether a shash algorithm is keyed.  Then update the HMAC
    template to require that its underlying hash algorithm is unkeyed.
    
    Here is a reproducer:
    
        #include <linux/if_alg.h>
        #include <sys/socket.h>
    
        int main()
        {
            int algfd;
            struct sockaddr_alg addr = {
                .salg_type = "hash",
                .salg_name = "hmac(hmac(sha3-512-generic))",
            };
            char key[4096] = { 0 };
    
            algfd = socket(AF_ALG, SOCK_SEQPACKET, 0);
            bind(algfd, (const struct sockaddr *)&addr, sizeof(addr));
            setsockopt(algfd, SOL_ALG, ALG_SET_KEY, key, sizeof(key));
        }
    
    Here was the KASAN report from syzbot:
    
        BUG: KASAN: stack-out-of-bounds in memcpy include/linux/string.h:341  [inline]
        BUG: KASAN: stack-out-of-bounds in sha3_update+0xdf/0x2e0  crypto/sha3_generic.c:161
        Write of size 4096 at addr ffff8801cca07c40 by task syzkaller076574/3044
    
        CPU: 1 PID: 3044 Comm: syzkaller076574 Not tainted 4.14.0-mm1+ #25
        Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS  Google 01/01/2011
        Call Trace:
          __dump_stack lib/dump_stack.c:17 [inline]
          dump_stack+0x194/0x257 lib/dump_stack.c:53
          print_address_description+0x73/0x250 mm/kasan/report.c:252
          kasan_report_error mm/kasan/report.c:351 [inline]
          kasan_report+0x25b/0x340 mm/kasan/report.c:409
          check_memory_region_inline mm/kasan/kasan.c:260 [inline]
          check_memory_region+0x137/0x190 mm/kasan/kasan.c:267
          memcpy+0x37/0x50 mm/kasan/kasan.c:303
          memcpy include/linux/string.h:341 [inline]
          sha3_update+0xdf/0x2e0 crypto/sha3_generic.c:161
          crypto_shash_update+0xcb/0x220 crypto/shash.c:109
          shash_finup_unaligned+0x2a/0x60 crypto/shash.c:151
          crypto_shash_finup+0xc4/0x120 crypto/shash.c:165
          hmac_finup+0x182/0x330 crypto/hmac.c:152
          crypto_shash_finup+0xc4/0x120 crypto/shash.c:165
          shash_digest_unaligned+0x9e/0xd0 crypto/shash.c:172
          crypto_shash_digest+0xc4/0x120 crypto/shash.c:186
          hmac_setkey+0x36a/0x690 crypto/hmac.c:66
          crypto_shash_setkey+0xad/0x190 crypto/shash.c:64
          shash_async_setkey+0x47/0x60 crypto/shash.c:207
          crypto_ahash_setkey+0xaf/0x180 crypto/ahash.c:200
          hash_setkey+0x40/0x90 crypto/algif_hash.c:446
          alg_setkey crypto/af_alg.c:221 [inline]
          alg_setsockopt+0x2a1/0x350 crypto/af_alg.c:254
          SYSC_setsockopt net/socket.c:1851 [inline]
          SyS_setsockopt+0x189/0x360 net/socket.c:1830
          entry_SYSCALL_64_fastpath+0x1f/0x96
    
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

 crypto/hmac.c                  | 6 +++++-
 crypto/shash.c                 | 5 +++--
 include/crypto/internal/hash.h | 8 ++++++++
 3 files changed, 16 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2017-12-20
CVE: CVE-2017-17806
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2017-11-29
Linus Commit: af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1
Linus Tag: 4.15
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2017-17807:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 4dca6ea1d9432052afb06baf2e3ae78188a4410b
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri Dec 8 15:13:27 2017 +0000

    KEYS: add missing permission check for request_key() destination
    
    When the request_key() syscall is not passed a destination keyring, it
    links the requested key (if constructed) into the "default" request-key
    keyring.  This should require Write permission to the keyring.  However,
    there is actually no permission check.
    
    This can be abused to add keys to any keyring to which only Search
    permission is granted.  This is because Search permission allows joining
    the keyring.  keyctl_set_reqkey_keyring(KEY_REQKEY_DEFL_SESSION_KEYRING)
    then will set the default request-key keyring to the session keyring.
    Then, request_key() can be used to add keys to the keyring.
    
    Both negatively and positively instantiated keys can be added using this
    method.  Adding negative keys is trivial.  Adding a positive key is a
    bit trickier.  It requires that either /sbin/request-key positively
    instantiates the key, or that another thread adds the key to the process
    keyring at just the right time, such that request_key() misses it
    initially but then finds it in construct_alloc_key().
    
    Fix this bug by checking for Write permission to the keyring in
    construct_get_dest_keyring() when the default keyring is being used.
    
    We don't do the permission check for non-default keyrings because that
    was already done by the earlier call to lookup_user_key().  Also,
    request_key_and_link() is currently passed a 'struct key *' rather than
    a key_ref_t, so the "possessed" bit is unavailable.
    
    We also don't do the permission check for the "requestor keyring", to
    continue to support the use case described by commit 8bbf4976b59f
    ("KEYS: Alter use of key instantiation link-to-keyring argument") where
    /sbin/request-key recursively calls request_key() to add keys to the
    original requestor's destination keyring.  (I don't know of any users
    who actually do that, though...)
    
    Fixes: 3e30148c3d52 ("[PATCH] Keys: Make request-key create an authorisation key")
    Cc: <stable@vger.kernel.org>	# v2.6.13+
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

 security/keys/request_key.c | 46 ++++++++++++++++++++++++++++++++++++---------
 1 file changed, 37 insertions(+), 9 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2017-12-20
CVE: CVE-2017-17807
Break Date: 2005-06-24
Break Commit: 3e30148c3d524a9c1c63ca28261bc24c457eb07a
Break Tag: 2.6
Linus Fix Date: 2017-12-08
Linus Commit: 4dca6ea1d9432052afb06baf2e3ae78188a4410b
Linus Tag: 4.15
Stable Date: -
Stable Commit: -
Stable Tag: -
