
-----------------------------
Stable Kernel Security Notice
2016-12-09

Stable Branch: linux-4.1.y

All linux-4.1.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-4.1.y-stable-cve-list.html

CVE(s) in report:

CVE-2015-8966
CVE-2016-9120
-----------------------------

Details:

*************
CVE-2015-8966:
*************

*** This is a new CVE ***
This CVE has been resolved in 4.1.33.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 76cc404bfdc0d419c720de4daaf2584542734f42
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 28 20:47:08 2015 -0500

    [PATCH] arm: fix handling of F_OFD_... in oabi_fcntl64()
    
    Cc: stable@vger.kernel.org # 3.15+
    Reviewed-by: Jeff Layton <jeff.layton@primarydata.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 arch/arm/kernel/sys_oabi-compat.c | 73 ++++++++++++++++++++-------------------
 1 file changed, 37 insertions(+), 36 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-12-08
CVE: CVE-2015-8966
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-29
Linus Commit: 76cc404bfdc0d419c720de4daaf2584542734f42
Linus Tag: 4.4
Stable Date: 2016-09-11
Stable Commit: 469a242127b181656cb0a07de4584215bd4494fb
Stable Tag: 4.1.33

CVE-2016-9120:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9590232bb4f4cc824f3425a6e1349afbe6d6d2b7
Author: EunTaik Lee <eun.taik.lee@samsung.com>
Date:   Wed Feb 24 04:38:06 2016 +0000

    staging/android/ion : fix a race condition in the ion driver
    
    There is a use-after-free problem in the ion driver.
    This is caused by a race condition in the ion_ioctl()
    function.
    
    A handle has ref count of 1 and two tasks on different
    cpus calls ION_IOC_FREE simultaneously.
    
    cpu 0                                   cpu 1
    -------------------------------------------------------
    ion_handle_get_by_id()
    (ref == 2)
                                ion_handle_get_by_id()
                                (ref == 3)
    
    ion_free()
    (ref == 2)
    
    ion_handle_put()
    (ref == 1)
    
                                ion_free()
                                (ref == 0 so ion_handle_destroy() is
                                called
                                and the handle is freed.)
    
                                ion_handle_put() is called and it
                                decreases the slub's next free pointer
    
    The problem is detected as an unaligned access in the
    spin lock functions since it uses load exclusive
     instruction. In some cases it corrupts the slub's
    free pointer which causes a mis-aligned access to the
    next free pointer.(kmalloc returns a pointer like
    ffffc0745b4580aa). And it causes lots of other
    hard-to-debug problems.
    
    This symptom is caused since the first member in the
    ion_handle structure is the reference count and the
    ion driver decrements the reference after it has been
    freed.
    
    To fix this problem client->lock mutex is extended
    to protect all the codes that uses the handle.
    
    Signed-off-by: Eun Taik Lee <eun.taik.lee@samsung.com>
    Reviewed-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/staging/android/ion/ion.c | 55 ++++++++++++++++++++++++++++++---------
 1 file changed, 42 insertions(+), 13 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-12-08
CVE: CVE-2016-9120
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-11
Linus Commit: 9590232bb4f4cc824f3425a6e1349afbe6d6d2b7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -
