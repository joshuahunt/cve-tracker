
-----------------------------
Stable Kernel Security Notice
2018-06-26

Stable Branch: linux-4.14.y

All linux-4.14.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-4.14.y-stable-cve-list.html

CVE(s) in report:

CVE-2018-1118
CVE-2018-11412
CVE-2018-12232
-----------------------------

Details:

*************
CVE-2018-1118:
*************

This CVE has been resolved in 4.14.52.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 670ae9caaca467ea1bfd325cb2a5c98ba87f94ad
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Sat May 12 00:33:10 2018 +0300

    vhost: fix info leak due to uninitialized memory
    
    struct vhost_msg within struct vhost_msg_node is copied to userspace.
    Unfortunately it turns out on 64 bit systems vhost_msg has padding after
    type which gcc doesn't initialize, leaking 4 uninitialized bytes to
    userspace.
    
    This padding also unfortunately means 32 bit users of this interface are
    broken on a 64 bit kernel which will need to be fixed separately.
    
    Fixes: CVE-2018-1118
    Cc: stable@vger.kernel.org
    Reported-by: Kevin Easton <kevin@guarana.org>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Reported-by: syzbot+87cfa083e727a224754b@syzkaller.appspotmail.com
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>

 drivers/vhost/vhost.c | 3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Stable Date,Stable Commit,Stable Tag
Stable Date: - -> 2018-06-26
Stable Commit: - -> 7446344baafba2f23da58ac837b86770ec977b90
Stable Tag: - -> 4.14.52

CVE-2018-11412:
*************

This CVE has been resolved in 4.14.52.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 117166efb1ee8f13c38f9e96b258f16d4923f888
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Tue May 22 16:15:24 2018 -0400

    ext4: do not allow external inodes for inline data
    
    The inline data feature was implemented before we added support for
    external inodes for xattrs.  It makes no sense to support that
    combination, but the problem is that there are a number of extended
    attribute checks that are skipped if e_value_inum is non-zero.
    
    Unfortunately, the inline data code is completely e_value_inum
    unaware, and attempts to interpret the xattr fields as if it were an
    inline xattr --- at which point, Hilarty Ensues.
    
    This addresses CVE-2018-11412.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=199803
    
    Reported-by: Jann Horn <jannh@google.com>
    Reviewed-by: Andreas Dilger <adilger@dilger.ca>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Fixes: e50e5129f384 ("ext4: xattr-in-inode support")
    Cc: stable@kernel.org

 fs/ext4/inline.c | 6 ++++++
 1 file changed, 6 insertions(+)
---
The following fields have changed: Stable Date,Stable Commit,Stable Tag
Stable Date: - -> 2018-06-26
Stable Commit: - -> e81d371dac30019816a1c5a3a2c4c44bb3c68558
Stable Tag: - -> 4.14.52

CVE-2018-12232:
*************

This CVE has been resolved in 4.14.52.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6d8c50dcb029872b298eea68cc6209c866fd3e14
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Thu Jun 7 13:39:49 2018 -0700

    socket: close race condition between sock_close() and sockfs_setattr()
    
    fchownat() doesn't even hold refcnt of fd until it figures out
    fd is really needed (otherwise is ignored) and releases it after
    it resolves the path. This means sock_close() could race with
    sockfs_setattr(), which leads to a NULL pointer dereference
    since typically we set sock->sk to NULL in ->release().
    
    As pointed out by Al, this is unique to sockfs. So we can fix this
    in socket layer by acquiring inode_lock in sock_close() and
    checking against NULL in sockfs_setattr().
    
    sock_release() is called in many places, only the sock_close()
    path matters here. And fortunately, this should not affect normal
    sock_close() as it is only called when the last fd refcnt is gone.
    It only affects sock_close() with a parallel sockfs_setattr() in
    progress, which is not common.
    
    Fixes: 86741ec25462 ("net: core: Add a UID field to struct sock.")
    Reported-by: shankarapailoor <shankarapailoor@gmail.com>
    Cc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Cc: Lorenzo Colitti <lorenzo@google.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c | 18 +++++++++++++++---
 1 file changed, 15 insertions(+), 3 deletions(-)
---
The following fields have changed: Stable Date,Stable Commit,Stable Tag
Stable Date: - -> 2018-06-26
Stable Commit: - -> 91717ffc9057f38a0203a40ef36ae2e482fd7cbe
Stable Tag: - -> 4.14.52
