
-----------------------------
Stable Kernel Security Notice
2018-04-18

Stable Branch: linux-4.9.y

All linux-4.9.y CVEs:
http://joshuahunt.github.io/cve-tracker/linux-4.9.y-stable-cve-list.html

CVE(s) in report:

CVE-2017-13695
CVE-2017-17975
CVE-2018-1092
CVE-2018-1093
CVE-2018-1094
CVE-2018-1094
CVE-2018-1095
-----------------------------

Details:

*************
CVE-2017-13695:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 97f3c0a4b0579b646b6b10ae5a3d59f0441cc12c
Author: Seunghun Han <kkamagui@gmail.com>
Date:   Wed Mar 14 16:12:56 2018 -0700

    ACPICA: acpi: acpica: fix acpi operand cache leak in nseval.c
    
    I found an ACPI cache leak in ACPI early termination and boot continuing case.
    
    When early termination occurs due to malicious ACPI table, Linux kernel
    terminates ACPI function and continues to boot process. While kernel terminates
    ACPI function, kmem_cache_destroy() reports Acpi-Operand cache leak.
    
    Boot log of ACPI operand cache leak is as follows:
    >[    0.464168] ACPI: Added _OSI(Module Device)
    >[    0.467022] ACPI: Added _OSI(Processor Device)
    >[    0.469376] ACPI: Added _OSI(3.0 _SCP Extensions)
    >[    0.471647] ACPI: Added _OSI(Processor Aggregator Device)
    >[    0.477997] ACPI Error: Null stack entry at ffff880215c0aad8 (20170303/exresop-174)
    >[    0.482706] ACPI Exception: AE_AML_INTERNAL, While resolving operands for [opcode_name unavailable] (20170303/dswexec-461)
    >[    0.487503] ACPI Error: Method parse/execution failed [\DBG] (Node ffff88021710ab40), AE_AML_INTERNAL (20170303/psparse-543)
    >[    0.492136] ACPI Error: Method parse/execution failed [\_SB._INI] (Node ffff88021710a618), AE_AML_INTERNAL (20170303/psparse-543)
    >[    0.497683] ACPI: Interpreter enabled
    >[    0.499385] ACPI: (supports S0)
    >[    0.501151] ACPI: Using IOAPIC for interrupt routing
    >[    0.503342] ACPI Error: Null stack entry at ffff880215c0aad8 (20170303/exresop-174)
    >[    0.506522] ACPI Exception: AE_AML_INTERNAL, While resolving operands for [opcode_name unavailable] (20170303/dswexec-461)
    >[    0.510463] ACPI Error: Method parse/execution failed [\DBG] (Node ffff88021710ab40), AE_AML_INTERNAL (20170303/psparse-543)
    >[    0.514477] ACPI Error: Method parse/execution failed [\_PIC] (Node ffff88021710ab18), AE_AML_INTERNAL (20170303/psparse-543)
    >[    0.518867] ACPI Exception: AE_AML_INTERNAL, Evaluating _PIC (20170303/bus-991)
    >[    0.522384] kmem_cache_destroy Acpi-Operand: Slab cache still has objects
    >[    0.524597] CPU: 1 PID: 1 Comm: swapper/0 Not tainted 4.12.0-rc5 #26
    >[    0.526795] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS virtual_box 12/01/2006
    >[    0.529668] Call Trace:
    >[    0.530811]  ? dump_stack+0x5c/0x81
    >[    0.532240]  ? kmem_cache_destroy+0x1aa/0x1c0
    >[    0.533905]  ? acpi_os_delete_cache+0xa/0x10
    >[    0.535497]  ? acpi_ut_delete_caches+0x3f/0x7b
    >[    0.537237]  ? acpi_terminate+0xa/0x14
    >[    0.538701]  ? acpi_init+0x2af/0x34f
    >[    0.540008]  ? acpi_sleep_proc_init+0x27/0x27
    >[    0.541593]  ? do_one_initcall+0x4e/0x1a0
    >[    0.543008]  ? kernel_init_freeable+0x19e/0x21f
    >[    0.546202]  ? rest_init+0x80/0x80
    >[    0.547513]  ? kernel_init+0xa/0x100
    >[    0.548817]  ? ret_from_fork+0x25/0x30
    >[    0.550587] vgaarb: loaded
    >[    0.551716] EDAC MC: Ver: 3.0.0
    >[    0.553744] PCI: Probing PCI hardware
    >[    0.555038] PCI host bridge to bus 0000:00
    > ... Continue to boot and log is omitted ...
    
    I analyzed this memory leak in detail and found acpi_ns_evaluate() function
    only removes Info->return_object in AE_CTRL_RETURN_VALUE case. But, when errors
    occur, the status value is not AE_CTRL_RETURN_VALUE, and Info->return_object is
    also not null. Therefore, this causes acpi operand memory leak.
    
    This cache leak causes a security threat because an old kernel (<= 4.9) shows
    memory locations of kernel functions in stack dump. Some malicious users
    could use this information to neutralize kernel ASLR.
    
    I made a patch to fix ACPI operand cache leak.
    
    Signed-off-by: Seunghun Han <kkamagui@gmail.com>
    Signed-off-by: Erik Schmauss <erik.schmauss@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

 drivers/acpi/acpica/nseval.c | 8 ++++++++
 1 file changed, 8 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2017-08-25
CVE: CVE-2017-13695
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2018-03-18
Linus Commit: 97f3c0a4b0579b646b6b10ae5a3d59f0441cc12c
Linus Tag: 4.17-rc1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2017-17975:
*************

*** This is a new CVE ***
This CVE has been resolved in 4.9.93.
Please pull this or a newer version of the kernel to resolve this security vulnerability.

---
Description of fix for this vulnerability:
commit 50e7044535537b2a54c7ab798cd34c7f6d900bd2
Author: Oliver Neukum <oneukum@suse.com>
Date:   Mon Jan 8 09:21:07 2018 -0500

    media: usbtv: prevent double free in error case
    
    Quoting the original report:
    
    It looks like there is a double-free vulnerability in Linux usbtv driver
    on an error path of usbtv_probe function. When audio registration fails,
    usbtv_video_free function ends up freeing usbtv data structure, which
    gets freed the second time under usbtv_video_fail label.
    
    usbtv_audio_fail:
    
            usbtv_video_free(usbtv); =>
    
               v4l2_device_put(&usbtv->v4l2_dev);
    
                  => v4l2_device_put
    
                      => kref_put
    
                          => v4l2_device_release
    
      => usbtv_release (CALLBACK)
    
                                 => kfree(usbtv) (1st time)
    
    usbtv_video_fail:
    
            usb_set_intfdata(intf, NULL);
    
            usb_put_dev(usbtv->udev);
    
            kfree(usbtv); (2nd time)
    
    So, as we have refcounting, use it
    
    Reported-by: Yavuz, Tuba <tuba@ece.ufl.edu>
    Signed-off-by: Oliver Neukum <oneukum@suse.com>
    CC: stable@vger.kernel.org
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

 drivers/media/usb/usbtv/usbtv-core.c | 2 ++
 1 file changed, 2 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2017-12-29
CVE: CVE-2017-17975
Break Date: 2014-08-21
Break Commit: 63ddf68de52efaac40a9287e44266ac30e71dd36
Break Tag: 3.19
Linus Fix Date: 2018-02-26
Linus Commit: 50e7044535537b2a54c7ab798cd34c7f6d900bd2
Linus Tag: 4.17-rc1
Stable Date: 2018-04-08
Stable Commit: 50cd7759a34104c3acb510e644355d4ae8010851
Stable Tag: 4.9.93

CVE-2018-1092:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 8e4b5eae5decd9dfe5a4ee369c22028f90ab4c44
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Thu Mar 29 21:56:09 2018 -0400

    ext4: fail ext4_iget for root directory if unallocated
    
    If the root directory has an i_links_count of zero, then when the file
    system is mounted, then when ext4_fill_super() notices the problem and
    tries to call iput() the root directory in the error return path,
    ext4_evict_inode() will try to free the inode on disk, before all of
    the file system structures are set up, and this will result in an OOPS
    caused by a NULL pointer dereference.
    
    This issue has been assigned CVE-2018-1092.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=199179
    https://bugzilla.redhat.com/show_bug.cgi?id=1560777
    
    Reported-by: Wen Xu <wen.xu@gatech.edu>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Cc: stable@vger.kernel.org

 fs/ext4/inode.c | 6 ++++++
 1 file changed, 6 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2018-04-01
CVE: CVE-2018-1092
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2018-03-29
Linus Commit: 8e4b5eae5decd9dfe5a4ee369c22028f90ab4c44
Linus Tag: 4.17-rc1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2018-1093:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 7dac4a1726a9c64a517d595c40e95e2d0d135f6f
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Mon Mar 26 23:54:10 2018 -0400

    ext4: add validity checks for bitmap block numbers
    
    An privileged attacker can cause a crash by mounting a crafted ext4
    image which triggers a out-of-bounds read in the function
    ext4_valid_block_bitmap() in fs/ext4/balloc.c.
    
    This issue has been assigned CVE-2018-1093.
    
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=199181
    BugLink: https://bugzilla.redhat.com/show_bug.cgi?id=1560782
    Reported-by: Wen Xu <wen.xu@gatech.edu>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Cc: stable@vger.kernel.org

 fs/ext4/balloc.c | 16 ++++++++++++++--
 fs/ext4/ialloc.c |  7 +++++++
 2 files changed, 21 insertions(+), 2 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2018-04-01
CVE: CVE-2018-1093
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2018-03-26
Linus Commit: 7dac4a1726a9c64a517d595c40e95e2d0d135f6f
Linus Tag: 4.17-rc1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2018-1094:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit 18db4b4e6fc31eda838dd1c1296d67dbcb3dc957
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Thu Mar 29 22:10:35 2018 -0400

    ext4: don't allow r/w mounts if metadata blocks overlap the superblock
    
    If some metadata block, such as an allocation bitmap, overlaps the
    superblock, it's very likely that if the file system is mounted
    read/write, the results will not be pretty.  So disallow r/w mounts
    for file systems corrupted in this particular way.
    
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Cc: stable@vger.kernel.org

 fs/ext4/super.c | 6 ++++++
 1 file changed, 6 insertions(+)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2018-04-01
CVE: CVE-2018-1094
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2018-03-29
Linus Commit: 18db4b4e6fc31eda838dd1c1296d67dbcb3dc957
Linus Tag: 4.17-rc1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2018-1094:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit a45403b51582a87872927a3e0fc0a389c26867f1
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Thu Mar 29 22:10:31 2018 -0400

    ext4: always initialize the crc32c checksum driver
    
    The extended attribute code now uses the crc32c checksum for hashing
    purposes, so we should just always always initialize it.  We also want
    to prevent NULL pointer dereferences if one of the metadata checksum
    features is enabled after the file sytsem is originally mounted.
    
    This issue has been assigned CVE-2018-1094.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=199183
    https://bugzilla.redhat.com/show_bug.cgi?id=1560788
    
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Cc: stable@vger.kernel.org

 fs/ext4/super.c | 15 ++++++---------
 1 file changed, 6 insertions(+), 9 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2018-04-01
CVE: CVE-2018-1094
Break Date: -
Break Commit: -
Break Tag: -
Linus Fix Date: 2018-03-29
Linus Commit: a45403b51582a87872927a3e0fc0a389c26867f1
Linus Tag: 4.17-rc1
Stable Date: -
Stable Commit: -
Stable Tag: -

CVE-2018-1095:
*************

*** This is a new CVE ***
---
Description of fix for this vulnerability:
commit ce3fd194fcc6fbdc00ce095a852f22df97baa401
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Mar 29 14:31:42 2018 -0400

    ext4: limit xattr size to INT_MAX
    
    ext4 isn't validating the sizes of xattrs where the value of the xattr
    is stored in an external inode.  This is problematic because
    ->e_value_size is a u32, but ext4_xattr_get() returns an int.  A very
    large size is misinterpreted as an error code, which ext4_get_acl()
    translates into a bogus ERR_PTR() for which IS_ERR() returns false,
    causing a crash.
    
    Fix this by validating that all xattrs are <= INT_MAX bytes.
    
    This issue has been assigned CVE-2018-1095.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=199185
    https://bugzilla.redhat.com/show_bug.cgi?id=1560793
    
    Reported-by: Wen Xu <wen.xu@gatech.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Cc: stable@vger.kernel.org
    Fixes: e50e5129f384 ("ext4: xattr-in-inode support")

 fs/ext4/xattr.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)
---
The following fields have changed: Public Date,CVE,Break Date,Break Commit,Break Tag,Linus Fix Date,Linus Commit,Linus Tag,Stable Date,Stable Commit,Stable Tag
Public Date: 2018-04-01
CVE: CVE-2018-1095
Break Date: 2017-06-21
Break Commit: e50e5129f384ae282adebfb561189cdb19b81cee
Break Tag: 4.13-rc1
Linus Fix Date: 2018-03-29
Linus Commit: ce3fd194fcc6fbdc00ce095a852f22df97baa401
Linus Tag: 4.17-rc1
Stable Date: -
Stable Commit: -
Stable Tag: -
